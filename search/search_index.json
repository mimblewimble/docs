{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"./Grin","text":"<p>Simple, privacy-focused, scalable Mimblewimble chain implementation.</p> <p>Grin aims to serve as digital cash. To provide electronic transactions for all, without censorship or restrictions.</p>"},{"location":"#principles","title":"Principles","text":""},{"location":"#open","title":"Open","text":"<p>Grin is developed openly, by individual contributors all over the world. There's no company or foundation behind it, and no ICO, founder reward, pre-mine or dev-tax. The coin distribution is designed to be as fair (but not gratis) as is known to be possible.</p>"},{"location":"#private","title":"Private","text":"<p>Privacy by default. Transactions have no amount, no addresses and can be trivially aggregated. This enables complete fungibility without precluding the ability to selectively disclose information as needed.</p>"},{"location":"#scalable","title":"Scalable","text":"<p>Scales mostly with the number of users and minimally with the number of transactions. Past transactional data can be pruned, making grin drastically lightweight compared to other blockchains.</p>"},{"location":"#simple","title":"Simple","text":"<p>Minimal implementation that strives to remain as clear and simple as possible, making it easy to audit and maintain over time.</p>"},{"location":"#proven","title":"Proven","text":"<p>Mimblewimble relies on Elliptic Curve cryptography which has been tried and tested for decades.  A formal study of its security was published in one of the flagship conferences of the the International Association for Cryptologic Research.</p> <p></p>  \u30c4  <p></p>"},{"location":"about-grin/emission/","title":"Emission","text":"<p>A new grin \u30c4 is emitted every second, forever, meaning the emission rate stays constant and completely linear. As time passes, the relative dilution becomes smaller; After 10 years, it falls below 10%. After 20, below 5%. This results in a decreasing inflation rate, known as disinflation.</p> <p></p> <p>This simple design serves to ensure the long-term security and stability of grin, as well as provide a fair process of distribution. We'll set to explore those topics more thoroughly.</p> <p>The first four years of bitcoin's emission rate are identical to the first four of grin. Bitcoin had a full reward for 4 years, followed by half that for the following 4 years. So compared to a constant supply, after 8 years, the total amount of coins emitted is only 25% less. Compare that to daily price fluctuations.</p>"},{"location":"about-grin/emission/#security","title":"Security","text":"<p>The more resources being spent on mining a proof-of-work chain, the less it's susceptible to various mining attacks, most prominently 51% attacks. The financial resources deployed, or the overall mining revenue, are often referred to as security spend, which is solely determined by the incentives provided as block rewards. This reward is composed both of transactions fees, and of the block subsidy, i.e. newly generated coins.</p>"},{"location":"about-grin/emission/#block-subsidy","title":"Block Subsidy","text":"<p>Grin introduces a constant block subsidy in order to remain sufficiently secure over the coming years and decades. Block reward is then guaranteed, regardless of how full the blocks are, or how much users are willing to pay in fees for faster confirmation.</p> <p>Furthermore, this type of emission removes a lot of uncertainty, and avoids the shortcomings of the standard rapidly decreasing emission which has yet to be proven stable and effective on a longer time horizon.</p>"},{"location":"about-grin/emission/#fees","title":"Fees","text":"<p>Most blockchains are designed to generate and distribute most of the currency supply early on, to directly benefit a few, and then increasingly rely on transaction fees to incentivize mining.</p> <p>One apparent issue with this approach is that the overall security spend is likely to decrease as time passes, making the chain fundamentally less secure in the face of mining attacks, whether by selfish attackers or state actors. This results in a \"tragedy of the commons\", as individual users strive to pay a minimum amount of fees, while also depending on the security that their fees are paying for.<sup>1</sup></p> <p>Even then, the stability of a chain sustaining itself through high transaction fees is questionable.<sup>2</sup> It becomes potentially prone to a new set of mining attacks, all of which could be avoided given similar mining revenues earned through a block subsidy.</p>"},{"location":"about-grin/emission/#distribution","title":"Distribution","text":"<p>How the coin gets distributed carries significant importance. Grin was not created to quickly enrich a few early users, but to provide digital cash to all.</p>"},{"location":"about-grin/emission/#fair","title":"Fair","text":"<p>The constant issuance establishes a fair coin distribution<sup>3</sup>, where equal opportunity is given to everyone, in any point in time. New users should not feel discouraged or disadvantaged when adopting a new form money.</p> <p>In contrast, distributing a very large portion of the coins early, mostly benefits the first users but presents an unwelcoming narrative to new ones, as it assigns them a substantially smaller portion of the network's value. This in turn affects the currency's long-standing story of distribution.<sup>4</sup></p>"},{"location":"about-grin/emission/#wide","title":"Wide","text":"<p>As it stands today, the ownership of bitcoin is very centralized and will likely remain so. The situation is far worse in most other cryptocurrencies.</p> <p>Such concentration may give birth to a narrow group of individuals and organizations who may have an exorbitant amount of control over the market price. More importantly, they have the power to influence the project and its ecosystem more than any others, since early, disproportioned hoarding carries a good deal of centralization pressure.</p> <p>A constant emission aims to support grin's intent of being at the hands of many people and being used to transact freely, as a privacy-preserving medium of exchange.</p>"},{"location":"about-grin/emission/#more","title":"More","text":"<p>Additional properties of constant emission that are worthy to consider:</p> <ul> <li>One of the pitfalls of monetary inflation in fiat currencies is governments can inflate the monetary supply on a whim. This has been used to disastrous effect throughout history. A consensus-based currency solves this issue by making the emission policy well known ahead of time, and makes it difficult if not impossible to change. Removing central authorities with arbitrary control is much more what makes bitcoin important than the arbitrary amount of its capped supply. By this definition, grin is just as much \"sound money\".</li> <li>1 grin/s is very intuitive to understand.<sup>5</sup> A clear emission rule is more likely to be enforced by community consensus, unlike a blurred, complex model.</li> <li>When ownership is more evenly distributed, it likely means that more participants are holding a sizable portion of the network, and thus more users are meaningfully incentivized to advance its growth &amp; improve it.</li> <li>Early users do not profit exponentially due to a decreasing supply, but purely through increasing demand for the coin.</li> </ul> <ol> <li> <p>Bitcoin's Security Trilemma \u21a9</p> </li> <li> <p>On the Instability of Bitcoin Without the Block Reward \u21a9</p> </li> <li> <p>Grin and the Mythical Fair Launch \u21a9</p> </li> <li> <p>The Story of Distribution \u21a9</p> </li> <li> <p>Nick Szabo on Supply Predictability \u21a9</p> </li> </ol>"},{"location":"about-grin/privacy/","title":"Privacy","text":""},{"location":"about-grin/privacy/#overview","title":"Overview","text":"<p>Privacy is the foundation of a peer-to-peer electronic cash. In its essence, cash cannot distinguish between individuals, it does not reveal the amounts transferred or owned, and it holds no bias to the history of a specific coin or person. Cash is neutral, the way money should be.</p> <p>By cleverly employing mimblewimble along with several other methods, grin is able to achieve these qualities, while also keeping in mind its core design attributes of simplicity and scalability. Let's explore how and to what extent.</p>"},{"location":"about-grin/privacy/#amounts","title":"Amounts","text":"<p>First, there are no amounts. A mimblewimble implementation natively uses Confidential Transactions, meaning all amounts are hidden; They are provably impossible to uncover, yet easily verified. Even before anything else, simply hiding amounts makes any analysis significantly more challenging.</p>"},{"location":"about-grin/privacy/#addresses","title":"Addresses","text":"Notably, there are no on-chain addresses either, as transaction building is interactive. Transactions hold minimal information, and each output is simply a commitment; a point on the curve. A transaction might look like this: <p>transaction</p> Inputs Outputs 08c482407fac2.....e335bf2f10d82 085cc6944467b.....a3f1d4274b79b 097b2588fd494.....494e43580476b <p>Each transaction also carries rangeproofs and a kernel, which are mostly irrelevant for this topic.</p> <p>The above illustrates a normal transaction of 1 input and 2 outputs. The outputs (an input is also a reference to an output) are commitments, a 33 bytes blurb to any observer. There's no address to tie an identity to, and it's not clear which output is the change of the sender, and which belongs to the receiver.</p> <p>In a Bitcoin-like system, there are multiple ways in which a user might (accidentally or intentionally) link an address to his identity. Consequently, it is often trivial for analysis to link many of his addresses. Not only does his own privacy suffer, but also the entire network's privacy diminishes as a result.</p> <p>While a grin commitment is one unique output, a bitcoin address may be used to receive an unlimited amount of outputs. An interesting analogy could then be used to emphasize the difference:</p> <ul> <li>A commitment, once on-chain, is like a one-time-use address. Both of them only ever \"contain\" a single output.</li> <li>A commitment is not used to form transactions, unlike an address. A commitment is in fact a result of a transaction after it was built peer-to-peer. This makes it significantly harder to link an identity to.</li> </ul>"},{"location":"about-grin/privacy/#aggregation","title":"Aggregation","text":"Furthermore, a key concept of mimblewimble transactions is that several of them can be safely merged together, resulting in what looks like a single transaction. When done at the block level, every block essentially becomes one large transaction: <p>block</p> Inputs Outputs 08c482407fac2.....e335bf2f10d82 097b2588fd494.....494e43580476b 0857b6b7eb6a2.....a0a283ed35974 09f731e071316.....42dae69672dca 085e205dea687.....8b8aeac7562c6 085cc6944467b.....a3f1d4274b79b 09035d331b17a.....bb76238f605fb 094262a95a67a.....2f246f6ce60ce 0961ee1db49ad.....602489c9c4517 09cf2db66b748.....7327297b8e69c 09c2751af8fe9.....fc745808238b6 0900015eec3c1.....d52d78fca78de <p>The outcome is a non-interactive CoinJoin with hidden amounts. It is named non-interactive since all transactions are aggregated into one without any coordination required between the different parties. This is possible to do at the protocol level, and is simply done automatically whenever several transactions meet each other.</p> <p>An observer knows how many transactions are included in the block, since each one carries a kernel, but nothing more. Any further information is impossible to obtain by looking at the chain.</p>"},{"location":"about-grin/privacy/#cut-through","title":"Cut-through","text":"Another trick mimblewimble sets the stage for is to perform cut-through. In an example scenario where <code>A</code> sent funds to <code>B</code>, and then <code>B</code> sent them over to <code>C</code>, any trace of <code>B</code>'s involvement can be completely removed, such that the result is seen as <code>A -&gt; C</code>. <p>cut-through</p> Inputs Outputs \u21d2 Inputs Outputs A B \u21d2 A B C \u21d2 C <p>This is could be done at any level of transaction building; Before broadcast, during peer propagation, or in a block. While this trick's use cases are limited, it is a unique manifestation of the \"right to be forgotten\" in a blockchain.</p>"},{"location":"about-grin/privacy/#transaction-graph","title":"Transaction Graph","text":"<p>Despite the fact that chain analysis can extract very little (if any) information about users and outputs, it is possible to monitor peer-to-peer network activity and obtain the transactions before they're included in a block and aggregated with others. By setting up sniffing nodes connected to many peers, you can figure out which outputs are being spent by what transaction, allowing you to build a partial transaction graph by separating the aggregation done at the block level. It's unclear at this point if meaningful information could be derived from this, as the trail of data stops there.</p> <p>As of today, an almost complete transaction graph can be constructed. But as usage grows this will gradually become harder. Likewise, many privacy-enhancing techniques can be employed to easily remove linkability of outputs. Fortunately, with mimblewimble these may be added natively, such that nobody knows when a user takes extra privacy precautions to obfuscate the transaction graph, therefore no coins become \"tainted\".</p>"},{"location":"about-grin/privacy/#dandelion","title":"Dandelion","text":"<p>An important piece of information that commonly leaks is the IP address that originally sent the transaction. Normally, a transaction is just broadcast to all connected peers and immediately spreads on the network, allowing for statistical analysis to deduce where it originated. In a peer-to-peer network, this might be hard as transactions are relayed, but over multiple transactions it becomes trivial.</p> <p>To tackle this issue, grin employs Dandelion++ (originally proposed as a BIP), a protocol designed to hide a transaction's origin IP address. Dandelion has two phases; a <code>stem</code> phase and a <code>fluff</code> phase. Once a transaction is initially broadcast, it enters the <code>stem</code> phase, in which it hops between individual peers. At a random point, the transaction enters its <code>fluff</code> phase and is spread (fluffed) among the entire network.</p> <p>This makes it almost impossible to deduce a reliable IP address, and renders statistical analysis impractical.</p> <p></p> <p>Moreover, Dandelion provides an additional benefit unique to mimblewimble, as it allows for transactions to be aggregated at a very early stage. Right before a transaction starts its fluff phase, it enters a 30s waiting period in which it will be aggregated with any other transactions it meets, thus obscuring linkability of inputs and outputs that a sniffing node may have learned. However, the privacy gained from aggregation before fluffing depends on having many other transactions.</p>"},{"location":"about-grin/privacy/#afterword","title":"Afterword","text":"<p>Privacy is complex and information leakage is surprisingly easy. Privacy-preserving systems need to be extremely strong to ensure reasonable amounts of protection. Unfortunately, they often fail in practice simply because they are cumbersome to use, causing people to revert to convenience.</p> <p>Grin is committed  to long term privacy protection and will continue to advance in that direction, while remaining practical and accessible to all, regardless of a person's sophistication or available resources.</p>"},{"location":"about-grin/proof-of-work/","title":"Proof of Work","text":"<p>Proof of work is a consensus mechanism which allows anyone to extend the blockchain, by providing a piece of data that is both difficult to produce and easy to verify (according to set parameters). Proof of work also serves as the basis for the security and distribution of the coin.</p> <p>Grin has an average block time of 60 seconds and employs Cuckoo Cycle<sup>1</sup>, a memory bound proof of work algorithm, or more specifically, a variation of it named Cuckatoo that is meant to simplify ASICs.</p> Cuckoo Cycle <p>The algorithm finds length-42 cycles in a bipartite graph. The current (and final) grin PoW is Cuckatoo32+, in which a graph must have at least 2<sup>32</sup> + 2<sup>32</sup> nodes. For a comprehensive introduction, read here.</p> <p>Q: Why use a memory-hard proof of work?</p> <p>A: The point is that chips dominated by memory have rather different characteristics from computational chips; they run much cooler, dissipating less heat per unit of area. This shifts the mining cost from mostly OPEX (electricity) to mostly CAPEX (hardware cost), which delays obsolescence  and allows mining in places with higher electricity costs.</p>"},{"location":"about-grin/proof-of-work/#two-algorithms","title":"Two Algorithms","text":"<p>Grin has two PoW algorithms:</p> <ul> <li>Cuckatoo32+, The primary algorithm, meant to be ASIC-friendly. Begins at 10% and evolves to 100% over 2 years.</li> <li>Cuckaroo29, The secondary algorithm, aimed to be ASIC-resistant. Begins at 90% and decreases to 0% after 2 years.</li> </ul> <p>During the first 2 years of grin, the algorithms gradually balance themselves to satisfy the current ratio, starting from 90/10 and eventually becoming 0/100, such that the only proof of work remaining after those initial 2 years would be Cuckatoo32+. This period includes scheduled hardforks every 6 months, in which Cuckaroo29 is modified in order to interrupt possible ASIC development for it.</p> <p>The above simplifies a bit, since in practice Cuckatoo31+ was initially the primary PoW but was phased out completely after 18 months, for reasons we won\u2019t discuss here. You can read about it on this post.</p>"},{"location":"about-grin/proof-of-work/#asics","title":"ASICs","text":"<p>ASICs are special pieces of hardware especially designed to do a specific task as quickly and efficiently as possible. In our context, they solve PoW a algorithm at a much faster rate than general purpose hardware, such as consumer GPUs. The common arguments against ASICs are about how they raise the barrier to entry for mining, and the centralization that may occur when a single ASIC manufacturer has complete market dominance.</p> <p>These issues are mostly solved once a mature, competitive market for ASICs appears. However, as became apparent with bitcoin, this natural process may take time. Grin\u2019s Cuckatoo32+ simplifies ASIC design in hope to reduce the time until they become widely distributed and accessible.</p> <p>The choice of upholding some ASIC-resistance in the first 2 years was made to ensure fair initial distribution, in which no single party has a disproportional mining advantage at launch, before the market becomes populated and competitive enough.</p> <p>Let\u2019s see why encouraging ASIC development might be beneficial<sup>2</sup> in the first place:</p>"},{"location":"about-grin/proof-of-work/#security","title":"Security","text":"<p>The security of a chain depends both on the amount of capital allocated to mine it (CAPEX), and on the cost of electricity &amp; operation (OPEX). But the CAPEX is only relevant if the mining hardware's main function is to mine our specific chain and is mostly useless otherwise.</p> <p>We should want to avoid having the chain prone to attack by large hardware operators who own no stake in its success (no skin-in-the-game), since they can attack it and divert their hardware to other uses without incurring any loss to their capital.</p> <p>Therefore, to achieve optimal security, two conditions must be met:</p> <ul> <li>ASICs exist and perform significantly better than general-purpose hardware.</li> <li>Our chain has the largest economic value for its specific ASIC. If the same PoW algorithm is used by a bigger chain or serves another purpose, we encounter the same issue as described earlier.</li> </ul>"},{"location":"about-grin/proof-of-work/#inevitability","title":"Inevitability","text":"<p>There\u2019s increasingly more evidence that ASICs are inevitable, as dedicated hardware will always have ways in which it can improve upon general purpose hardware. While it is possible to make ASIC manufacturing more difficult, over a long period it is likely to end up a centralizing force in itself, as it makes the chain vulnerable to secret ASIC operations<sup>3</sup>.</p> <ol> <li> <p>Cuckoo Cycle \u21a9</p> </li> <li> <p>ASICs and Decentralization FAQ \u21a9</p> </li> <li> <p>The State of Cryptocurrency Mining \u21a9</p> </li> </ol>"},{"location":"about-grin/scalability/","title":"Scalability","text":"<p>A Mimblewimble chain is massively-prunable, which allows it to stay lightweight and cheap to verify. Its core essence is this unique balance of privacy and scalability.</p> <p>For a mimblewimble chain to be valid everything has to balance out, such that all outputs minus all inputs equals 0 (plus fees). Given that spending an output is practically just copying it to the input side of the equation, then that spent output can be completely removed from the chain and the balance still holds.</p> Only a small kernel has to be kept for each past transaction, forever proving it's validity. Let's illustrate with a trail of transactions: <p>(switch between tabs)</p> Before Inputs Outputs t r a n s a c t i o n Kernel t r a n s a c t i o n Kernel t r a n s a c t i o n Kernel t r a n s a c t i o n Kernel Cut-through Inputs Outputs t r a n s a c t i o n \u2731   \u2731 Kernel t r a n s a c t i o n \u2731  \u2731 \u2731  \u2731 Kernel t r a n s a c t i o n \u2731  \u2731 \u2731  \u2731 Kernel \u2731  \u2731 t r a n s a c t i o n \u2731  \u2731 Kernel \u2731  \u2731 After Inputs Outputs t r a n s a c t i o n Kernel t r a n s a c t i o n Kernel t r a n s a c t i o n Kernel t r a n s a c t i o n Kernel <p>An output is considered 'spent' once it is used as an input. As demonstrated above, every single input can disappear as well as every spent output. What remains is only the set of unspent outputs and all transaction kernels (~100 bytes).</p> <p>In order to verify the entire history starting from the genesis block, a verifier needs:</p> <ul> <li>Block headers</li> <li>Set of unspent outputs</li> <li>Kernels</li> </ul> <p>An output is a 33 bytes commitment accompanied by a 640 byte rangeproof.</p> <p>Following this logic, the chain mostly grows by the number of users, instead of the number of overall transactions. In fact, it often shrinks in size when more inputs are used than new outputs are created.</p> <p>Building, verifying and storing transactions requires minimal resources. Anyone can verify the entire chain on a phone or cheap hardware, and fully participate in areas with poor network connectivity.</p> <p>Comparison for bitcoiners</p> <p>At the time of this writing, there were 560M bitcoin transactions since its genesis. Anybody who wishes to verify the current state must replay each and every transaction in its history. They will go over billions of outputs to eventually derive the current set of 66M unspent outputs.</p> <p>Mimblewimble shrinks the transaction history such that a chain with bitcoin's history would be kept at around 1/4 the size. This difference becomes much more exciting if one remembers that confidential transactions are extremely resource consuming, since each output requires a large rangeproof. If the current bitcoin blockchain had hidden amounts, it's size would have been on the order of several terabytes.</p>"},{"location":"about-grin/story/","title":"Grin's Story","text":""},{"location":"about-grin/story/#mimblewimble","title":"Mimblewimble","text":"<p>On Mon Aug 01 2016 a user named <code>majorplayer</code> logged into the <code>#bitcoin-wizards</code> IRC channel, dropped a text file hosted on a Tor server and then disappeared. The document<sup>1</sup> was titled MIMBLEWIMBLE and authored under the pseudonym  Tom Elvis Jedusor. It described a protocol which is both private and extremely lightweight.</p> <p>Tom Elvis Jedusor is the French name for Tom Riddle (Lord Voldemort) from the Harry Potter book series. Mimblewimble is a tongue-tying spell.</p> <pre><code>-!- majorplayer [...] has joined #bitcoin-wizards\n&lt;majorplayer&gt; hi, i have an idea for improving privacy in bitcoin. my friend who\nknows technology says this channel would have interest\nhttp://5pdcbgndmprm4wud.onion/mimblewimble.txt\n-!- majorplayer [...] has quit [Client Quit]\n</code></pre> <p>Its title:</p> <pre><code>MIMBLEWIMBLE\nTom Elvis Jedusor\n19 July, 2016\n</code></pre> <p>The following day, users <code>nsh</code> and <code>andytoshi</code> (Andrew Poelstra) began discussing the idea proposed in the paper. The anonymous writer left several un-answered questions in the document, along with a general lack of details, so there was much to discuss. The conversation included a memorable moment:</p> <pre><code>&lt;nsh&gt; gotta be some way this is sneaky, otherwise it's too good to be true...\n&lt;andytoshi&gt; hah, yeah, i know the feeling\n</code></pre> <p>On Oct 10 2016, Andrew Poelstra published a follow-up paper<sup>2</sup> about Mimblewimble, which introduced several refinements to the original proposal and describes further its technical details.</p>"},{"location":"about-grin/story/#grin","title":"Grin","text":"<p>On Oct 20 2016, a pseudonymous developer using the name Ignotus Peverell, announced in the bitcoin wizards IRC channel that he began work on a minimal implementation of the protocol, which he named Grin.</p> <p>Ignotus Peverell is the wizard who was gifted the Cloak of Invisibility by Death.  Grin is short for the Gringotts Wizarding Bank.</p> <pre><code>-!- igno_peverell [~user@104.238.169.137] has joined #bitcoin-wizards\n&lt;igno_peverell&gt; I have a minimal implementation of MimbleWimble available. It's very far from complete but has the basics, included the summing of Pedersen commitments:\n&lt;igno_peverell&gt; https://github.com/ignopeverell/grin\n&lt;igno_peverell&gt; Any feedback or review is greatly appreciated. Thanks!\n</code></pre> <p>Igno was joined on GitHub by other developers who took interest in the project, several of them bearing pseudonyms of other Harry Potter characters.</p> <p>While Mimblewimble serves as the foundation to a blockchain, it constitutes a relatively small part of a complete cryptocurrency, and many choices were yet to be made. Thus, began the journey to create a full implementation. A community of contributors and users slowly started to form around grin.</p>"},{"location":"about-grin/story/#launch","title":"Launch","text":"<p>Grin's genesis block was mined on January 15th, 2019. It was, and still is, young and experimental. It currently goes through rapid changes, as its first 2 years include agreed-upon hardforks in 6-months intervals.</p> <p>Several months after launch, Ignotus Peverell disappeared and has yet to return.</p> <p>Developers distributed around the world are contributing to build grin, some of them funded by donations to work on the project full-time. Development will always remain completely transparent and open for anybody to join.</p> <ol> <li> <p>The Mimblewimble Whitepaper \u21a9</p> </li> <li> <p>Andrew Poelstra's Paper \u21a9</p> </li> </ol>"},{"location":"about-grin/transactions/","title":"Transactions","text":"<p>Mimblewimble transactions are interactive, meaning both parties need some kind of communication to interact with each other and exchange the necessary data to create a transaction.</p> <p>Let's see how a standard transaction flow looks like:</p> <p></p> <p>The slate is a sheet of incomplete transaction data. Wallets transfer it back and forth until the full signature is complete.</p> <p>In more detail, the process goes as follows:</p> <ol> <li> <p>An address, often referred to as a Slatepack Address, is provided by the receiver.  It is important to note; This slatepack address is only used to support peer-to-peer interaction, and is completely different from the familiar on-chain address, as it's not part of the ledger.  It is in fact an <code>ed25199</code> public key which serves a double role:</p> <ul> <li>A Tor hidden service address.</li> <li>Key to encrypt the data communicated between the sender and receiver.</li> </ul> </li> <li> <p>Sender begins building the transaction slate, encrypts it with the receiver's address (a public key), and passes it over.</p> </li> <li>Receiver adds to the slate his own data and partial signature, and delivers it back.</li> <li>Sender finalizes the transaction by adding the final data and his own part partial signature to the slate, thus completing the transaction building process. He can then post it to the chain.</li> </ol> <p>One nice side-effect of interactive transactions is that coins can't accidentally be sent into the \"void\" (a public key/address which nobody controls).</p>"},{"location":"about-grin/transactions/#how-does-it-happen","title":"How does it happen?","text":"<p>The interaction between sender and receiver happens in one of two ways.</p>"},{"location":"about-grin/transactions/#tor","title":"Tor","text":"<p>As mentioned earlier, the slatepack address is also used to derive a Tor address. By default, the sender's wallet will try to communicate with the receiver's wallet via Tor.</p> <p>If the connection succeeds, all the rest is done automatically by the two wallets and no manual action is required. The process is exactly as described above, but it all happens under the hood without further intervention.</p> <p>However, if the Tor connection between the wallets is not successful for whatever reason, grin defaults to manually exchanging slate text messages, also called slatepacks. manually.</p> Alternative Method: http <p>Synchronous communication can also happen through regular http, but it requires opening port 3415 and thus might be complicated. We don't cover it here as this method will soon be deprecated.</p>"},{"location":"about-grin/transactions/#slatepack","title":"Slatepack","text":"<p>Recall that slates are simply partial transactions. Slatepacks are slates encoded inside compact, neatly organized and encrypted text messages.</p> <p>Using this method, 2<sub>nd</sub> and 3<sub>rd</sub> steps, where the sender and receiver pass the slate to one another, would be done manually by exchanging these slatepack messages. To do so, almost every available communication channel will work; e-mail, forum, chat, social media, letters, pigeons etc. Creativity is the only limit.</p> <p>The address (public key) initially provided by the receiver will be used to the encrypt the slatepacks, so that only the transacting parties are able to see the data inside.</p> <p>Non-encrypted Slatepacks</p> <p>It is possible to skip the 1<sub>st</sub> step (providing an address) and straight up send a non-encrypted slatepack to the receiver. Keep in mind that in this case, if the communication channel is compromised or public, observers may learn some transaction information.</p>"},{"location":"about-grin/transactions/#invoice","title":"Invoice","text":"<p>Invoice transactions are built much the same way, but with a different order where the receiver initiates the transaction by asking for a certain amount of coins.</p> <ol> <li>A slatepack address is provided by the sender (optional).</li> <li>Receiver creates an invoice, requesting to be paid the specified amount. In practice he starts building the transaction slate and writes a pre-determined amount into it.</li> <li>Sender decrypts the slate to confirm the amount he is about to pay, and adds his own data and signature.</li> <li>Receiver finalizes the transaction building process and posts it to the chain.</li> </ol>"},{"location":"getting-started/build/","title":"Build","text":"<p>Read this in other languages: Espa\u00f1ol, Korean, \u65e5\u672c\u8a9e, \u7b80\u4f53\u4e2d\u6587.</p>"},{"location":"getting-started/build/#requirements","title":"Requirements","text":""},{"location":"getting-started/build/#rust","title":"Rust","text":"<p>Install using rustup.rs:</p> <pre><code>curl https://sh.rustup.rs -sSf | sh; source $HOME/.cargo/env\n</code></pre> <p>If rust is already installed, you should update to the latest version by running <code>rustup update</code>.</p> <p>Grin currently does not support a minimum version of Rust, so it's recommended to build using the latest version.</p>"},{"location":"getting-started/build/#dependencies","title":"Dependencies","text":"<p>git \u25cf tor \u25cf clang \u25cf ncurses and libs (ncurses, ncursesw5) \u25cf zlib libs (zlib1g-dev or zlib-devel) \u25cf pkg-config \u25cf libssl-dev \u25cf llvm \u25cf linux-headers (needed on Alpine linux)</p> <p>For Debian-based distributions (Ubuntu, Mint etc):</p> <pre><code>apt install build-essential git tor cmake git libgit2-dev clang libncurses5-dev libncursesw5-dev zlib1g-dev pkg-config libssl-dev llvm\n</code></pre> <p>For macOS:</p> <pre><code>xcode-select --install\nbrew install --with-toolchain llvm\nbrew install pkg-config\nbrew install openssl\n</code></pre>"},{"location":"getting-started/build/#build_1","title":"Build","text":"<pre><code>git clone https://github.com/mimblewimble/grin.git\ncd grin\ngit checkout v4.0.2\ncargo build --release\n</code></pre> <p>Grin can also be built in debug mode (using the <code>--debug</code> or the <code>--verbose</code> flags) but this will render fast sync prohibitively slow due to the large overhead of cryptographic operations.</p> Build errors \u21b4 <p>Build error: Could not compile <code>tokio-retry</code></p> <p>You might want to remove any previous rust installations to avoid conflicts. Use <code>rustup</code> to reinstall rust and cargo as described.</p> <p>NOTE: If you install rust or cargo with your package manager (most Linuxes anno 2017) you\u2019ll get too old versions. On Debian, you might have to manually compile cmake or get it from non-detault repositories.</p> <p>Build error: <code>failed to select a version for \u2018serde_json\u2019</code></p> <p>Run <code>cargo update</code> to fix this</p> <p>Build error: can\u2019t compile crate <code>bitflags</code></p> <p>Chech <code>rustc \u2013version</code> and note that bitflags requires rust 1.21 or newer. Install via <code>rustup</code> and recommended you also remove any rust/cargo installed via your package manager.</p> <p>Build error: can\u2019t locate stdarg.h</p> <p>If librocksdb-sys fails to build, try symlinking stddef.h and stdarg.h from the gcc5 include directory. So probably from /usr/lib to /usr/include</p> <p>Build error: <code>/usr/bin/ld: cannot find -lz</code></p> <p>On Ubuntu install the zlib development headers: <code>apt install zlib1g-dev</code>.</p> <p>Build error: <code>/usr/bin/ld: cannot find -lncursesw</code></p> <p>On Ubuntu install the ncurses development headers: <code>apt install libncursesw5-dev</code>.</p>"},{"location":"getting-started/build/#upgrading","title":"Upgrading","text":"<pre><code>rustup update\ncd ~/grin\ngit checkout master\ngit pull\ngit checkout [determine latest build you want e.g. v5.0.0]\ncargo build --release\n</code></pre>"},{"location":"getting-started/build/#what-was-built","title":"What was built?","text":"<p>Let's review what a successful build gets you.</p>"},{"location":"getting-started/build/#binary","title":"Binary","text":"<p><code>target/release/grin</code> is your main grin binary, located inside the build directory.</p> <p>To add it to your path, type:</p> <pre><code>export PATH=`pwd`/target/release:$PATH\n</code></pre> <p>You can then run <code>grin</code> from anywhere on your system.</p>"},{"location":"getting-started/build/#data-files","title":"Data Files","text":"<p>All data, configuration and log files created and used by grin are located by default in the hidden <code>~/.grin</code> directory (under your user home directory).</p> <p>You can modify configuration values by editing the <code>grin-server.toml</code> file, located in <code>~/.grin/main/grin-server.toml</code>.</p> <p>You can have grin create its data files in the current directory. To do this, run:</p> <pre><code>grin server config\n</code></pre> <p>This will generate a <code>grin-server.toml</code> file in the current directory. Running grin from a directory that contains <code>grin-server.toml</code> will use the values in that file which will also be pre-configured to use the current directory for all of the node's data.</p>"},{"location":"getting-started/build/#configuration","title":"Configuration","text":"<p>Grin attempts to run with sensible defaults, and can be further configured via the <code>grin-server.toml</code> file, generated by grin on its first run. The file contains documentation on each available option.</p> <p>While it is recommended that you perform all grin server configuration via <code>grin-server.toml</code>, it's also possible to supply command line switches to grin that override any settings in the file.</p> <p>For help on grin commands and their switches, try:</p> <pre><code>grin help\ngrin server help\ngrin client help\n</code></pre> Mining <p>Once your grin node is up and running, you can start mining by building and running grin-miner against your node.</p> <p>For grin-miner to be able to communicate with your grin node, make sure that you have <code>enable_stratum_server = true</code> in your <code>grin-server.toml</code> configuration file and you have a wallet listener running (<code>grin-wallet listen</code>).</p>"},{"location":"getting-started/build/#docker","title":"Docker","text":"<p>(Running grin in a container)</p> <pre><code>docker build -t grin -f etc/Dockerfile .\n</code></pre> <p>For floonet, use <code>etc/Dockerfile.floonet</code> instead</p> <p>You can bind-mount your grin cache to run inside the container.</p> <pre><code>docker run -it -d -v $HOME/.grin:/root/.grin grin\n</code></pre> <p>If you prefer to use a docker named volume, you can pass <code>-v dotgrin:/root/.grin</code> instead. Using a named volume copies default configurations upon volume creation.</p>"},{"location":"getting-started/wallet-handbook/","title":"CLI Wallet User Handbook","text":"<p>Now that you've set up your node and learned how to form a simple transaction, let's get to know the wallet more deeply. The following document is an extremely comprehensive user guide to the reference grin wallet implementation, <code>grin-wallet</code>.</p> <p>GUI Wallet</p> <p>Instructions on how to transact with a graphical user interface can be found in wallets.</p>"},{"location":"getting-started/wallet-handbook/#file-structure","title":"File Structure","text":"<p>By default, grin will create all wallet files in the hidden directory <code>.grin</code> under your home directory (i.e. <code>~/.grin</code>). You can also create and use a wallet with data files in a custom directory, as will be explained later.</p> <p>A grin wallet maintains its state in an Lightning Memory-Mapped Database (LMDB), with the master seed stored in a separate file. When creating a new wallet, the file structure should be as follows:</p> <pre><code>[wallet directory]\n\u251c\u2500\u2500 grin-wallet.log\n\u251c\u2500\u2500 grin-wallet.toml\n\u251c\u2500\u2500 tor\n\u2514\u2500\u2500 wallet_data\n    \u251c\u2500\u2500 db\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 lmdb\n    \u2502\n    \u2514\u2500\u2500 wallet.seed\n</code></pre> <ul> <li> <p><code>grin-wallet.toml</code> contains configuration information for the wallet. You can modify values within to change ports, the address of your grin node, or logging values.</p> </li> <li> <p><code>wallet.seed</code> is your master seed file; the private keys of all your outputs are derived from it, and its contents are encrypted with your wallet password. The seed file can be recovered using the seed phrase.</p> </li> <li> <p><code>tor</code> folder contains Tor configuration files used by the wallet listener. There should be no need to manipulate anything in this directory manually.</p> </li> </ul> Tor Configuration \u21b4 <p><code>grin-wallet.toml</code> contains a [tor] section used to configure values when sending or listening via TOR:</p> <ul> <li> <p><code>use_tor_listener</code> specifies whether the Tor listener should also be invoked when starting the wallet listener via <code>listen</code> (default = true).</p> </li> <li> <p><code>socks_proxy_addr</code> contains the listening address of TOR's socks proxy port. This should generally be left alone.</p> </li> </ul>"},{"location":"getting-started/wallet-handbook/#help","title":"help","text":"<p><code>grin-wallet help</code> will display all the commands and every global flag.  To get additional info about a specific command type <code>grin-wallet help [command]</code>, e.g:</p> <pre><code>grin-wallet help send\n</code></pre> <p>You can also pass <code>--help</code> or <code>-h</code>.</p>"},{"location":"getting-started/wallet-handbook/#init","title":"init","text":"<p>Before doing anything else, the wallet files need to be generated via the <code>init</code> command:</p> <pre><code>grin-wallet init\n</code></pre> <p>You'll be prompted to enter a password for the new wallet. It will be used to encrypt your <code>master.seed</code> file and you'll be asked to type it for most wallet commands.</p> <p>By default, your wallet files will be placed into <code>~/.grin</code>. Alternatively, if you'd like to run a wallet in a directory of your choice, you can create one in the current directory by using flag <code>-h</code>, e.g:</p> <pre><code>grin-wallet init -h\n</code></pre> <p>This will create all the needed data files, including <code>grin-wallet.toml</code> and <code>wallet.seed</code>, in the current directory. When running any <code>grin-wallet</code> command, grin will check the working directory if these files exist. If not, it will use the default location <code>~/.grin</code>.</p> <p>Upon a successful <code>init</code>, the wallet prints a 24-word recovery phrase, which you should write down and store in a non-digital format. This phrase can be used to re-create your master seed file if it gets lost or corrupted, or if you forget the wallet password.</p> <p>If you'd prefer to use a 12-word recovery phrase, you can use the <code>-s</code> <code>--short_wordlist</code> flag.</p>"},{"location":"getting-started/wallet-handbook/#init-recover","title":"init --recover","text":"<p>If you need to recreate your wallet from an existing seed, you can <code>init</code> a wallet with a recovery phrase using the <code>-r</code> <code>--recover</code> flag. For example, the following command initializes a wallet in the current directory.</p> <pre><code>grin-wallet init -hr\n</code></pre> <pre><code>File /home/tomriddle/wallet/grin-wallet.toml configured and created\nPlease enter your recovery phrase:\n</code></pre> <p>On the first run, the wallet will scan the entire chain and restore any outputs that belong to you.</p>"},{"location":"getting-started/wallet-handbook/#rewind_hash-and-scan-rewind_hash","title":"rewind_hash and scan rewind_hash","text":"<p>The rewind_hash command returns the hash of the wallets root public key. Ensure the transparency (spending, receiving, balance etc) of a wallet that receive grin as donations. </p> <p>The  scan_rewind_hash  command makes the wallet scan the UTXO set and return the outputs and the total of grin owned by a view wallet rewind hash. Allow everyone to scan the rewind_hash of the wallet shared publicly.</p> <ul> <li> <p>get the rewind_hash of the wallet</p> </li> <li> <p>scan of the rewind_hash of a third-party wallet <pre><code>get_rewind_hash: `grin-wallet rewind_hash`\n</code></pre></p> </li> </ul> <pre><code>scan_rewind_hash: `grin-wallet scan_rewind_hash 2c95b24de492395934a8a345440ed0ebbe67ee0025b348712a927a91c7fe58e9`\n</code></pre>"},{"location":"getting-started/wallet-handbook/#account","title":"account","text":"<p>The <code>account</code> command is used to manage wallet accounts. Let's print a list of your existing accounts:</p> <pre><code>grin-wallet account\n</code></pre> <p>Accounts could be thought of as somewhat similar to different bank accounts under the same name. Each account acts as a separate wallet, but they are all derived from the same master seed. The <code>default</code> account is created when you initialize the wallet.</p> <p>To create a new account, pass the argument <code>-c</code> <code>--create</code>.</p> <pre><code>grin-wallet account -c jedusor\n</code></pre> <p>This will create a new account called 'jedusor'.</p> <p>All <code>grin-wallet</code> commands can then be passed the argument <code>-a</code> to specify an account for the command (otherwise <code>default</code> account is used), e.g:</p> <pre><code>grin-wallet -a jedusor info\n</code></pre>"},{"location":"getting-started/wallet-handbook/#info","title":"info","text":"<p>The <code>info</code> command summarizes wallet account balance.</p> <pre><code>grin-wallet info\n</code></pre> <pre><code>____ Wallet Summary Info - Account 'default' as of height 813137 ____\n\nConfirmed Total                  | 5779.473029600\nAwaiting Confirmation (&lt; 10)     | 0.000000000\nAwaiting Finalization            | 139.851133700\nLocked by previous transaction   | 389.859133700\n-------------------------------- | -------------\nCurrently Spendable              | 5779.473029600\n</code></pre> <ul> <li>Confirmed Total is your balance including both spendable coins and those awaiting confirmation.</li> <li>Awaiting Confirmation denotes the balance from transactions that have appeared on-chain, but for which your wallet is waiting a set number of blocks before treating them as spendable (default is 10 blocks).</li> <li>Awaiting Finalization is the balance from transactions that have not yet appeared on-chain. This could be due to the other party not having broadcast the transaction yet. Also, when you are the sender of a transaction, your change output will be denoted in this field as well.</li> <li>Locked by previous transaction shows the amount of coins locked by a previous transaction you have made and that is currently awaiting finalization. This is usually made up both of the amount being sent and of the change outputs waiting to be returned back to your wallet.  Once the transaction appears on-chain, this balance unlocks and the output that was used will again become available for spending.</li> </ul>"},{"location":"getting-started/wallet-handbook/#address","title":"address","text":"<p>To get your wallet address, enter the <code>address</code> command.</p> <pre><code>grin-wallet address\n</code></pre> <pre><code>grin1chv9p4uxp3qgl6qp4w6x5p2434varqwl6fdevg6342qr\n</code></pre> <p>This command outputs the same address as using the <code>listen</code> command. The address serves a triple purpose:</p> <ul> <li>If Tor is available, it will serve as your Tor onion address.</li> <li>A key to encrypt the slatepack messages exchanged between you and your counterparty (more on that below).</li> <li>Payment proof identification.</li> </ul> <p>Address</p> <p>This is not the same concept of address that other cryptocurrencies might use; A Mimblewimble chain has no addresses. It is used purely for wallet to wallet communication.</p>"},{"location":"getting-started/wallet-handbook/#listen","title":"listen","text":"<p>The <code>listen</code> command opens up a Tor listener.</p> <pre><code>grin-wallet listen\n</code></pre> <p>This will automatically configure a Tor hidden service and makes the wallet listen to it for incoming transactions. This allows you to transact directly through Tor with other users who are sending grins to your <code>grin1...</code>. Your wallet will listen for requests until the process is cancelled (<code>&lt;Ctrl-C&gt;</code>).</p> <p><code>tor</code> or <code>tor.exe</code> need to be available on the system path.</p>"},{"location":"getting-started/wallet-handbook/#send","title":"send","text":"<p>The <code>send</code> command is the first step of building an interactive transaction. The transaction can either be an instant synchronous exchange through Tor, or it can be an asynchronous process, in which each step is done manually by exchanging easily copy-pastable strings called slatepacks.</p> <p>The choice between the two methods is handled automatically by using <code>send</code> in the form of <code>send -d &lt;address&gt; &lt;amount&gt;</code>.</p> <pre><code>grin-wallet send -d grin1dhvv9mvarqwl6fderuxp3qgl6qpphvc9p4u24347ec0mvvg6342q4w6x5r 180\n</code></pre> <p>This command tries to send <code>180</code> grins to the specified address via Tor. If both wallets are accessible, the transaction would complete immediately with no further steps required.</p> <p>If the above communication fails, for whatever reason, your wallet will output a slatepack message:</p> <pre><code>BEGINSLATEPACK. HctgNGXrJDGFY3B KrEF1meAezGjxQ6 Z93QF6Ps2m9yKCQ LfhZvpDY9ZXViM7 nDoNeMvwtYV2crr 8gDqvYDmtRfLL3n Uabao7VyWR4AuYg TXQUSWU83kEhKmr bRtdRjvpisx1LYo 9cyZGfsgsd7ZvDJ KKZPHhcPe4Eivtv cMvee3nwFFY3ZnM SoULNaHVJ38h3tZ vMXQMoMLB17L53o Xy6QQjDaG8avUBt LQq2GfGRTiUPQgn vQwFzfZPVzVKNLk\n5AFmUQFZtiVdTJV xHvc1BuAqcamerv Y76KVccPY3WGupy 4zWFpkjTH65XNiH XqQnkb3EA1iVrHc tyTJ1PWb6X6oV1k ktYiWBpatyTirRy CywPyjr6c8XLr4Q 9VoCedU5BcdFdMB ACqQTwjgVXqjHoS 58ZPKFitjeH67Ts ah6twcKtMaFmTXD i7JEQ7qV6cewgxH 2jwWFxbb98mye6A Lm9movc6Wer26L2 91WQD3cbVpAZLEs APFPtyxnWjv8n3W\nZXFLR2TPZwGc5Vt zwFUPoyWfKXasQy VVV6tbKWEEhqAZR e34M7uEwfurpUUi 9812VFPY1qw3K9b ynwQXuXMuWQCUnU s1JqWqFgSQKENUP tGCK19dys9twghA FaAc7ZXQHdMbUoL sVxVfdjE94F1Wpj M7QAM5VZuaauHdQ Mt2erFyxJ5vsYSZ hgS553UKoQL5YWX E7oRNdMDkJV6VkL i55kAQc1vWvW9ce 3MoXiBT4TJ1SyNS NVZKxgk8c. ENDSLATEPACK.\n</code></pre> <p>This message contains the data required for the receiver's wallet to process the transaction via the <code>receive</code> command. This slatepack is also encrypted for the recipient only, since you provided an address (which is a public key) by using the <code>-d</code> flag.</p> <p>Non-encrypted slatepack</p> <p>If the receiver does not want, or is not able to provide an address, you could use command <code>send</code> without the <code>-d</code> <code>--dest</code> flag.</p> <pre><code>grin-wallet send 180\n</code></pre> <p>In this case, the wallet will simply output a non-encrypted slatepack message which can be sent to anybody.</p>"},{"location":"getting-started/wallet-handbook/#more-flags","title":"more flags","text":"<ul> <li><code>-m</code> <code>--manual</code> if present, don't attempt to interact via Tor, only output slatepack message.</li> <li><code>-f</code> <code>--fluff</code> if present, ignore the dandelion relay protocol. Dandelion bounces your transactions directly through several nodes in a stem phase, after which the transaction randomly fluffs (broadcast) to the rest of the network.</li> <li><code>-n</code> <code>--no_payment_proof</code> if present, do not request the data required for a payment proof. This shortens the slatepack message length.</li> <li><code>-e</code> <code>--estimate-selection</code> if present, performs a \"dry-run\" of creating the transaction, without actually doing anything and locking the funds. It then lists different output selection strategies (outlined below) and their possible effect on your wallet outputs, if chosen.</li> <li><code>-s</code> <code>--selection</code> allows you to choose between two output selection strategies, <code>small</code> and <code>all</code>. The default strategy is <code>small</code>, which includes the minimum number of inputs to cover the amount, starting with the smallest value output. In contrast, using <code>all</code> consolidates all of your outputs into a single new output, thus reducing your wallet size, increasing operation speed and reducing the UTXO-set size of the chain. The downside is that the entire contents of your wallet remain locked until the transaction is validated on-chain, and all outputs are linked to one another, a detriment to your privacy.</li> <li><code>-b</code> <code>--ttl_blocks</code> allows you to specify a number of blocks into the future, after which a wallet should refuse to process the transaction further. This can be useful for putting time limits on transaction finalization, but please note this is not enforced at the grin protocol level; it's up to individual wallets whether they wish to respect this flag.</li> </ul>"},{"location":"getting-started/wallet-handbook/#receive","title":"receive","text":"<p>The <code>receive</code> command processes the slatepack message provided by the sender.</p> <pre><code>grin-wallet receive\n</code></pre> <p>After entering the command, you'll be prompted to input the slatepack.  Then your wallet will output another slatepack message to provide the other party, so they can <code>finalize</code> the transaction.</p> <p>Files</p> <p>When sending or receiving via slatepacks, the wallet will also create a text file containing the message it generated. Default path is <code>~/.grin/main/slatepacks</code>.</p> <p>To receive grins using a file, type:</p> <pre><code>grin-wallet receive -i $PATH/file.tx\n</code></pre>"},{"location":"getting-started/wallet-handbook/#finalize","title":"finalize","text":"<p>The <code>finalize</code> command is the final step to any slatepack transaction.</p> <pre><code>grin-wallet finalize\n</code></pre> <p>After entering the command, you'll be prompted to input the slatepack message provided to you by the receiver.</p> <p>The transaction building process will then be finalized and your wallet will post it to the network.</p> <p>If the flag <code>-n</code> <code>--nopost</code> is present, the transaction would be finalized but not posted.</p>"},{"location":"getting-started/wallet-handbook/#post","title":"post","text":"<p>Manually post a finalized transaction to the network. Either type <code>grin-wallet post</code> and enter the slatepack message into the prompt, or specify the file path using the <code>-i</code> flag.</p> <pre><code>grin-wallet post -i \"~/.grin/main/slatepacks/my_tx.S3.slatepack/\"\n</code></pre>"},{"location":"getting-started/wallet-handbook/#proof","title":"proof","text":"<p>Grin's privacy and scalability mechanics mean users no longer have the ability to simply prove a transaction has happened by pointing to it on the chain. By default, whenever a transaction sent to a destination address using <code>-d</code>, a payment proof is created.</p> <p>Payers can then use these proofs to resolve future payment disputes and prove they sent funds to the correct recipient.</p> <p>The sender can export the payment proof by specifying the transaction id (<code>-i</code>) (obtained by txs) or the tx-UUID (<code>-t</code>), and choosing the path for the proof file, e.g:</p> <pre><code>grin-wallet export_proof -i 4 \"~/Documents/proof.txt\"\n</code></pre> <p>The sender can then provide this proof to any other wallet for verification.</p> <p>Verification for e.g.</p> <pre><code>grin-wallet verify_proof $PATH/proof.txt\n</code></pre> <p>This will ensure that:</p> <ul> <li>The kernel for the transaction in the proof is validated and can be found on-chain.</li> <li>Both the sender and recipient's signatures correctly sign for the amount and the kernel.</li> </ul> <p>On top of that, if the receiver's address in the transaction belongs to the same wallet who's verifying, then the user will be informed as follows:</p> <pre><code>grin-wallet verify_proof proof.txt\n</code></pre> <pre><code>Payment proof's signatures are valid.\nThe proof's recipient address belongs to this wallet.\nCommand 'verify_proof' completed successfully\n</code></pre>"},{"location":"getting-started/wallet-handbook/#invoice","title":"invoice","text":"<p>The <code>invoice</code> command sends an invoice transaction, in which the initiator requests an amount for payment and sends that request to another party.</p> <p>Since invoice transactions require manual confirmation from the party paying the funds, they can only be created and sent to payers via slatepack.</p> <pre><code>grin-wallet invoice -d grin1dhvv9mvarqwl6fderuxp3qgl6qpphvc9p4u24347ec0mvvg6342q4w6x5r 60\n</code></pre> <p>This command will create an encrypted (since <code>-d</code> is provided) invoice, requesting a payment of <code>60</code> grins. The resulting slatepack can then be sent to the other party for them to pay.</p> <p>Upon receiving the back the slatepack from the payer, the transaction can then be finalized and posted using the <code>finalize</code> command.</p>"},{"location":"getting-started/wallet-handbook/#pay","title":"pay","text":"<p>After receiving an invoice request, the payer can use the <code>pay</code> command to decode (also decrypt if possible) the slatepack and confirm the amount of coins being requested as payment.</p> <pre><code>grin-wallet pay\n\nPlease paste your encoded slatepack message:\nBEGINSLATEPACK. P9rVoTRyKdhVsuC a5SfwQMXbtsDBwD omfeWYWwkbK9AUD k2pZvpgeXmJSUcv y9Mi81ngsCrpW9r QW226CWwbxrSprJ cCJA9cACpguBHDj eExN8vuYc1SHj9B 2Xa1BPGB77kpY9q uG9eXmaeprY6CQt PAibwfMnwxVDJFU EeQfwwSnEUADkg3 wBYXcuSVTnfJ4Jj DnqawMkmAiWvhNm WLrdZ1Vh3P6TXP6 ZgJG9pRNi51mAtU 9soyVAgvFWoEpgn VA6suegVxTsWN1r V3LQHB7bjwX5Rwa yPfqhGTLwR. ENDSLATEPACK.\n\nThis command will pay the amount specified in the invoice using your wallet's funds.\nAfter you confirm, the following will occur:\n\n* 10.000000000 of your wallet funds will be added to the transaction to pay this invoice.\n* The wallet will IMMEDIATELY attempt to send the resulting transaction to the wallet listening at: 'grin1ln4y82fw4urggk3hq0xkeqfhw3dfe6rhcv6a0v64uz4ny9epcc6qpuwx4k'.\n* If other wallet is not listening, the resulting transaction will output as a slatepack which you can manually send back to the invoice creator.\n\nPlease review the above information carefully before proceeding\n\nTo proceed, type the exact amount of the invoice as displayed above (or Q/q to quit) &gt;\n</code></pre> <p>To confirm the payment, type the exact amount in decimal, <code>10.000000000</code> in this example, into the prompt. Your wallet will then fill out the transaction slate and return a slatepack for you to provide back to the initiator, which they can then <code>finalize</code>.</p>"},{"location":"getting-started/wallet-handbook/#unpack","title":"unpack","text":"<p>Upon receiving a slatepack message or file from a party, whether in an encrypted form or not, the <code>unpack</code> command decrypts and decodes it to a bare slate JSON format (the format used by the wallet to read and construct transactions).</p> <pre><code>grin-wallet unpack\n</code></pre> <p>This prompts you for a slatepack message. to decode a file, use the <code>-i</code> flag and provide the path.</p> <p>Result:</p> <pre><code>SLATEPACK CONTENTS\n------------------\n{\n  ...\n}\n------------------\nSlatepack is encrypted for this wallet\n\nDECRYPTED SLATEPACK\n-------------------\n{\n  ...\n}\n\nDECRYPTED SLATE\n---------------\n{\n  ...\n}\nCommand 'unpack' completed successfully\n</code></pre>"},{"location":"getting-started/wallet-handbook/#outputs","title":"outputs","text":"<p>To show a list of all your wallet's outputs, type:</p> <pre><code>grin-wallet outputs\n</code></pre> <pre><code>Wallet Outputs - Account 'default' - Block Height: 814491\n---------------------------------------------------------------------------------------------------------------------------------------------------------------\n Output Commitment                                                   MMR Index  Block Height  Locked Until  Status   Coinbase?  # Confirms  Value           Tx\n===============================================================================================================================================================\n 08f4f062b99223d2d8a1ad1ae11085ab2d7b4f1bc603f9c29748f1b918861fdf23  7498573    743936        743936        Unspent  false      70556       5198.081029600  1\n---------------------------------------------------------------------------------------------------------------------------------------------------------------\n 097fe8bf1ad6a792600d5e010d0b77c40b147ea122c176476259f100a48924d40c  7832632    790025        790025        Unspent  false      24467       581.392000000   2\n---------------------------------------------------------------------------------------------------------------------------------------------------------------\n 08645896f150bfc70f36a602a7a5f41180ae8d5db42864f19f7257542cf2c7fc98  None       811501        0             Unspent  false      2991        389.859133700   9\n---------------------------------------------------------------------------------------------------------------------------------------------------------------\n</code></pre> <p>By default, only unspent outputs are listed. To show spent outputs, provide the <code>-s</code> flag.</p> <pre><code>grin-wallet -s outputs\n</code></pre>"},{"location":"getting-started/wallet-handbook/#txs","title":"txs","text":"<p>Every time an action is performed in your wallet (send, receive, even if uncompleted), an entry is added to an internal transaction log containing vital information about the transaction. Because the grin blockchain contains no identifying information whatsoever, this transaction log is necessary for your wallet to keep track of transactions. To view the contents of your transaction log, use the command:</p> <pre><code>grin-wallet txs\n</code></pre> <pre><code>Transaction Log - Account 'default' - Block Height: 814448\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n Id  Type         Shared Transaction Id                 Creation Time        TTL Cutoff Height  Confirmed?  Confirmation Time    Num.    Num.     Amount        Amount       Fee    Net           Payment   Kernel                                                              Tx\n                                                                                                                                 Inputs  Outputs  Credited      Debited             Difference    Proof                                                                         Data\n=====================================================================================================================================================================================================================================================================================\n 0   Received Tx  2b2ffc5e-8fa0-4450-b270-078df29b3e23  2020-07-28 13:18:18  None               true        2020-07-28 13:18:18  0       1        389.892       0.0          0.007  389.892       None      ddec166399348a24d2893c025b4b4d4a058f81834a663284ba23fe0bd0ac025b4b  Yes\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n 1   Sent Tx      fd9b3035-73d0-4ea3-8c3e-5d45c512ad8b  2020-08-03 15:32:19  None               true        2020-08-03 15:42:20  2       1        389.8591337   390.8661337  0.007  -1.007        Yes       0834a66310df8a8b43093c025b4b4d4a058f8188ee24d2809e338e0bd0ae9e2c2c  Yes\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n 2   Sent Tx      ea92fcce-8fa0-48d0-b270-078df2e22d24  2020-08-04 18:51:47  None               false       None                 1       1        139.8511337   389.8591337  0.008  -250.008      None      09fd95b4e40ce1c2d67376d46dc37ddec1aa0ae50ca9934ba271fff0b47510c72f  Yes\n     - Cancelled\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n</code></pre> <p>To see the inputs &amp; outputs associated with a particular transaction, as well as the payment proof associated with the transaction, use the <code>-i</code> switch and specify the id of the transaction, e.g:</p> <pre><code>grin-wallet txs -i 0\n</code></pre>"},{"location":"getting-started/wallet-handbook/#cancel","title":"cancel","text":"<p>Cancels an in-progress created transaction, freeing previously locked outputs for use again.</p> <pre><code>grin-wallet cancel -i 2\n</code></pre> <p>To specify which transaction to cancel, use the <code>-i</code> flag along with the tx id (obtained by txs) or the <code>-t</code> flag with the tx-UUID.</p>"},{"location":"getting-started/wallet-handbook/#scan","title":"scan","text":"<p>The <code>scan</code> command scans the entire UTXO (unspent tx outputs) set from the node, identifies which outputs are yours and updates your wallet state.</p> <pre><code>grin-wallet scan\n</code></pre> <p>It should not be necessary to run the scan command manually, as the wallet continually scans the outputs on the chain. However, if for some reason you believe your outputs and transactions are in an inconsistent state, you can initiate a manual scan to attempt to fix or restore them.</p> <p>flags</p> <ul> <li> <p><code>-d</code> <code>--delete-unconfirmed</code> if present, scan and cancel all pending transactions, freeing up any locked outputs.</p> </li> <li> <p><code>-h</code> <code>--start-height</code> lets you specify a block height from which to start the manual scan.</p> </li> </ul> <p>When initializing a wallet from an existing seed via the grin-wallet <code>init -r command</code>, this scan is performed automatically on the first run.</p>"},{"location":"getting-started/wallet-handbook/#recover","title":"recover","text":"<p>The <code>recover</code> command displays the existing wallet's 24 (or 12) word seed phrase.</p> <pre><code>grin-wallet recover\n</code></pre>"},{"location":"getting-started/wallet-handbook/#arguments","title":"arguments","text":"<p>There are several global wallet arguments which you can provide for every command.</p>"},{"location":"getting-started/wallet-handbook/#account_1","title":"account","text":"<p>To set the account for a wallet command, provide the <code>-a</code> argument.</p> <pre><code>grin-wallet -a jedusor info\n</code></pre>"},{"location":"getting-started/wallet-handbook/#password","title":"password","text":"<p>You could specify your password on the directly command line by providing the -p argument. Please note this will place your password in your shell's command history, so use this switch with caution.</p> <pre><code>grin-wallet -p mypass info\n</code></pre>"},{"location":"getting-started/wallet-handbook/#node","title":"node","text":"<p>The wallet needs to talk to a running grin node in order to remain up-to-date and verify its contents. By default, it tries to contact a node at 127.0.0.1:3413. To change this, either modify the value in the <code>grin_wallet.toml</code> file, or alternatively, you can provide the <code>-r</code> (se r ver) switch to wallet commands.</p> <pre><code>grin-wallet -r \"http://192.168.0.2:3413\" info\n</code></pre>"},{"location":"getting-started/wallets/","title":"Grin Wallets","text":""},{"location":"getting-started/wallets/#grim","title":"GRIM","text":"<p>Cross-platform GUI written in Rust \ud83e\udd80 supports both running a grin rust node or a remote node. Focus on usability and availability.  <sub>Windows,</sub> <sub>Linux,</sub> <sub>Android,</sub> <sub>macOS,</sub> <sub>iOS</sub></p> How to: send/receive Download <p>Download at https://gri.mw/downloads</p> <p>Telegram channel</p> Receive <ul> <li>Copy your address (<code>grin1...</code>) and provide it to the other party.  That's it. If both your wallets can communicate via Tor, the transaction is then completed automatically.</li> </ul> <p>But if there's no Tor communication, next steps are:</p> <ul> <li>The sender will provide you a Slatepack message. Paste it into the Slatepack box and click Receive.</li> <li>Copy the Slatepack message your wallet generates and give it to the sender </li> <li>Done! The sender will finalize the transaction and post it to the network, it should show up in your wallet.</li> </ul> Send <ul> <li>Click send.</li> <li>Choose the amount of grins.</li> <li>Enter the receiver's address and send.</li> </ul> <p>That's it. If both your wallets can communicate via Tor, the transaction is then completed automatically.</p> <ul> <li> <p>But if there's no Tor communication, next steps are:*</p> </li> <li> <p>Copy the Slatepack message your wallet generates and provide it to the receiver (however you want).</p> </li> <li> <p>You should get a Slatepack message back from the receiver. Paste it into the Slatepack box and click Finalize.</p> </li> </ul> <p>Done! Your wallet will now finalize the transaction and post it to the network.</p> <p></p>"},{"location":"getting-started/wallets/#grim-cross-platform-gui-for-in-rust-for-maximum-compatibility-with-original-mimblewimble-implementation-and-focus-on-usability-and-availability","title":"GRIM  Cross-platform GUI for in Rust \ud83e\udd80 for maximum compatibility with original Mimblewimble implementation and focus on usability and availability.","text":"How to: send/receive <p>Download at https://gri.mw/downloads</p> <p>Telegram channel</p> <p></p>"},{"location":"getting-started/wallets/#grin","title":"Grin++","text":"<p>GUI wallet and node written in C++  <sub>Windows,</sub> <sub>Linux,</sub> <sub>macOS</sub></p> How to: send/receive Download <p>Download at grinplusplus.github.io</p> <p>Troubleshooting</p> Receive <ul> <li>Copy your address (<code>grin1...</code>) and provide it to the other party.</li> </ul> <p></p> <p>That's it. If both your wallets can communicate via Tor, the transaction is then completed automatically.</p> <ul> <li> <p>But if there's no Tor communication, next steps are:*</p> </li> <li> <p>The sender will provide you a Slatepack message. Paste it into the Slatepack box and click Receive.</p> </li> </ul> <p></p> <ul> <li>Copy the Slatepack message your wallet generates.</li> </ul> <p></p> <ul> <li>Provide it to the sender.</li> </ul> <p>Done! The sender will finalize the transaction and post it to the network.</p> Send <ul> <li>Click send.</li> </ul> <p></p> <ul> <li>Choose the amount of grins.</li> </ul> <p></p> <ul> <li>Enter the receiver's address and send.</li> </ul> <p></p> <p>That's it. If both your wallets can communicate via Tor, the transaction is then completed automatically.</p> <p>But if there's no Tor communication, next steps are:</p> <ul> <li>Copy the Slatepack message your wallet generates and provide it to the receiver (however you want).</li> </ul> <p></p> <ul> <li>You should get a Slatepack message back from the receiver. Paste it into the Slatepack box and click Finalize.</li> </ul> <p></p> <p>Done! Your wallet will now finalize the transaction and post it to the network.</p> <p></p>"},{"location":"getting-started/wallets/#niffler","title":"Niffler","text":"<p> GUI wallet and node using the Rust implementation as back-end  <sub>Windows,</sub> <sub>Linux,</sub> <sub>macOS</sub></p> How to: send/receive Download <p>Download at github.com/grinfans/niffler/releases</p> <p>(by clicking on one of the listed download links)</p> Receive <ul> <li>Click on Receive, then Slatepack address.</li> </ul> <p></p> <ul> <li>Copy your address (<code>grin1...</code>) and provide it to the other party.</li> </ul> <p>That's it. If both your wallets can communicate via Tor, the transaction is then completed automatically.</p> <ul> <li> <p>But if there's no Tor communication, next steps are:*</p> </li> <li> <p>The sender will provide you a Slatepack message. Click again on Receive, then on Create response slatepack. Paste it into the Slatepack box and click Create response slatepack.</p> </li> </ul> <p></p> <ul> <li>Copy the new Slatepack message your wallet generates.</li> </ul> <p></p> <ul> <li>Provide it to the sender.</li> </ul> <p>Done! The sender will then finalize the transaction and post it to the network.</p> Send <ul> <li>Click on Send, then Create slatepack.</li> </ul> <p></p> <ul> <li>Enter the address and amount, then Create slatepack.</li> </ul> <p></p> <ul> <li>Copy the Slatepack message your wallet generates and provide it to the receiver (however you want).</li> </ul> <p></p> <ul> <li>You should get a Slatepack message back from the receiver.  Click on Send, then on Finalize.</li> </ul> <p></p> <ul> <li>Paste the Slatepack message into the box and confirm.</li> </ul> <p>Done! Your wallet will now finalize the transaction and post it to the network.</p> <p></p>"},{"location":"getting-started/wallets/#ironbelly","title":"Ironbelly","text":"<p> Mobile wallet  <sub>iOS,</sub> <sub>Android</sub></p> How to: send/receive Download <p>Download at https://ironbelly.app</p> Receive <p>Soon</p> Send <p>Soon</p> <p></p>"},{"location":"getting-started/wallets/#related-services","title":"Related Services","text":""},{"location":"getting-started/wallets/#grinnodelive","title":"Grinnode.live","text":"<p> Public GRIN API and sync service</p>"},{"location":"getting-started/quickstart/initialize/","title":"Initializing Node and Wallet","text":""},{"location":"getting-started/quickstart/initialize/#running-a-grin-node","title":"Running a Grin Node","text":"<p>The rest of the documentation is common for Linux, macOS and Windows.</p> <p>Running a Grin node is as simple as typing the command:</p> <pre><code>grin\n</code></pre> <p>You should see the following window:  Congratulations! \ud83c\udf89 You are now running a Grin full node. The initial sync might take anywhere from 30 minutes to a few hours depending on your connection speed and CPU performance.</p> <p>If you have a good Internet connection, you can help strengthen the network by keeping your PC running with a grin node and port 3414 open.</p> <p>All data files will be created at the hidden folder <code>~/.grin</code> (under your home directory). Inside this folder, of special interest is the file <code>grin-server.toml</code> which can be used to modify configuration options.</p>"},{"location":"getting-started/quickstart/initialize/#creating-a-grin-wallet","title":"Creating a Grin Wallet","text":"<p>While your node is syncing, let's initialize a new Grin wallet.</p> <p>In the command prompt type the following:</p> <pre><code>grin-wallet init\n</code></pre> <p>Your wallet will now ask you to create a password. Most wallet commands will require it, so you'll be typing the password quite often. In order to hide it, your keyboard input will not be displayed.</p> <pre><code>Please enter a password for your new wallet\nPassword:\nConfirm Password:\n</code></pre> <p>Next, the wallet will show your recovery-phrase:</p> <pre><code>Your recovery phrase is:\n\nfire execute festival romance just void lecture leopard balcony trick waste castle undo master custom ordinary million slam wise oil whisper mechanic episode room\n</code></pre> <p>This phrase is a list of 24 words which encode all the information needed to recover your wallet. If your computer breaks or your hard drive becomes corrupted, you can enter <code>grin-wallet init -r</code> and type the phrase to recover your grins.</p> <p>Store it safely, preferably in a non-digital format.</p>"},{"location":"getting-started/quickstart/install/","title":"Install","text":"<p>The Quickstart series will guide you in your first steps of installing a Grin node, creating a wallet, and making a transaction.</p> <p>GUI Wallet</p> <p>To use Grin with a graphical user interface, see wallets.</p> <p>We begin by downloading the precompiled binaries.</p> <ul> <li><code>grin</code> - grin node.</li> <li><code>grin-wallet</code> - command-line wallet.</li> </ul> <p>First, choose your operating system:</p> <ul> <li>Linux</li> <li>macOS</li> <li>Windows</li> </ul>"},{"location":"getting-started/quickstart/install/#linux","title":"Linux","text":"<p>Go to grin.mw/download and download the tgz files of grin and grin-wallet by clicking on their name titles. Or alternatively, type in the terminal:</p> <pre><code>wget https://github.com/mimblewimble/grin/releases/latest/download/grin-$VERSION-linux-amd64.tar.gz\nwget https://github.com/mimblewimble/grin-wallet/releases/latest/download/grin-wallet-$VERSION-linux-amd64.tar.gz\n</code></pre> <p>In every command replace <code>$VERSION</code> with the appropriate version for each binary, e.g. <code>v4.0.2</code></p> <p>To verify the release, calculate the <code>sha256sum</code> of the binaries and compare the result against their respective SHA256 HASH on the website (or in releases).</p> <pre><code>sha256sum grin-wallet-$VERSION-linux-amd64.tar.gz\nsha256sum grin-$VERSION-linux-amd64.tar.gz\n</code></pre> <p>Next, navigate to the directory where the files were downloaded and extract the binaries:</p> <pre><code>sudo tar -C /usr/local/bin -xzf grin-$VERSION-linux-amd64.tar.gz --strip-components=1\nsudo tar -C /usr/local/bin -xzf grin-wallet-$VERSION-linux-amd64.tar.gz --strip-components=1\n</code></pre> libncursesw error \u21b4 <p>If you have the following error when you start grin:</p> <pre><code>grin: error while loading shared libraries: libncursesw.so.5: cannot open shared object file: No such file or directory\n</code></pre> <p>Then install <code>libncursesw5</code>:</p> <pre><code>sudo apt install libncursesw5\n</code></pre> <p>And you're done!</p>"},{"location":"getting-started/quickstart/install/#snap-store","title":"Snap Store","text":"<p>You can also install everything as Snap package, however, note that you can't verify its content.</p> <p>To install, type:</p> <pre><code>snap install grin\n</code></pre> <p>When installed with Snap, grin-wallet is accessible using the <code>grin.wallet</code> command instead of <code>grin-wallet</code>.</p>"},{"location":"getting-started/quickstart/install/#macos","title":"macOS","text":"<p>The easiest way to install grin and grin-wallet on macOS is with homebrew.</p> <p>If you do not have homebrew installed, open the \"Terminal.app\" and paste the following line:</p> <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\"\n</code></pre> <p>This will install homebrew on your computer.</p> <p>Once it's finished, you can simply install the binaries:</p> <pre><code>brew install grin grin-wallet\n</code></pre>"},{"location":"getting-started/quickstart/install/#windows","title":"Windows","text":"<p>Go to grin.mw/download and download the zip files of grin and grin-wallet by clicking on their name titles.</p> <p>We recommend that you create a directory called <code>Grin</code> in <code>C:\\Users\\%USER%\\AppData\\Local</code>. The parent directory is where most user windows apps are installed, but if you want to put them somewhere else, that'll work too.</p> <p>In this directory, extract both binaries <code>grin.exe</code> and <code>grin-wallet.exe</code>. Then, add them to your path by typing in the terminal:</p> <pre><code>set PATH=%PATH%;C:\\Users\\%USER%\\AppData\\Local\\Grin\n</code></pre> <p>Remember to replace %USER%</p> <p>That's it, you're done!</p>"},{"location":"getting-started/quickstart/receive/","title":"Receiving Grins","text":"<p>Let's see how you can receive your first grins.</p> <p>Interactive Transactions</p> <p>The nature of Mimblewimble protocol means that the sender &amp; receiver need to interact with one another, in some way or another, in order to form transactions.</p> <p>The first step is to generate an address:</p> <pre><code>grin-wallet address\n</code></pre> <p>It is not an on-chain address, as it's only used for wallet-to-wallet communication.</p> <pre><code>grin1dhvv9mvarqwl6fderuxp3qgl6qppvhc9p4u24347ec0mvgg6342q4w6x56\n</code></pre> <p>Give it to the sender.</p> <p>To understand what comes next, you should know there are two primary ways to interact with the other party: Tor and Slatepack. A Tor connection is attempted first, but if it isn't accessible (counterparty offline, or either party doesn't have Tor service installed), then Slatepack method is automatically chosen.</p>"},{"location":"getting-started/quickstart/receive/#tor","title":"Tor","text":"<p>All you need to do is type:</p> <pre><code>grin-wallet listen\n</code></pre> <p>Done! This sets up your wallet to listen for incoming connections through Tor. Just let the sender know that your wallet is ready. You can type <code>grin-wallet info</code> to check your wallet balance.</p> <p>You can make sure your wallet is online by checking if it's reachable.</p> <p>If your wallet should always be online, see Setting up an always listening wallet.</p>"},{"location":"getting-started/quickstart/receive/#slatepack","title":"Slatepack","text":"<p>Slatepacks are encoded text messages used to transfer the data required to form a transaction, and are an alternative to a hands-off method such as Tor. The messages are easily copy-pasted and can be transferred in any communication channel imaginable: email, forum, social media, chat, letter, carrier pigeon etc.</p> <p>The text you receive from the sender should look like this:</p> <pre><code>BEGINSLATEPACK. HctgNGXrJDGFY3B KrEF1meAezGjxQ6 Z93QF6Ps2m9yKCQ LfhZvpDY9ZXViM7 nDoNeMvwtYV2crr 8gDqvYDmtRfLL3n Uabao7VyWR4AuYg TXQUSWU83kEhKmr bRtdRjvpisx1LYo 9cyZGfsgsd7ZvDJ KKZPHhcPe4Eivtv cMvee3nwFFY3ZnM SoULNaHVJ38h3tZ vMXQMoMLB17L53o Xy6QQjDaG8avUBt LQq2GfGRTiUPQgn vQwFzfZPVzVKNLk 5AFmUQFZtiVdTJV xHvc1BuAqcamerv Y76KVccPY3WGupy 4zWFpkjTH65XNiH XqQnkb3EA1iVrHc tyTJ1PWb6X6oV1k ktYiWBpatyTirRy CywPyjr6c8XLr4Q 9VoCedU5BcdFdMB ACqQTwjgVXqjHoS 58ZPKFitjeH67Ts ah6twcKtMaFmTXD i7JEQ7qV6cewgxH 2jwWFxbb98mye6A Lm9movc6Wer26L2 91WQD3cbVpAZLEs APFPtyxnWjv8n3W ZXFLR2TPZwGc5Vt zwFUPoyWfKXasQy VVV6tbKWEEhqAZR e34M7uEwfurpUUi 9812VFPY1qw3K9b ynwQXuXMuWQCUnU s1JqWqFgSQKENUP tGCK19dys9twghA FaAc7ZXQHdMbUoL sVxVfdjE94F1Wpj M7QAM5VZuaauHdQ Mt2erFyxJ5vsYSZ hgS553UKoQL5YWX E7oRNdMDkJV6VkL i55kAQc1vWvW9ce 3MoXiBT4TJ1SyNS NVZKxgk8c. ENDSLATEPACK.\n</code></pre> <p>Your next step would be to type:</p> <pre><code>grin-wallet receive\n</code></pre> <p>Then enter the message you were sent into the prompt.</p> <p>Next, your own wallet will output a beautiful Slatepack message as well:</p> <p></p> <p>Copy and send it to the other party, and that's it, you've completed your role!</p> <p>It's now in the hands of the sender to finalize and post the transaction to the network. You can tell when it's accepted by the chain by typing <code>grin-wallet info</code> and seeing if there's an amount waiting for confirmation.</p>"},{"location":"getting-started/quickstart/send/","title":"Sending Grins","text":"<p>To send grins, use the <code>send</code> command and specify both the destination address (<code>-d</code>) and the amount.</p> <pre><code>grin-wallet send -d [address] [amount]\n</code></pre> <p>Example of sending 90 grins:</p> <pre><code>grin-wallet send -d grin1dhvv9mvarqwl6fderuxp3qgl6qppvhc9p4u24347ec0mvgg6342q4w6x56 90\n</code></pre> <p>Locked Outputs</p> <p>From now on and until confirmed in the chain, the outputs used in this transaction are locked.</p> <p>The wallets will interact through Tor and complete the process automatically.</p> <p>However, If the connection wasn't successful, your wallet will output a Slatepack message which you need to provide the receiver with. The receiver then uses the <code>receive</code> command to process it (as demonstrated earlier), and returns back a Slatepack he produced himself.</p> <p>Simply type the following command:</p> <pre><code>grin-wallet finalize\n</code></pre> <p>And enter into the prompt the Slatepack message you got from the receiver.</p> <p>Your wallet will complete the transaction building process and post it to the network, along with a fee, to be included in an upcoming block. Celebrate this milestone with an unapologizing smile \u30c4</p>"},{"location":"grin-rfcs/","title":"Grin RFCs","text":"<p>This repository contains all Grin Project RFCs that have been proposed and accepted by the Grin community for further consideration.</p> <p>Grin RFCs may cover (but are not limited to) technical enhancements, changes to the governance structure or changes to project processes.</p>"},{"location":"grin-rfcs/#getting-started","title":"Getting started","text":"<p>To begin writing your own RFC or to find out more about the process and the general RFC guidelines, refer to the RFC that established this  process.</p>"},{"location":"grin-rfcs/#list-of-accepted-rfcs","title":"List of accepted RFCs","text":"Title Status Tl;dr 0001-rfc-process ACTIVE Introduce RFC process 0002-grin-governance RETIRED Articulate community values, define core and sub-teams Replaced by RFC#6. 0003-security-process ACTIVE Define community standards for ethical disclosure behaviour 0004-full-wallet-lifecycle ACTIVE Define API standard for sensitive wallet operations 0005-variable-size-kernels ACTIVE Introduce kernel variants that can be of different sizes 0006-payment-proofs ACTIVE Support generating and validating payment proofs for sender-initiated (i.e. non-invoice) transactions 0007-node-api-v2 ACTIVE Create a v2 JSON-RPC API for the Node API 0008-wallet-state-management ACTIVE Improve wallet state management 0009-enable-faster-sync ACTIVE Enable faster txhashset sync by changing output MMR commitment 0010-online-transacting-via-tor RETIRED Define standard for transacting via Tor Replaced by RFC#0015. 0011-security-team ACTIVE Establish Grin Security team 0012-compact-slates ACTIVE Introduce new compact slate format (Slate V4) 0013-nrd-kernels ACTIVE Introduce relative timelocks through \"No Recent Duplicate\" transaction kernels 0014-general-fund-guidelines ACTIVE Define general fund spending guidelines 0015-slatepack ACTIVE Universal transaction standard for Grin. Replaces RFC#0010. 0016-simplify-governance ACTIVE Simplify Grin governance model. Replaces RFC#0002. 0017-fix-fees ACTIVE Change minimum relay fees to be weight proportional, make output creation cost 0.01 Grin. 0018-fix-daa ACTIVE Change DAA (Difficulty Adjustment Algorithm) from damped simple moving average (dsma) to a weighted-target exponential moving average (wtema). Restrict the future-time-limit (FTL) window to 5 minutes. 0019-deprecate-http-tx ACTIVE Deprecating HTTP(S) as a transaction method in grin-wallet. 0020-pibd-messages ACTIVE Define new peer-to-peer messages to enable a novel sync method, using packets of self-contained partial state that can be downloaded and verified independently from each other. 0021-fix-prior-fees ACTIVE Carry the restriction of fees, to 40 bits since HF4, back to all history."},{"location":"grin-rfcs/#license","title":"License","text":"<p>Apache License 2.0</p>"},{"location":"grin-rfcs/#contributions","title":"Contributions","text":"<p>Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, shall be licensed as above, without any additional terms or conditions.</p>"},{"location":"grin-rfcs/0000-template/","title":"0000 template","text":"<ul> <li>Title: [edit and replace with a unique name like so: <code>my-awesome-proposal</code>]</li> <li>Authors: Your Name</li> <li>Start date: [edit and replace the day work begun, i.e. <code>Jan 15, 2019</code>]</li> <li>RFC PR: Edit if merged: mimblewimble/grin-rfcs#0000</li> <li>Tracking issue: [Edit if merged with link to tracking github issue]</li> </ul>"},{"location":"grin-rfcs/0000-template/#summary","title":"Summary","text":"<p>One paragraph explanation of the improvement.</p>"},{"location":"grin-rfcs/0000-template/#motivation","title":"Motivation","text":"<p>Why are we doing this? What use cases does it support? What is the expected outcome?</p>"},{"location":"grin-rfcs/0000-template/#community-level-explanation","title":"Community-level explanation","text":"<p>Explain the proposal as if it were already introduced into the Grin ecosystem and you were teaching it to another community member. That generally means:</p> <ul> <li>Introducing new named concepts.</li> <li>Explaining the feature largely in terms of examples.</li> <li>Explaining how Grin community members should think about the improvement, and how it should impact the way they interact with Grin. It should explain the impact as concretely as possible.</li> <li>If applicable, provide sample error messages, deprecation warnings, or migration guidance.</li> <li>If applicable, describe the differences between teaching this to existing Grin community members and new Grin community members.</li> </ul> <p>For implementation-oriented RFCs (e.g. for wallet), this section should focus on how wallet contributors should think about the change, and give examples of its concrete impact. For policy RFCs, this section should provide an example-driven introduction to the policy, and explain its impact in concrete terms.</p>"},{"location":"grin-rfcs/0000-template/#reference-level-explanation","title":"Reference-level explanation","text":"<p>This is the technical portion of the RFC. Explain the design in sufficient detail that:</p> <ul> <li>Its interaction with other features is clear.</li> <li>It is reasonably clear how the feature would be implemented.</li> <li>Corner cases are dissected by example.</li> </ul> <p>The section should return to the examples given in the previous section, and explain more fully how the detailed proposal makes those examples work.</p>"},{"location":"grin-rfcs/0000-template/#drawbacks","title":"Drawbacks","text":"<p>Why should we not do this?</p>"},{"location":"grin-rfcs/0000-template/#rationale-and-alternatives","title":"Rationale and alternatives","text":"<ul> <li>Why is this design the best in the space of possible designs?</li> <li>What other designs have been considered and what is the rationale for not choosing them?</li> <li>What is the impact of not doing this?</li> </ul>"},{"location":"grin-rfcs/0000-template/#prior-art","title":"Prior art","text":"<p>Discuss prior art, both the good and the bad, in relation to this proposal. A few examples of what this can include are:</p> <ul> <li>For core, node, wallet and infrastructure proposals: Does this feature exist in other projects and what experience have their community had?</li> <li>For community, ecosystem and moderation proposals: Is this done by some other community and what were their experiences with it?</li> <li>For other teams: What lessons can we learn from what other communities have done here?</li> <li>Papers: Are there any published papers or great posts that discuss this? If you have some relevant papers to refer to, this can serve as a more detailed theoretical background.</li> </ul> <p>This section is intended to encourage you as an author to think about the lessons from other languages, provide readers of your RFC with a fuller picture. If there is no prior art, that is fine - your ideas are interesting to us whether they are brand new or if it is an adaptation from other projects.</p> <p>Note that while precedent set by other projects is some motivation, it does not on its own motivate an RFC. Please also take into consideration that Grin sometimes intentionally diverges from common project features.</p>"},{"location":"grin-rfcs/0000-template/#unresolved-questions","title":"Unresolved questions","text":"<ul> <li>What parts of the design do you expect to resolve through the RFC process before this gets merged?</li> <li>What parts of the design do you expect to resolve through the implementation of this feature before stabilization?</li> <li>What related issues do you consider out of scope for this RFC that could be addressed in the future independently of the solution that comes out of this RFC?</li> </ul>"},{"location":"grin-rfcs/0000-template/#future-possibilities","title":"Future possibilities","text":"<p>Think about what the natural extension and evolution of your proposal would be and how it would affect the project and ecosystem as a whole in a holistic way. Try to use this section as a tool to more fully consider all possible interactions with the project and language in your proposal. Also consider how it fits into the road-map of the project and of the relevant sub-team.</p> <p>This is also a good place to \"dump ideas\", if they are out of scope for the RFC you are writing but otherwise related.</p> <p>If you have tried and cannot think of any future possibilities, you may simply state that you cannot think of anything.</p> <p>Note that having something written down in the future-possibilities section is not a reason to accept the current or a future RFC; such notes should be in the section on motivation or rationale in this or subsequent RFCs. The section merely provides additional information.</p>"},{"location":"grin-rfcs/0000-template/#references","title":"References","text":"<p>Include any references such as links to other documents or reference implementations.</p> <ul> <li>reference 1</li> <li>reference 2</li> </ul>"},{"location":"grin-rfcs/CODE_OF_CONDUCT/","title":"Code of Conduct","text":"<p>The Code of Conduct for this repository can be found online.</p>"},{"location":"grin-rfcs/text/0001-rfc-process/","title":"0001 rfc-process","text":"<ul> <li>Title: rfc-process</li> <li>Authors: joltz, yeastplume, lehnberg</li> <li>Start date: June 21st, 2019</li> </ul>"},{"location":"grin-rfcs/text/0001-rfc-process/#summary","title":"Summary","text":"<p>The \"RFC\" (request for comments) process is intended to provide a consistent and controlled path for improvements to be made to Grin.</p>"},{"location":"grin-rfcs/text/0001-rfc-process/#motivation","title":"Motivation","text":"<p>Many changes, including bug fixes and documentation improvements can be implemented and reviewed via the normal GitHub pull request workflow.</p> <p>Some changes though are \"substantial\", and could benefit from being put through a more formal design process in order to produce a consensus among Grin community participants and stakeholders.</p>"},{"location":"grin-rfcs/text/0001-rfc-process/#when-this-process-should-be-followed","title":"When this process should be followed","text":"<p>You need to follow this process if you intend to make \"substantial\" changes to the Grin codebase or governance process. What constitutes a \"substantial\" change may evolve based on community norms and individual definitions of sub-teams, but may include the following.</p> <ul> <li>Any semantic or syntactic change to the wallet, node, miner, or underlying crypto libraries that is not a bugfix.</li> <li>Major changes in ecosystem content such as the docs, site or explorer.</li> <li>Removing Grin features, including those that are feature-gated.</li> </ul> <p>Some changes do not require an RFC:</p> <ul> <li>Rephrasing, reorganizing, refactoring, or changes that are not visible to Grin's users.</li> <li>Additions that strictly improve objective, numerical quality criteria (warning removal, speedup, better platform coverage, more parallelism, trap more errors, etc.)</li> <li>Additions only likely to be noticed by other developers-of-grin, invisible to users-of-grin.</li> </ul> <p>If you submit a pull request to implement a new feature without going through the RFC process, it may be closed with a polite request to submit an RFC first.</p>"},{"location":"grin-rfcs/text/0001-rfc-process/#team-specific-guidelines","title":"Team specific guidelines","text":"<p>To be added here once available.</p>"},{"location":"grin-rfcs/text/0001-rfc-process/#before-creating-an-rfc","title":"Before creating an RFC","text":"<p>A hastily-proposed RFC can hurt its chances of acceptance. Low quality proposals, proposals for previously-rejected features, or those that don't fit into the near-term roadmap, may be quickly rejected, which can be demotivating for the unprepared contributor. Laying some groundwork ahead of the RFC can make the process smoother.</p> <p>Although there is no single way to prepare for submitting an RFC, it is generally a good idea to pursue feedback from other project contributors beforehand, to ascertain that the RFC may be desirable; having a consistent impact on the project requires concerted effort toward consensus-building.</p> <p>Ways to prepare and pave the way for writing and submitting an RFC include discussing the topic or posting \"pre-RFCs\" to our forum for feedback.</p> <p>As a rule of thumb, receiving encouraging feedback from long-standing project contributors, and particularly members of the relevant team (if applicable) is a good indication that the RFC is worth pursuing.</p>"},{"location":"grin-rfcs/text/0001-rfc-process/#process-description","title":"Process description","text":"<p>In order to make a \"substantial\" change to Grin, one must first get an RFC merged into the RFC repo as a markdown file. At that point the RFC is \"active\" and may be implemented with the goal of eventual inclusion into Grin.</p> <p></p>"},{"location":"grin-rfcs/text/0001-rfc-process/#stages-in-detail","title":"Stages in detail","text":""},{"location":"grin-rfcs/text/0001-rfc-process/#submission","title":"Submission","text":"<ul> <li>Fork the RFC repo https://github.com/mimblewimble/grin-rfcs</li> <li>Copy <code>0000-template.md</code> to <code>text/0000-my-feature.md</code> (where \"my-feature\" is descriptive. don't assign an RFC number yet).</li> <li>If you include any assets, do so as <code>/assets/0000-asset-description.xxx</code></li> <li>Write the RFC according to the template instructions.</li> <li>Submit a pull request. As a pull request the RFC will receive design feedback from the larger community, and the author should be prepared to revise it in response.</li> </ul>"},{"location":"grin-rfcs/text/0001-rfc-process/#draft","title":"Draft","text":"<ul> <li>Each pull request will be labeled with the most relevant team, which will lead to it being triaged by that team and is assigned a shepherd from this team. The shepherd ensures the RFC progresses through the process and that a decision is reached, but they themselves do not make this decision.</li> <li>As the author, you build consensus and integrate feedback. RFCs that have broad support are much more likely to make progress than those that don't receive any comments. They are encouraged to reach out to the RFC shepherd in particular to get help identifying stakeholders and obstacles.</li> <li>The relevant team discuss the RFC pull request, as much as possible in the comment thread of the pull request itself. Offline discussion will be summarized on the pull request comment thread.</li> <li>RFCs rarely go through this process unchanged, especially as alternatives and drawbacks are shown. As an author you can make edits, big and small, to the RFC to clarify or change the design,but make changes as new commits to the pull request, and leave a comment on the pull request explaining your changes. Specifically, do not squash or rebase commits after they are visible on the pull request.</li> </ul>"},{"location":"grin-rfcs/text/0001-rfc-process/#final-comment-period-fcp","title":"Final Comment Period (FCP)","text":"<ul> <li>At some point, a member of the assigned team will propose a \"motion for final comment period\" (FCP), along with a disposition for the RFC (merge, close, or postpone).</li> <li>This step is taken when enough of the tradeoffs have been discussed that the team is in a position to make a decision. That does not require consensus amongst all participants in the RFC thread (which is usually impossible). However, the argument supporting the disposition on the RFC needs to have already been clearly articulated, and there should not be a strong consensus against that position outside of the team. Team members use their best judgment in taking this step, and the FCP itself ensures there is ample time and notification for stakeholders to push back if it is made prematurely.</li> <li>For RFCs with lengthy discussion, the motion to FCP is usually preceded by a summary comment trying to lay out the current state of the discussion and major tradeoffs/points of disagreement.</li> <li>The FCP lasts ten calendar days, so that it is open for at least 5 business days. It is also advertised widely (i.e. in Grin News). This way all stakeholders have a chance to lodge any final objections before a decision is reached.</li> <li>In most cases, the FCP period is quiet, and the RFC is either merged or closed. However, sometimes substantial new arguments or ideas are raised, the FCP is canceled, and the RFC goes back into draft mode.</li> </ul>"},{"location":"grin-rfcs/text/0001-rfc-process/#active","title":"Active","text":"<ul> <li>As FCP concludes and there are no objections to accepting the RFC, it gets merged into <code>/grin-rfcs</code> and becomes \"active\".</li> <li>Before merging, the shepherd:<ul> <li>updates the RFC to give it an RFC number (which is the same as the number of the initial Pull Request).</li> <li>Renames the markdown file accordingly and any accompanied assets.</li> <li>If a tracking issue on the repo affected by the RFC has created, it is linked to in the header.</li> </ul> </li> <li>Once active, the authors may then implement it and submit the feature as a pull request to the relevant repo.</li> <li>Being \"active\" is not a rubber stamp, and in particular still does not mean the feature will ultimately be merged; it does mean that in principle all the major stakeholders have agreed to the feature and are amenable to merging it.</li> <li>Furthermore, the fact that a given RFC has been accepted and is \"active\" implies nothing about what priority is assigned to its implementation, nor does it imply anything about whether a developer has been assigned the task of implementing the feature.</li> <li>While it is not necessary that the author of the RFC also write the implementation, it is by far the most effective way to see an RFC through to completion: authors should not expect that other project contributors will take on responsibility for implementing their accepted feature.</li> <li>Modifications to \"active\" RFCs can be done in follow-up pull requests. We strive to write each RFC in a manner that it will reflect the final design of the feature; but the nature of software development means that we cannot expect every merged RFC to actually reflect what the end result will be at the time of implementation.</li> <li>In general, once accepted, RFCs should not be substantially changed. Only very minor changes should be submitted as amendments. More substantial changes should be new RFCs, with a note added to the original RFC. Exactly what counts as a \"very minor change\" is up to the team to decide; check team specific guidelines for more details.</li> </ul>"},{"location":"grin-rfcs/text/0001-rfc-process/#postponed","title":"Postponed","text":"<ul> <li>Some RFC pull requests are tagged with the \"postponed\" label when they are closed (as part of the rejection process).</li> <li>An RFC closed with \"postponed\" is marked as such because we want neither to think about evaluating the proposal nor about implementing the described feature until some time in the future, and we believe that we can afford to wait until then to do so.</li> <li>Postponed pull requests may be re-opened when the time is right. We don't have any formal process for that, you should ask members of the relevant team.</li> <li>Usually an RFC pull request marked as \"postponed\" has already passed an informal first round of evaluation, namely the round of \"do we think we would ever possibly consider making this change, as outlined in the RFC pull request, or some semi-obvious variation of it.\" (When the answer to the latter question is \"no\", then the appropriate response is to close the RFC, not postpone it.)</li> </ul>"},{"location":"grin-rfcs/text/0001-rfc-process/#closed","title":"Closed","text":"<ul> <li>A proposed RFC can be closed at any time before reaching \"active\" state. This is done by closing the pull request itself. This would happen for example if there is no support in the community for the proposal or if there are other underlying reasons why this is not a change the community wants to make.</li> </ul>"},{"location":"grin-rfcs/text/0001-rfc-process/#changes-to-the-rfc-process","title":"Changes to the RFC process","text":"<p>In the spirit of the proposed process itself, a future \"substantial\" overhaul to the RFC process should be opened as a new RFC rather than making edits to this RFC. Minor changes can be made by opening pull requests against this document.</p> <p>As the RFC process is something that should be consistent across all teams and the project as a whole, changes to the process fall under Core's remit. As they evaluate proposals to modify the process, they are expected to consult with teams, and other stakeholders using or being affected by the process.</p>"},{"location":"grin-rfcs/text/0001-rfc-process/#drawbacks","title":"Drawbacks","text":"<ul> <li>May not encourage sufficient community engagement</li> <li>May slow down needed features</li> <li>May allow some features to be included too quickly</li> </ul>"},{"location":"grin-rfcs/text/0001-rfc-process/#rationale-and-alternatives","title":"Rationale and alternatives","text":"<p>Alternatively, retain the current informal RFC process. The proposed RFC process is designed to improve over the informal process in the following ways:</p> <ul> <li>Discourage unactionable or vague RFCs</li> <li>Ensure that all serious RFCs are considered equally</li> <li>Improve transparency for how new features are added to Grin</li> <li>Give confidence to those with a stake in Grin's development that they understand why new features are being merged</li> <li>Assist the Grin community with feature and release planning.</li> </ul> <p>As an alternative, we could adopt an even stricter RFC process than the one proposed here. We could for example look to Bitcoin's BIP or Python's PEP process for inspiration.</p>"},{"location":"grin-rfcs/text/0001-rfc-process/#prior-art","title":"Prior art","text":"<p>This process draws inspiration extensively from Rust's RFC process, where much credit for the process is due.</p> <p>Most decentralized cryptocurrency projects have adopted an RFC-like process to manage adding new features.</p> <p>Bitcoin uses BIPs which are an adaptation of Python's PEPs. These processes are similar to the Rust RFC process which has had success in the Rust community as well as in other cryptocurrency projects like Peercoin.</p>"},{"location":"grin-rfcs/text/0001-rfc-process/#unresolved-questions","title":"Unresolved questions","text":"<ol> <li>Does this RFC strike a favorable balance between formality and agility?</li> <li>Does this RFC address the issues with the current informal process adequately?</li> </ol>"},{"location":"grin-rfcs/text/0001-rfc-process/#future-possibilities","title":"Future possibilities","text":"<p>This proposal was initially based on an RFC process for codebase development. As the process evolves it will have a larger impact in the governance of Grin. This is a relatively new area of exploration as governance processes can have wide ranging impacts on the ecosystem as a whole.</p> <p>Just as it is important to hone the language to support the development process and life-cycle, it is also important to sharpen the language to support governance processes and life-cycles for the Grin ecosystem.</p>"},{"location":"grin-rfcs/text/0001-rfc-process/#references","title":"References","text":"<ul> <li>https://github.com/rust-lang/rfcs</li> <li>https://github.com/bitcoin/bips/blob/master/bip-0001.mediawiki</li> <li>https://www.python.org/dev/peps/pep-0001/</li> </ul>"},{"location":"grin-rfcs/text/0002-grin-governance/","title":"0002 grin-governance","text":"<ul> <li>Title: grin-governance</li> <li>Authors: lehnberg, yeastplume</li> <li>Start date: June 24th, 2019</li> <li>Tracking issue: mimblewimble/grin-pm/#167</li> </ul>"},{"location":"grin-rfcs/text/0002-grin-governance/#retired","title":"RETIRED","text":"<p>This RFC has been retired and has been superseded by RFC#0016: simplify-governance.</p>"},{"location":"grin-rfcs/text/0002-grin-governance/#summary","title":"Summary","text":"<p>Evolve Grin's governance: - Define general community principles; - Convert council into core team and define its responsibilities and processes; - Introduce RFC process; - Introduce self-governing teams that steward and guide work in each of their focus areas.</p>"},{"location":"grin-rfcs/text/0002-grin-governance/#motivation","title":"Motivation","text":""},{"location":"grin-rfcs/text/0002-grin-governance/#background","title":"Background","text":"<p>Grin's governance today consists of the Grin Technocratic Council, and the rest of the community. The council came to be as there was a need for some sub-set of community members to manage the multi-sig keys of the Grin General Fund, and it became a modest first pass at a governance structure. Over time, it has come to be that a lot of responsibilities and day to day tasks are handled by Grin council members. This puts a heavy workload on council members, but it also inhibits other members of the community from becoming more engaged, contributing more, and becoming recognized for it. Naturally this implies that either the council would have to grow large in order to be able to fit all the members of the community that deserve recognition for their contributions, or that we end up not rewarding active contributors properly.</p> <p>In addition, as most decisions up to this point have been taken in the bi-weekly meetings, it's come to be that decisions take time to materialize: It can take up to 14 days just to have the initial conversation and sometimes multiples of that to reach an agreement. In these meetings the entire active community ends up participating in every discussion in a synchronous fashion that often does not end up being productive.</p> <p>We have also struggled to answer more fundamental questions about Grin's governance, as in how decisions are made, who has authority to make these, and what the path is for a community member who would like to take on greater responsibilities.</p> <p>This is a proposal to evolve our governance process.</p>"},{"location":"grin-rfcs/text/0002-grin-governance/#objectives","title":"Objectives","text":"<ul> <li>Reward and recognize contributions better. Offer different ways to become more engaged and give better recognition for work</li> <li>Empower more to contribute. Encourage more community members to participate, facilitate more initiative.</li> <li>Make Grin less centralized. Rather than relying on a small group of people, share responsibilities and make the project more resilient against shocks.</li> <li>Create a more transparent process.</li> </ul>"},{"location":"grin-rfcs/text/0002-grin-governance/#not-objectives","title":"Not objectives","text":"<ul> <li>Do not create fiefdoms. Do not create emperors. Nobody is the boss of anybody else.</li> <li>Do not create bureaucracy for the sake of bureaucracy. Do not impose death by a thousand papercuts or let forms and administration get in the way of making progress.</li> <li>Do not discourage contributions. Nobody can prevent someone else from doing work. Anyone can contribute in which ever way they find meaningful. You do not need to ask for permission.</li> </ul>"},{"location":"grin-rfcs/text/0002-grin-governance/#community-level-explanation","title":"Community-level explanation","text":"<p>This proposal outlines a set of loose principles to guide the work we do. While some of these may already be in use, they might not have been articulated before. It converts the council into a core team, and outlines its responsibilities for the first time. In addition, it's proposed that additional teams are introduced alongside it, as well as an RFC process. An initial teams breakdown is suggested, and the proposal concludes with a path to adoption.</p>"},{"location":"grin-rfcs/text/0002-grin-governance/#general-principles","title":"General principles","text":"<ul> <li>Lead by example. \"Cypherpunks write code.\" We don't tell others what to do. We do what we can, and if we need to we ask for help. We suggest, but never command. We act as we want others to act.</li> <li>Not a democracy. We are evaluated based on the work we do. It's not a popularity contest, and the majority is not always right. Community members are here by their free will, participation is optional.</li> <li>Influence is measured by recent and not historical work. We are grateful for and respect historical contributions, but they do not lead to lifelong positions of authority. Influence is earned by making contributions consistently over time, allowing new contributors to join the ranks of the old.</li> <li>Transparency. Where possible, discussions and decisions are made in the open. We have nothing to hide, and we do not try to limit oversight unless there's a defensible reason to do so.</li> <li>Keep things lightweight. We strive to only put in place the minimal structure and organization that's needed, neither more nor less.</li> <li>Groups organize themselves. Structures do not need to be imposed tops down, and we recognise that what works for one group will not necessarily work for the other. Teams self-organize and define their own workflows and processes as they see fit.</li> <li>Consensus-seeking decision making. Voting creates winners and losers, and is polarizing. We recognize there are trade offs with everything and rarely any single right answer. This does not mean design by committee. We seek consensus through dialogue and discussion, but where there is a lack of consensus, we do not let it block us indefinitely. We're ready to make judgment calls to the best of our abilities.</li> <li>We speak for ourselves. We can only speak in the name of ourselves, as contributors to the project. We do not write blog posts, articles, tweets, or give interviews speaking on behalf of the project as a whole. Grin itself has no single voice.</li> <li>There's no need to ask for permission. We are not afraid to take decisions. We ask for feedback and opinions from others, but we do not need to ask for somebody's permission. If we believe it's in the best interest of  Grin, we act, and are accountable for our actions.</li> <li>Mistakes are tolerated. As with any organization structure, mistakes happen. This is understood, and mistakes are accepted. We try to learn from them and improve. We assume we all act in good faith, until proven otherwise.</li> </ul>"},{"location":"grin-rfcs/text/0002-grin-governance/#core-team","title":"Core team","text":"<p>The existing grin council is proposed to be renamed to core team.</p> <p>Over time, it's intended to be a broad representation of the wider community with diverse stakeholders.</p>"},{"location":"grin-rfcs/text/0002-grin-governance/#responsibilities","title":"Responsibilities","text":"<p>The core team leads the wider Grin project as a whole. In particular:</p> <ul> <li>Sets overall direction and vision. Values and philosophies. Steering towards use cases and targets.</li> <li>Sets priorities and plans releases. Maintains high level planning, roadmaps, focus areas, decides on pace and the release schedule.</li> <li>Work on broader, cross-sectional issues. What falls in-between teams, taking a global view.</li> <li>Adds and removes teams. While proposals for new teams can come from anywhere, the core team is responsible to ensure structures are productive and make sense.</li> <li>Appoints initial team leadership. Once a new team is established, core appoints a leader that has the responsibility to grow the team.</li> <li>Responsible for security. Handles disclosures, vulnerabilities, audits, processes.</li> <li>Handles multi-sig keys and takes high level spending decisions. Spending proposals can be made by anyone, and teams can have their own own budgets to deal with as they please.</li> </ul>"},{"location":"grin-rfcs/text/0002-grin-governance/#organization-processes","title":"Organization &amp; Processes","text":"<ul> <li>There's no defined maximum size of the team.</li> <li>New members are added through a core decision; A core member can nominate a new member for inclusion, there\u2019s discussion, and the process is consensus seeking.</li> <li>The general decision making process is consensus seeking - no majority rule based voting, but also not blocked by lack of explicit consensus.</li> <li>Core members have no explicit veto, but strong objections are considered.</li> <li>Nominations and discussions are kept private.</li> <li>The term of core members is currently undefined but may change in the future.</li> <li>A core member can resign by notifying the rest of the team.</li> <li>If unreachable for 30 days without any news, a core member can be removed through a core decision.</li> <li>The core team does not make rulings on RFCs of other teams, although individual team members might also participate in the discussions of sub teams or be members of those teams.</li> <li>Meeting notes should be published and made transparent to the community on a regular basis.</li> </ul>"},{"location":"grin-rfcs/text/0002-grin-governance/#rfc-process","title":"RFC process","text":"<p>An RFC is a Request For Comments document, outlining a proposed improvement or design change to an area of Grin. The exact specifics for the template is TBD. They are kept in their own dedicated repo and need to be accepted before a pull request is merged. Their purpose is to outline a standardized way of making proposals and allow the community to discuss and evaluate whether something is worth doing. Having an RFC accepted means that there's support \"in theory\" for the suggestion. It does not mean that a change becomes implemented automatically or in the exact way it is proposed, it is high-level design. The work still needs to be carried out. Accepted RFCs guide the broader planning work.</p>"},{"location":"grin-rfcs/text/0002-grin-governance/#teams","title":"Teams","text":""},{"location":"grin-rfcs/text/0002-grin-governance/#overview","title":"Overview","text":"<p>Teams are groups organized around specific areas or knowledge fields. They are responsible for these areas, but do not do all the work. Anyone can contribute anywhere, and do not need to hold a particular title to do so.</p> <p>Rather, teams work on policies, processes, and workflows for their specific areas, as required. They are in charge of the RFC process in their specific field: They determine what requires an RFC in their area, they assign RFC shepherds that guide an RFC through its various stages and ensures the right stakeholders become aware of it and solicit their feedback. Ultimately, teams decide whether an RFC in their area should be accepted or rejected. They are responsible to ensure that each RFC in their area has a tracked status, and that they progress towards an outcome.</p> <p>Teams self-organize, but should be inclusive and adhere to community values. They should have a leader, often this leader may be part of the core team. They determine how members get added to the team. They should include area experts, and stakeholders. The decision making process should be consensus-seeking where possible.</p> <p>Teams can be broken down into smaller working groups or teams, permanent or temporary, as required and is seen necessary for them to be productive.</p> <p>Each team has a dedicated section on the forum, they should meet regularly, and keep some notes on what was covered and decided. Decisions do not need to happen in meetings, and could for example be handled asynchronously or in the RFC process.</p> <p>Meeting notes should be published and made transparent to the community on a regular basis.</p>"},{"location":"grin-rfcs/text/0002-grin-governance/#the-teams","title":"The teams","text":"<p>In addition to Core team, the following teams are proposed to be created initially.</p> <ul> <li> <p>Node development. Core Grin technology, changes and optimizations to the  node and anything consensus related, research and discussion of new technologies, proof of work.</p> </li> <li> <p>Wallet development. wallet technology, wallet API, wallet-related research.</p> </li> <li> <p>Infrastructure. Technical documentation, non-technical documentation, QA, testing, toolchain, developer productivity, guides, how-tos.</p> </li> <li> <p>Ecosystem. 3rd party developers interaction (wallets, pools, exchanges and others), integration and technical assistance, growing the grin ecosystem, stakeholder collaboration.</p> </li> <li> <p>Community. Onboarding of new community members, website, chat channels, conferences, events, meetups.</p> </li> <li> <p>Fundraising. Sponsorships, donations, activities to increase project funds.</p> </li> <li> <p>Moderation. Code of conduct, handles violations, across all areas of the project.  To avoid biases and conflicts of interest, this team does not contain any member of the core team.</p> </li> </ul>"},{"location":"grin-rfcs/text/0002-grin-governance/#in-case-of-conflicts-disagreement-or-dissent","title":"In case of conflicts, disagreement, or dissent","text":"<p>Teams are created and appointed by the core, and core can decide to re-organize team structures and shut down dysfunctional teams. This is a \"nuclear\" option, such decisions should not be taken lightly. The repercussions of such actions can be worse than the initial situation.</p> <p>In practice, core team members might be engaging with teams as individual contributors. It is however not expected that \"the core team\" will become involved in the responsibilities of individual teams. Core sets the overall direction for the project, but should not micro manage teams as this defeats the entire purpose of having these teams in the first place.</p> <p>If there are conflicts within teams, these should ideally be resolved within the teams themselves. If this is not possible and there's contentious disagreements that need outside arbitration, teams can invite core or another team to become involved.</p>"},{"location":"grin-rfcs/text/0002-grin-governance/#drawbacks","title":"Drawbacks","text":"<ul> <li>Adds a lot more structure. This might create overhead.</li> <li>Could lead to infighting and conflict between teams.</li> <li>Could lead to situations where one team does work that conflicts with other teams, \"left hand not talking to the right\".</li> </ul>"},{"location":"grin-rfcs/text/0002-grin-governance/#rationale-and-alternatives","title":"Rationale and alternatives","text":"<ul> <li>Keep the process as is.</li> <li>Change the process to something else.</li> </ul>"},{"location":"grin-rfcs/text/0002-grin-governance/#prior-art","title":"Prior art","text":"<p>Python conducted a comprehensive survey of the governance structures of various open source projects in 2018 through PEP-8002. This document is highly recommended reading for various alternative structures.</p>"},{"location":"grin-rfcs/text/0002-grin-governance/#unresolved-questions","title":"Unresolved questions","text":"<p>Far too many to all be listed here, but here are some:</p> <ul> <li>Is this too much structure for the amount of active contributors we have?</li> <li>Does this approach really address the problems as highlighted in the motivation?</li> <li>Does this legitimize the core team enough in the community?</li> </ul>"},{"location":"grin-rfcs/text/0002-grin-governance/#future-possibilities","title":"Future possibilities","text":"<ul> <li>Introduce more teams</li> <li>Introduce an electorate</li> <li>Introduce terms</li> <li>Define firmer structures and organizational rules</li> </ul>"},{"location":"grin-rfcs/text/0002-grin-governance/#references","title":"References","text":"<p>Rust's governance process</p> <ul> <li>https://rust-lang.github.io/rfcs/1068-rust-governance.html</li> <li>https://web.archive.org/web/2019*/https://predictablynoisy.com/rust-governance</li> <li>http://mgattozzi.com/oss-governance-and-sustainablility-i/</li> </ul> <p>Node.js governance</p> <ul> <li>https://medium.com/the-node-js-collection/healthy-open-source-967fa8be7951</li> </ul> <p>Swarmwise, by Rick Falkvinge</p> <ul> <li>https://falkvinge.net/files/2013/04/Swarmwise-2013-by-Rick-Falkvinge-v1.1-2013Sep01.pdf</li> </ul>"},{"location":"grin-rfcs/text/0003-security-process/","title":"0003 security-process","text":"<ul> <li>Title: security-process</li> <li>Authors: joltz</li> <li>Start date : July 18, 2019</li> <li>RFC PR: mimblewimble/grin-rfcs#13</li> <li>Tracking issue: mimblewimble/grin-pm#178</li> </ul>"},{"location":"grin-rfcs/text/0003-security-process/#summary","title":"Summary","text":"<p>This RFC improves the security processes for Grin by adopting a community standard for a public pre-commitment scheme for vulnerability sharing agreements. The standard proposed for adoption describes the norms for ethical disclosure behavior and provides a public pre-commitment scheme for the Grin community to clarify security process actions and expectations [2].</p>"},{"location":"grin-rfcs/text/0003-security-process/#motivation","title":"Motivation","text":"<ul> <li>Improves transparency around Grin security and disclosure processes</li> <li>Decreases reaction time for mitigating security incidents across the Grin ecosystem</li> <li>Increases preparedness in the event of an extreme vulnerability</li> <li>Improves overall ecosystem resiliency</li> <li>Provides clarity around ethical behavior and expected deviations</li> <li>Makes possible the mapping of the vulnerability disclosure surface</li> </ul>"},{"location":"grin-rfcs/text/0003-security-process/#community-level-explanation","title":"Community-level explanation","text":"<p>This RFC proposes adopting a vulnerability disclosure standard for Grin that provides more guidance and clears up some unanswered questions from Grin's current security process. The community should think of this improvement as an extension to the existing security process with the following changes:</p> <ul> <li>Better define ethical behavior (and deviations) for vulnerability disclosure</li> <li>Better define the processes and expectations for receiving and sending disclosures</li> <li>Provide a framework for bi-lateral disclosure agreements with other projects/implementations</li> <li>A public commitment to the above</li> </ul> <p>This all results in a more robust security process for Grin that is transparent from the beginning to the community, vulnerability researchers, the core team and other neighboring projects that share threads in the same security blanket.</p> <p>An example of another project adopting the same standard can be found here in Zcash's vulnerability disclosure document.</p>"},{"location":"grin-rfcs/text/0003-security-process/#reference-level-explanation","title":"Reference-level explanation","text":"<ul> <li> <p>This RFC proposes to adopt a community responsible disclosure standard for Grin: https://github.com/RD-Crypto-Spec/Responsible-Disclosure</p> </li> <li> <p>Here we will describe the specific changes that would be made to SECURITY.md if the RFC is adopted.</p> </li> <li> <p>Many of the changes proposed are modeled from Zcash's security disclosure policy which adopts the same standard proposed here for Grin.</p> </li> </ul> <p>All links to the standard in the actual implementation of SECURITY.md must be permanent.</p>"},{"location":"grin-rfcs/text/0003-security-process/#changes-to-securitymd","title":"Changes to SECURITY.md","text":"<ul> <li> <p>The original Recognition and Bug Bounties section will be updated:</p> <ul> <li>Include a link to the Acknowledgements section of the standard</li> <li>Include a link to the Bounty Payments section of the standard</li> <li> <p>Keep existing language such as:</p> <p>As of this writing, Grin is a traditional open source project with limited to no direct funding. As such, we have little means with which to compensate security researchers for their contributions.</p> </li> <li> <p>Remove unnecessary or old language such as:</p> <p>It is our hope that after mainnet release...</p> </li> <li> <p>Include a note that there is not currently a formal bug bounty program but that more donations can help provide the resources to run one in the future. Include a donation link here.</p> </li> </ul> </li> <li> <p>The original Code Reviews and Audits section will be moved to a not yet determined page on the wiki.</p> </li> <li> <p>The original Chain Splits section will move to a not yet determined Github issue in the main repository.</p> </li> </ul> <p>The following sections will be added to SECURITY.md and may replace existing sections as noted below.</p>"},{"location":"grin-rfcs/text/0003-security-process/#responsible-disclosure-standard","title":"Responsible Disclosure Standard","text":"<p>This section will replace the original vulnerability handling section</p> <p>Grin follows a community standard for responsible disclosure in cryptocurrency and related software.</p> <p>This document is a public commitment to following the standard. Any expected deviations are explained in the following sections.</p> <p>The standard provides detailed information for: - Initial Contact: how the initial contact process works - Giving Details: what details to include with your disclosure after receiving a response to your initial contact - Setting Dates: details for when to release updates and publicize details of the issue</p>"},{"location":"grin-rfcs/text/0003-security-process/#receiving-disclosures","title":"Receiving Disclosures","text":"<p>This section will replace the will replace the original responsible disclosure section.</p> <p>Grin is committed to working with researchers who submit security vulnerability notifications to us to resolve those issues on an appropriate timeline and perform a coordinated release, giving credit to the reporter if they would like.</p> <p>Please submit issues to all of the following main points of contact for security related issues according to the initial contact and details guidelines. More information is available about the expected timelines for the full disclosure cycle.</p> <p>Emails and PGP keys for Grin's security contacts will be listed here as in the existing Responsible Disclosure and Public Key sections.</p>"},{"location":"grin-rfcs/text/0003-security-process/#sending-disclosures","title":"Sending Disclosures","text":"<p>In the case where we become aware of security issues affecting other projects that has never affected Grin, our intention is to inform those projects of security issues on a best effort basis.</p> <p>In the case where we fix a security issue in Grin that also affects the following neighboring projects, our intention is to engage in responsible disclosures with them as described in https://github.com/RD-Crypto-Spec/Responsible-Disclosure, subject to the deviations described in the 'Deviations from the Standard' section.</p>"},{"location":"grin-rfcs/text/0003-security-process/#bilateral-responsible-disclosure-agreements","title":"Bilateral Responsible Disclosure Agreements","text":"<p>Here we would list any agreements we have with neighboring projects to share vulnerability information in accordance with the standard itself and the 'Deviations from the Standard' section in the adoption of the standard. Agreements would be made by the core team or security team based on capacity to engage and relevance/impact on Grin's ecosystem and to an extent the greater cryptocurrency ecosystem.</p>"},{"location":"grin-rfcs/text/0003-security-process/#deviations-from-the-standard","title":"Deviations from the Standard","text":"<p>Grin is a technology that provides strong privacy with zero-knowledge commitments and rangeproofs. Due to the nature of the cryptography used, if a counterfeiting bug results it could be exploited without a way to identify which data was corrupted. This renders rollbacks or other fork-based attempted fixes ineffective.</p> <p>The standard describes reporters of vulnerabilities including full details of an issue, in order to reproduce it. This is necessary for instance in the case of an external researcher both demonstrating and proving that there really is a security issue, and that security issue really has the impact that they say it has - allowing the development team to accurately prioritize and resolve the issue.</p> <p>In the case of a counterfeiting or privacy-breaking bug, however, we might decide not to include those details with our reports to partners ahead of coordinated release, so long as we are sure that they are vulnerable.</p>"},{"location":"grin-rfcs/text/0003-security-process/#canaries","title":"Canaries","text":"<p>For a privacy preserving project such as Grin, adversaries wishing to break that privacy may have incentive to disrupt Grin's security processes. This could be attempted via NSLs, FISA court orders, secret government subpoenas and rubber-hose tactics. The purpose of a PGP signed canary by each disclosure contact on a regular basis is to indicate that the disclosure contacts are not compelled in any way to take any actions (or non-actions) to jeopardize the security of Grin users. There are several examples of canaries in action, particularly in privacy preserving projects [5][6][7].</p> <p>If this section is adopted with the RFC, canaries for each security contact for Grin vulnerability disclosures will be updated quarterly. Repos containing up to date signatures will be linked in the SECURITY.md document. In the event a security contact fails to keep their canary alive, they will be removed from the list of contacts. The specific language of each canary can be up to each contact unless a canary standard is adopted.</p>"},{"location":"grin-rfcs/text/0003-security-process/#drawbacks","title":"Drawbacks","text":"<p>This proposal could add complexity and overhead that a donation-supported decentralized project may not be able to uphold in good faith. Adopting and pre-committing to a standard and policy is not effective if it cannot be upheld through actions. This is amplified with bilateral agreements that extend through chains of vendors sharing code, many forks and multiple implementations with many operating publicly.</p> <p>For a project with extremely limited resources (relative to large companies) and no source of steady funding, it may not be possible to support the time and resources required to follow through on such a commitment.</p>"},{"location":"grin-rfcs/text/0003-security-process/#rationale-and-alternatives","title":"Rationale and alternatives","text":""},{"location":"grin-rfcs/text/0003-security-process/#why-is-this-design-the-best-in-the-space-of-possible-designs","title":"Why is this design the best in the space of possible designs?","text":"<p>This seems to be the most transparent and least centralized option that still provides the ability to efficiently handle cases of severe vulnerabilities that may be unique to Grin, while keeping with the minimalist philosophy.</p> <p>Relying on a single security@ disclosure email address provides a single point of failure. Additionally, not having clear pre-commitments to sharing agreements and expected ethical deviations can cause community contention at best and failure to successfully mitigate a vulnerability before it is exploited at worst.</p>"},{"location":"grin-rfcs/text/0003-security-process/#what-other-designs-have-been-considered-and-what-is-the-rationale-for-not-choosing-them","title":"What other designs have been considered and what is the rationale for not choosing them?","text":"<p>A less centralized model would be to attempt to guide this process with on-chain governance or an on-chain bug bounty program. Both of those not only challenge Grin's minimalist philosophy but are also extremely complicated to execute on. These do not seem to be viable options for Grin at this time.</p> <p>Ideally formal verification could be used to handle many of these security challenges but there is a huge gap between what formal verification can actually do and the complex blockchain related things we are doing today that we want formally verified. This may be more viable in the future, but it would require significant time and resource investment. It would not be responsible to rely on formal verification for a project like Grin today.</p>"},{"location":"grin-rfcs/text/0003-security-process/#what-is-the-impact-of-not-doing-this","title":"What is the impact of not doing this?","text":"<p>If we do not adopt a standard as proposed here, the community is left with unresolved problems:</p> <ul> <li>Who do we tell if we receive a vulnerability?</li> <li>What details are we obligated to share?<ul> <li>Exploit code?</li> <li>What if it is an inflation bug?</li> </ul> </li> <li>Do we attempt to collect a bug bounty?</li> </ul> <p>The community is exposed to risk by not having clear answers to these questions before it is presented with a critical security vulnerability. Even if the vulnerability has technically been fixed, there may be severe fallout in the community if it perceives the situation wasn't handled ethically by the parties involved in the disclosure. There is also risk of not implementing a fix in time across the community because there were internal disputes about who to tell.</p> <p>Without a public pre-commitment to expected actions taken during a vulnerability disclosure, Grin runs the risk of alienating the community in pursuit of security, or even worse, not implementing a critical fix before any user experiences privacy or value loss.</p>"},{"location":"grin-rfcs/text/0003-security-process/#prior-art","title":"Prior art","text":"<p>The traditional disclosure model (RF Policy/security@) [0] handles interaction between researcher and vendor but does not quite fit for our use case of potentially multiple vendors up/down stream. There have been multi-party models proposed with single researcher and multiple vendors that have not been successful, nor do they sufficiently account for the challenges faced in public decentralized projects.</p> <p>Neither model fits with chains of vendors sharing code, protocols with multiple implementations and forks, all operating in public. We need a model that is better suited to handle cases of consensus critical vulnerabilities that require upgrades across many implementations, forks and projects both in the Grin and greater cryptocurrency ecosystems.</p> <p>Bitcoin has received some criticism over handling of disclosures, as it never had a robust, well-defined pre-committed standard to follow. We want to learn from those lessons to avoid putting more people in the position to repeat the same mistakes.</p> <p>Zcash, a privacy based cryptocurrency, experienced a critical vulnerability that inspired the creation of the standard this RFC proposes to adopt [1]. Due to the similar nature of the Zcash and Grin ecosystems, this prior art is highly relevant to the security process for Grin.</p>"},{"location":"grin-rfcs/text/0003-security-process/#unresolved-questions","title":"Unresolved questions","text":"<ul> <li> <p>How can we further reduce centralization risk for Grin's security process?</p> <ul> <li>Disclosures are sent directly only to those listed in SECURITY.md. This poses a centralization risk for the community as there is no way to trustlessly publicly verify actions taken by individuals involved in a disclosure. While this RFC is a step in the right direction, it does not completely remove centralization risk for the disclosure process.</li> </ul> </li> <li> <p>How can we responsibly handle vulnerabilities in academic papers?</p> <ul> <li>It is possible that a vulnerability may be found in an underlying primitive at the specification level that Grin relies on. In this case not only do we have potential vulnerabilities in all implementations, but also in the specification itself. Without addressing these properly some may continue to use academic papers with vulnerable specifications as a reference for new development.</li> </ul> </li> <li> <p>What role will formal verification play in Grin's future?</p> </li> <li> <p>What form, if any, will the Bug Bounty process take?</p> </li> </ul>"},{"location":"grin-rfcs/text/0003-security-process/#future-possibilities","title":"Future possibilities","text":"<ul> <li>Security team<ul> <li>If a security team is adopted in the future it would likely maintain these processes</li> </ul> </li> <li>On-chain governance/bug bounties</li> <li>Bug bounty program</li> <li>Formal verification</li> </ul>"},{"location":"grin-rfcs/text/0003-security-process/#references","title":"References","text":"<ul> <li>[0] https://dl.packetstormsecurity.net/papers/general/rfpolicy-2.0.txt</li> <li>[1] https://www.youtube.com/watch?v=h7W1u1K2VjQ</li> <li>[2] https://github.com/RD-Crypto-Spec/Responsible-Disclosure</li> <li>[3] https://github.com/zcash/zcash/blob/master/SECURITY.md</li> <li>[4] https://github.com/mimblewimble/grin/blob/09cf6de1d143ffbe007478372dc573213e06804d/SECURITY.md</li> <li>[5] https://github.com/QubesOS/qubes-secpack/blob/master/canaries/canary-020-2019.txt</li> <li>[6] https://riseup.net/about-us/canary/canary-statement-signed.txt</li> <li>[7] https://protonmail.com/blog/transparency-report/</li> </ul>"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/","title":"0004 full-wallet-lifecycle","text":"<ul> <li>Title: full-wallet-lifecycle</li> <li>Authors: Michael Cordner</li> <li>Start date : June 26th, 2019</li> <li>RFC PR: mimblewimble/grin-rfcs#18</li> <li>Tracking issue: mimblewimble/grin-wallet#212</li> </ul>"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#summary","title":"Summary","text":"<p>Increase the scope of the Grin Wallet's Owner API to support full wallet lifecycle functions.</p>"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#motivation","title":"Motivation","text":"<p>Grin Wallet's APIs currently provides functions for transacting and querying the contents of the wallet. However, several pieces of functionality around wallet creation and seed/password management are not included within the API. This means that any consumers of the API will either expect their users to initialize the wallet manually before the APIs can be used, or provide custom management for wallet lifecycle functions.</p> <p>The Wallet APIs are intended to be the foundation upon which community-created wallets should be built, and the job of a wallet creator is made far more difficult by the absence of wallet creation and seed management functions within the API. Ideally, it should be the case that a wallet can be instantiated and managed solely via the Owner API.</p>"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#community-level-explanation","title":"Community-level explanation","text":"<p>From an end-user perspective, (i.e. end-users of community wallets that use the wallet API,) this change should be transparent.</p>"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#reference-level-explanation","title":"Reference-level explanation","text":""},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#wallet-initialization","title":"Wallet Initialization","text":"<p>Currently, wallet data does not exist until the user runs <code>grin-wallet init</code>. The <code>init</code> command creates <code>grin-wallet.toml</code>, in the <code>~/.grin/main</code> directory (or <code>~/.grin/floonet</code>, or the current directory via the <code>-h</code> flag), prompts the user for a password, creates a seed file, stores the resulting data files in the directory specified in <code>grin-wallet.toml</code> (<code>~/.grin/main/wallet_data</code> by default) and initialises the lmdb database.</p> <p>It should be possible to run <code>grin-wallet owner_api</code> or invoke the API directly from a linked binary without having instantiated a wallet.</p>"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#security-model","title":"Security Model","text":"<p>Given that the Wallet's Owner API needs to deal with sensitive data such as passwords and seed phrases, the API will be enhanced with a new ECDH and Token-based security model, the primary goals of which are to:</p> <ul> <li>Ensure sensitive data such as passwords or seed phrases are always end-to-end encrypted between the client and the Owner API server, regardless of what higher-level protocols are used during the exchange.</li> <li>Minimize the potential for damage that can be done by a third party listening on the exchange between a wallet client and its corresponding server.</li> <li>Ensure that sensitive data such as passwords or seed phrases are not resident in server-side memory any longer than they absolutely need to be.</li> </ul> <p>Note that this mode of operation is primarily intended for use over the JSON-RPC API, which supports many different architectural possiblities. Clients that link libraries directly and keep all sensitive data in the same process would see less benefit from this scheme, and an alternative model which doesn't encrypt any sensitive data is provided. Further, authors of existing wallets will need time to consider and/or implement the added complexity needed on the client-side to support ECDH and encryption. It's therefore proposed that the Owner API initially provide the new \"SecureAPI\" mode as an optional feature, with wallet authors strongly encouraged to make use of it. Support for the \"InsecureAPI\" model can be maintained indefinitely for directly-linked wallets, and for the JSON-RPC API until a cut-off release at some point in the future.</p> <p>Note that the \"SecureAPI\" mode and all lifecycle functions will be implemented in a V3 API, with the V2 API maintained for a time for backwards compatibility. The V3 API requires all JSON-RPC communication to be encrypted, with the exception of the <code>init_secure_api</code> function.</p>"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#secureapi-mode","title":"SecureAPI Mode","text":"<p>SecureAPI Mode consists of an ECDH key agreement followed by the establishment of an API Token that's used to XOR encrypt the wallet seed on the server side. The negotiated ECDH shared key is used to encrypt all requests and responses between the client and the JSON-RPC layer, while the token must be included in all API requests to allow the wallet backend to decrypt the seed. 'Open' wallets store their in-memory seeds XORed against the token, which is temporarily XORed against the supplied token during each request to reproduce the master seed.</p> <p>ECDH will use secp256k1 for key agreement.</p> <p>Encryption of JSON-RPC requests and responses will be performed using AEAD in GCM mode with 128-bit tags, 96 bit nonces, a 16 byte suffix length and an empty vector for the additional data. A 12 byte nonce will be applied in the encryption and included in each request/response to use on the decrypting side.</p> <p>Encrypted requests and responses will be exchanged in valid JSON-RPC calls with the method \"encrypted_request_v3\" (with 'v3' here denoting the version of the API). They will have the following form:</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"method: \"encrypted_request_v3\",\n    \"id\": \"1\",\n    \"params\": {\n       \"nonce\": \"ef32...\",\n       \"body_enc\": \"e0bcd...\"\n    }\n}\n</code></pre>"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#security-mode-initialization","title":"Security Mode Initialization","text":"<p>To initialize the Secure API, clients will generate an EC keypair using the secp256k1 curve, and provide the public key to the Owner API server via a new <code>init_secure_api</code> method. Both client and server will calculate the shared key, and store this key for the remainder of the session. The sequence of operations is outlined below:</p> <p></p> <p>The Secure API assumes that all requests (other than the actual call to <code>init_secure_api</code> itself) will be encrypted with the shared secret and presented in the above JSON-RPC format. All API calls other than <code>open_wallet</code> will be accompanied with a valid encrypted token derived during the call to the <code>open_wallet</code> function. This assumption will remain until the server process exits or a call to a corresponding <code>close_api_secure</code> function is called.</p> <p>The shared secret can be refreshed by the client at any time with another call to <code>init_secure_api</code> (either encrypted or unencrypted). Closing a wallet via the <code>close_wallet</code> function does not regenerate the shared secret but does invalidate the token and drops the XORed seed from memory.</p>"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#legacy-support","title":"Legacy support","text":"<p>The V2 API will remain active for a time the mode of operation for its JSON-RPC API will be assumed to work as currently, i.e. requests and responses are unencrypted, the wallet stores its full seed in-memory between requests and the providing of a token with each request is not requred. However, the new lifecycle functions described in this RFC, which deal with highly sensitive data such as passwords and master keys, will not be available in the V2 API. This setup should allow existing wallets to continue working as-is until a cutoff release for legacy mode is determined.</p>"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#opening-a-wallet-in-secureapi-mode","title":"Opening a Wallet in SecureAPI Mode","text":"<p>Opening a wallet in SecureAPI mode consists of encrypting a request to <code>open_wallet</code> (which contains the wallet password) with the shared secret <code>s</code>. The request is decrypted in the JSON-RPC layer and the password is used in the wallet backend to unlock the wallet master seed. The master seed is stored XORed against a randomly-generated token T, which is returned to the client in an encrypted response for inclusion in all further API calls. T is valid for the lifetime of the process, or until a corresponding call to <code>close_wallet</code>.</p> <p></p>"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#calling-api-functions-in-secureapi-mode","title":"Calling API functions in SecureAPI Mode","text":"<p>Calls to each API function proceed as per a call to <code>open_wallet</code>, however each encrypted request must contain the token provided by the <code>open_wallet</code> call. The token is XORed against the stored XORed seed to recover the original seed by the backend for the duration of each call, and the seed value is dropped and zeroed from memory when each call returns.</p> <p></p>"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#directly-linked-wallets","title":"Directly Linked Wallets","text":"<p>Wallets that link the wallet API directly will not be required to encrypt parameters, as there would be little benefit to doing so within a single process. However, for consistency, they will be expected to store and supply a token to each API call. The modified workflow for a linked wallet is outlined below:</p> <p> </p> <p>'Legacy' support will not be provided for directly-linked wallets on release of the features described in this RFC. It is expected that wallet authors will need to update their code to store and supply the token with each request.</p>"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#new-lifecycle-api-functions","title":"New Lifecycle API Functions","text":"<p>The functions as shown here are for illustrative purposes, and their signatures will change during implementation.</p> <ul> <li><code>OwnerAPI::init_secure_api(pubkey: Secp256k1Point) -&gt; Result&lt;pubkey: Secp256K1Point, Error&gt;</code><ul> <li>Initializes secure API mode, returning the server-side public key to be used for key agreement</li> <li>All further calls to the JSON-RPC API must be encrypted with the shared secret</li> </ul> </li> <li><code>OwnerAPI::set_wallet_directory(dir: String) -&gt; Result&lt;(), libwallet::Error&gt;</code><ul> <li>On API startup, it's assumed the top-level wallet data directory is <code>~/.grin/main/wallet_data</code> (or floonet equivalent)</li> <li>Set the top-level system wallet directory from which named wallets are read. Further calls to lifecycle functions will use this wallet directory</li> </ul> </li> <li><code>OwnerAPI::create_config(chain_type: &amp;global::ChainTypes, config_overrides: Option&lt;GlobalWalletConfig&gt;) -&gt; Result&lt;(), libwallet::Error&gt;</code><ul> <li>Outputs a <code>grin-wallet.toml</code> file into current top-level system wallet directory</li> <li>Optionally takes wallet configuration structure to override defaults in the grin-wallet.toml file</li> </ul> </li> <li><code>OwnerAPI::create_wallet(name: Option&lt;String&gt;, mnemonic: Option&lt;ZeroingString&gt;, mnemonic_length: usize, password: ZeroingString) -&gt; Result&lt;(), libwallet::Error&gt;</code><ul> <li>Creates and initializes a new wallet</li> <li>Initializes seed from given mnemonic if given, random seed otherwise</li> <li>Should error appropriately if the wallet already exists</li> <li>The 'name' parameter is included for future use as in <code>open_wallet</code> above.</li> </ul> </li> <li><code>OwnerAPI::open_wallet(name: Option&lt;String&gt;, password: String) -&gt; Result&lt;t:Token, libwallet::Error&gt;</code><ul> <li>Opens a wallet and sets it as the 'active' wallet. All further API commands will be performed against this wallet.</li> <li>'Opens' the wallet seed in memory, stored XORed against a new token. The token is to be returned to the client for use in all further API calls.</li> <li>The 'name' argument is included for future use, anticipating the inclusion of multiple wallets and seeds within a single top-level wallet directory.</li> </ul> </li> <li><code>OwnerAPI::close_wallet(&amp;mut self) -&gt; Result&lt;(), libwallet::Error&gt;</code><ul> <li>Closes the currently open wallet (i.e. drops the XORed seed from memory)</li> </ul> </li> <li><code>OwnerAPI::get_mnemonic(t:Token) -&gt; Result&lt;ZeroingString, libwallet::Error&gt;</code><ul> <li>Returns the mnemonic from the active, (open) wallet</li> </ul> </li> <li><code>OwnerAPI::change_password(old: ZeroingString, new: ZeroingString) -&gt; Result&lt;(), libwallet::Error&gt;</code><ul> <li>Changes the password for the open wallet. This will essentially:<ul> <li>Close the wallet instance</li> <li>Confirm the existing seed can be opened with the given password</li> <li>Regenerate the <code>wallet.seed</code> file with the new password</li> <li>Re-open the wallet instance</li> <li>(Should this just operate on closed wallets instead?)</li> </ul> </li> </ul> </li> <li><code>OwnerAPI::delete_wallet(name: Option&lt;String&gt;, password: ZeroingString) -&gt; Result&lt;(), libwallet::Error&gt;</code><ul> <li>Dangerous function that removes all wallet data</li> <li>name argument reserved for future use</li> </ul> </li> </ul>"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#api-only","title":"API only","text":"<p>Note that this RFC does not propose making user-facing changes to the existing CLI wallet to invoke these functions. It's expected that the existing cli functionality will be modified to invoke the new API functions.</p>"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#implementation-notes","title":"Implementation notes","text":"<p>Although this document doesn't attempt to outline implementation, a few notes to consider for the implementor:</p> <ul> <li>Currently, the code that deals with wallet initialization and seed management sits outside the wallet APIs, in the <code>impls</code> crate, (denoting they're implementation specific). The implementation should attempt to refactor traits from these hard implementations into a new interface, similar to the existing WalletBackend and NodeClient interfaces (WalletLifecycleManager, for instance). The implementation within <code>impls</code> will then become an implementation of that trait and can be substituted by wallet authors with their own implementations.</li> <li>The implementation period of this RFC may be a good time to remove the BIP32 specific code out from Grin core into the wallet or into a separate rust crate (probably more desirable).</li> <li>New API functions should be implemented as additions, with the new features optional to ensure complete backwards compatibility</li> </ul>"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#drawbacks","title":"Drawbacks","text":"<ul> <li>Security-critical information such as passwords and mnemonics are covered via the encryption in the above scheme, but sending slate information via the OwnerAPI has privacy concerns.</li> </ul>"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#unresolved-questions","title":"Unresolved questions","text":"<ul> <li>Due to how this is likely to be implemented, the Foreign API will also have to provide a token for all wallet access. The Foreign API will need to store this token in-process, therefore negating much of the benefit of the scheme. Is there a cleverer way to deal with this?</li> </ul>"},{"location":"grin-rfcs/text/0004-full-wallet-lifecycle/#future-possibilities","title":"Future possibilities","text":"<p>The changes in this RFC lead the way for:</p> <ul> <li>Support for multiple wallets in a single top-level data directory</li> <li>An alternate method of command-line invocation whereby the wallet presents its own prompt instead of using single-use commands.</li> </ul>"},{"location":"grin-rfcs/text/0005-variable-size-kernels/","title":"0005 variable-size-kernels","text":"<ul> <li>Title: variable-size-kernels</li> <li>Authors: Antioch Peverell</li> <li>Start date: Aug 13, 2019</li> <li>RFC PR: mimblewimble/grin-rfcs#21</li> <li>Tracking issue: mimblewimble/grin#3038</li> </ul>"},{"location":"grin-rfcs/text/0005-variable-size-kernels/#summary","title":"Summary","text":"<p>We minimize the size of binary serialized transaction kernels by including only the data applicable for each kernel variant. Height locked kernels include a fee and a lock height. Plain kernels include only a fee. Coinbase kernels include neither a fee nor a lock height. Each kernel feature variant will serialize to a fixed size in bytes but this size will differ across the kernel variants.</p>"},{"location":"grin-rfcs/text/0005-variable-size-kernels/#motivation","title":"Motivation","text":"<p>We were originally including both fee and lock_height on every kernel in the binary serialization format. We were storing a fee of 0 on coinbase kernels and a lock_height of 0 on both plain and coinbase kernels. Kernels are never pruned and must be maintained forever so this overhead is relatively expensive. By only serializing data strictly necessary for each kernel variant we minimize storage and transmission costs. This also provides the flexibility necessary to introduce new kernel variants in the future, for example the proposed [relative kernels][0].</p>"},{"location":"grin-rfcs/text/0005-variable-size-kernels/#community-level-explanation","title":"Community-level explanation","text":"<p>Each transaction kernel variant may have associated data. For example, height locked kernels include an associated lock height and non-coinbase kernels have an associated fee. Each kernel variant serializes to a fixed size in bytes but this size may be different for each kernel variants. This allows kernels to be serialized efficiently and provides flexibility to introduce new kernel variants that have additional associated data in the future.</p> <p>A plain kernel is 106 bytes compared to 114 bytes for a height locked kernel. Omitting the lock height from plain kernels saves approximately 7% in kernel storage costs.</p> <p>These changes affect serialization/deserialization of transaction kernels. Kernels are included in p2p messages for transactions and full blocks. Older nodes will serialize transaction kernels differently so nodes on the network need to be able to handle old and new serialization formats. The kernel MMR is also included in the txhashset state file during fast sync so nodes need to be able to support old and new formats of the state file.</p>"},{"location":"grin-rfcs/text/0005-variable-size-kernels/#reference-level-explanation","title":"Reference-level explanation","text":""},{"location":"grin-rfcs/text/0005-variable-size-kernels/#protocol-version-1-previous-version","title":"Protocol Version 1 (Previous Version)","text":"<p>In protocol version 1 all transaction kernels are serialized using the same structure, regardless of kernel variant. All kernels include 8 bytes for the fee and 8 bytes for the lock_height, even if unused.</p> <pre><code>features (1 byte) | fee (8 bytes) | lock_height (8 bytes) | excess (33 bytes) | signature (64 bytes)\n\n00 | 00 00 00 00 01 f7 8a 40 | 00 00 00 00 00 00 00 00 | 08 b1 ... 22 d8 | 33 11 ... b9 69\n</code></pre> <p>All kernels contain a feature byte to determine the variant. Kernels always include an excess commitment and signature, 33 bytes and 64 bytes respectively. The proposal is to have variant specific data follow the feature byte.</p> <p>The initial feature byte would determine the number of subsequent bytes to read for variant specific data.</p> <pre><code>00 (plain): following 8 bytes for the fee.\n01 (coinbase): no additional bytes.\n02 (height locked): following 8 bytes for the fee and additional 8 bytes for the lock height.\n</code></pre> <p>This would always be followed by a fixed 33 bytes for the excess commitment and 64 bytes for the kernel signature.</p>"},{"location":"grin-rfcs/text/0005-variable-size-kernels/#protocol-version-2-current-version","title":"Protocol Version 2 (Current Version)","text":"<p>Plain kernel, includes fee.</p> <pre><code>features (1 byte) | fee (8 bytes) | excess (33 bytes) | signature (64 bytes)\n\n00 | 00 00 00 00 01 f7 8a 40 | 08 b1 ... 22 d8 | 33 11 ... b9 69\n</code></pre> <p>Coinbase kernel, no fee, no lock height.</p> <pre><code>features (1 byte) | excess (33 bytes) | signature (64 bytes)\n\n01 | 08 b2 ... 15 36 | 08 14 ... 98 96\n</code></pre> <p>Height locked kernel, include fee and lock height.</p> <pre><code>features (1 byte) | fee (8 bytes) | lock_height (8 bytes) | excess (33 bytes) | signature (64 bytes)\n\n02 | 00 00 00 00 00 6a cf c0 | 00 00 00 00 00 00 04 14 | 09 4d ... bb 9a | 09 c7 ... bd 54\n</code></pre>"},{"location":"grin-rfcs/text/0005-variable-size-kernels/#backward-compatibility-protocol-version-support","title":"Backward Compatibility (Protocol Version Support)","text":""},{"location":"grin-rfcs/text/0005-variable-size-kernels/#network-p2p-messages","title":"Network p2p messages","text":"<p>The following p2p messages include serialized transaction kernels -</p> <ul> <li>transaction</li> <li>full block</li> <li>compact block (incl. coinbase kernel)</li> </ul> <p>Each node has a \"local\" protocol version. Nodes exchange protocol versions during the initial handshake when setting up a connection.</p> <p>If both nodes are running protocol version 2 then no translation is required and transaction kernels can be serialized using protocol version 2.</p> <p>If both nodes are running protocol version 1 then again no translation is required.</p> <p>The complexity arises when one node is running protocol version 2 and the other node is running protocol version 1.</p> <ul> <li>Node A: protocol version 2</li> <li>Node B: protocol version 1</li> </ul> <p>If node A and node B are communicating they must both send and receive using a protocol version compatible with both nodes. In this case protocol version 1.</p> <p>Receiving messages using previous protocol version</p> <p>Node B will broadcast transactions and blocks using protocol version 1. Node A will need to use the previous protocol version and not the local version when deserializing these messages.</p> <p>Sending messages using previous protocol version</p> <p>Node A will need to ensure anything broadcast to Node B is compatible with protocol version 1. In both cases node A is responsible for translating to and from the previous protocol version.</p>"},{"location":"grin-rfcs/text/0005-variable-size-kernels/#local-db-storage","title":"Local db storage","text":"<p>Each node has a \"db\" protocol version. All entries in the db serialize/deserialize using that protocol version. Nodes support a process for local migration of data. On startup, the db is inspected and if necessary a migration is performed upgrading all entries in the db to the latest protocol version. This process can be disabled locally to allow nodes to run against old databases without upgrading the protocol version. This is useful in cases where nodes do not wish to immediately upgrade the db, allowing for previous versions of code to run without problems.</p>"},{"location":"grin-rfcs/text/0005-variable-size-kernels/#kernel-mmr-storage","title":"Kernel MMR storage","text":"<p>Each node maintains a kernel MMR as part of the txhashset data structure. Each node has an MMR protocol version. The node will serialize/deserialize kernel entries in the kernel MMR data file according to the MMR protocol version.</p>"},{"location":"grin-rfcs/text/0005-variable-size-kernels/#fast-sync-txhashsetzip-state-file","title":"Fast sync (txhashset.zip state file)","text":"<p>Internally nodes are free to use any protocol version but the kernel MMR is also provided to other nodes during initial fast sync. A node joining the network requests a txhashset state file and this includes the kernel MMR. It is important that nodes send and receive the txhashset file using a compatible protocol version. This is a special case of \"p2p messages\" above with the txhashset state file provided as an attachment to the txhashset message.</p> <p>If node A (protocol version 2) requests a txhashset from node B (protocol version 1) then it must read the file using protocol version 1. Similarly, if node B requests txhashset from node A then node A must provide the file such that it is compatible with protocol version 1.</p> <p>The simplest way to achieve this is for all nodes to continue to use protocol version 1 internally for MMR storage, even if they use protocol version 2 externally for p2p messages. A transition period will be in place until a majority of nodes support protocol version 2 at which time nodes can migrate their MMR storage to protocol version 2.</p>"},{"location":"grin-rfcs/text/0005-variable-size-kernels/#wallet-compatibility","title":"Wallet Compatibility","text":"<p>Interactive transaction building involves a transaction \"slate\" passed between parties. This includes a json serialized representation of the transaction.</p> <p>To minimize compatibility issues between wallets we have maintained this existing json format. Transaction kernels are represented in a single consistent json format, with fee and lock_height both included, regardless of kernel variant. Plain kernels have an associated lock_height of 0 and coinbase kernels include a 0 fee. This is consistent with the current \"v2\" slate.</p> <pre><code>\"kernels\": [\n  {\n    \"features\": \"Plain\",\n    \"fee\": \"7000000\",\n    \"lock_height\": \"0\",\n    \"excess\": \"08b1...22d8\",\n    \"excess_sig\": \"3311...b969\"\n  },\n  ...\n]\n</code></pre>"},{"location":"grin-rfcs/text/0005-variable-size-kernels/#future-possibilities","title":"Future possibilities","text":"<p>Support for variable size kernels allows new kernel variants to be introduced in the future. One proposed kernel variant is [No Recent Duplicate (NRD) kernels][0]. Kernels with relative lock heights will have an associated reference to a prior kernel in addition to a lock height based on that prior kernel.</p>"},{"location":"grin-rfcs/text/0005-variable-size-kernels/#references","title":"References","text":"<ul> <li>PR #2734 Support for variable size MMRs</li> <li>PR #2824 Protocol version support</li> <li>PR #2859 Kernel feature variants</li> </ul>"},{"location":"grin-rfcs/text/0006-payment-proofs/","title":"0006 payment-proofs","text":"<ul> <li>Title: payment-proofs</li> <li>Authors: David Burkett</li> <li>Start date: Nov 05, 2019</li> <li>RFC PR: mimblewimble/grin-rfcs#31</li> <li>Tracking issue: mimblewimble/grin-wallet#230</li> </ul>"},{"location":"grin-rfcs/text/0006-payment-proofs/#summary","title":"Summary","text":"<p>Support generating and validating payment proofs for sender-initiated (i.e. non-invoice) transactions.</p>"},{"location":"grin-rfcs/text/0006-payment-proofs/#motivation","title":"Motivation","text":"<p>Bitcoin and other cryptocurrencies with transparent protocol-level addressing and immutable, unprunable blockchains can prove sender, receiver, and amounts of payments simply by pointing to the transaction in the blockchain. Grin's privacy and scalability means users no longer have this ability. This prevents some merchants from accepting Grin due to the high possibility of payment disputes that are unresolvable in the same way they are for transparent coins.</p> <p>This RFC changes the transaction building process where payers can require payees to create a \"proof\" they've received a payment before the payer finalizes and broadcasts the transaction.</p>"},{"location":"grin-rfcs/text/0006-payment-proofs/#community-level-explanation","title":"Community-level explanation","text":"<p>From an end-user perspective, payers can require payees to prove receipt of funds as part of the transacting process. Payers can then use these \"proofs\" to resolve payment disputes and prove they sent funds to the correct payee.</p>"},{"location":"grin-rfcs/text/0006-payment-proofs/#reference-level-explanation","title":"Reference-level explanation","text":""},{"location":"grin-rfcs/text/0006-payment-proofs/#slate-changes","title":"Slate changes","text":"<p>A new (optional) structure (<code>payment_info</code>) will be added to transaction slates, along with a version increase. The <code>payment_info</code> structure will contain:</p> <ul> <li><code>sender_address</code> - An ed25519 public key generated by the sender.</li> <li><code>receiver_address</code> - An ed25519 public key for the receiver, typically the public key of the user's v3 onion address.</li> <li><code>receiver_signature</code> - A signature of the sender_address, received amount, and kernel commitment that validates against the <code>receiver_address</code>.</li> </ul>"},{"location":"grin-rfcs/text/0006-payment-proofs/#generating-proofs","title":"Generating proofs","text":"<p>Receipt confirmations (<code>receiver_signature</code>) will be generated by the payee by providing an ED25519 signature of: <code>(amount || kernel_commitment || sender_address)</code>, using the private key of the <code>receiver_address</code>.</p> <p>The <code>sender_signature</code> can be generated for <code>(amount || kernel_commitment || sender_address)</code> using the private key of the <code>sender_address</code>.</p> <p>Sender will then create and store the following info, which can be considered the complete <code>payment_proof</code>:</p> <ul> <li><code>receiver_address</code></li> <li><code>receiver_signature</code></li> <li><code>amount</code></li> <li><code>kernel_commitment</code></li> <li><code>sender_address</code></li> <li><code>sender_signature</code></li> </ul>"},{"location":"grin-rfcs/text/0006-payment-proofs/#verifying-proofs","title":"Verifying Proofs","text":"<p>This <code>payment_proof</code> can be provided by the sender at any time to convince a payee that a payment was made to them. The proof can be verified as follows:</p> <ol> <li>Ensure the <code>kernel_commitment</code> is confirmed on-chain.</li> <li>Verify that the <code>receiver_address</code> belongs to the payee.</li> <li>Verify that the <code>receiver_signature</code> is valid.</li> <li>Verify that the <code>sender_signature</code> is valid.</li> </ol>"},{"location":"grin-rfcs/text/0006-payment-proofs/#wallet-actions","title":"Wallet actions","text":""},{"location":"grin-rfcs/text/0006-payment-proofs/#init-send","title":"init-send","text":"<p>As part of the first step of the tx-building process, the sender/payer generates the <code>sender_address</code> using their keychain.</p> <p>The <code>receiver_address</code> and keychain path of the <code>sender_address</code> must be stored locally, along with the <code>slate_id</code>.</p> <p>The <code>sender_address</code> and <code>receiver_address</code> will then be added to the <code>payment_proof</code> structure of the slate.</p>"},{"location":"grin-rfcs/text/0006-payment-proofs/#receive","title":"receive","text":"<p>If the <code>payment_proof</code> structure exists on the slate, it is mandatory that the <code>receiver_signature</code> is generated and added to the slate as part of the receive tx-building step.</p>"},{"location":"grin-rfcs/text/0006-payment-proofs/#finalize","title":"finalize","text":"<p>Using the <code>slate_id</code>, the sender can retrieve the original <code>sender_address</code> and <code>receiver_address</code> that were included in the slate, and verify that those fields remain unchanged. The sender must then validate the <code>receiver_signature</code>. If any of the original <code>payment_proof</code> slate fields were modified, or if the <code>receiver_signature</code> is invalid, the transaction must be rejected by the sender.</p> <p>Once the <code>payment_info</code> details have been validated, the sender can generate and store the <code>payment_proof</code> (See <code>Generating Proofs</code> above), and then finalize the transaction as normal.</p>"},{"location":"grin-rfcs/text/0006-payment-proofs/#drawbacks","title":"Drawbacks","text":"<ul> <li>Increases the size of tx slates.</li> <li>Possibility of privacy leakage through address reuse.</li> </ul>"},{"location":"grin-rfcs/text/0006-payment-proofs/#rationale-and-alternatives","title":"Rationale and alternatives","text":"<ul> <li>This design works well with TOR tx building, yet is generic enough to work with all known transacting mechanisms.</li> </ul>"},{"location":"grin-rfcs/text/0006-payment-proofs/#prior-art","title":"Prior art","text":"<ul> <li>Wallet713 implements payment proofs for grinbox transactions, which our design adapts and builds on to work more seemlessly with onion addresses and with transaction building methods that don't inherently rely on addresses.</li> </ul>"},{"location":"grin-rfcs/text/0006-payment-proofs/#unresolved-questions","title":"Unresolved questions","text":"<ul> <li>Can this be adapted to work for invoices?</li> </ul>"},{"location":"grin-rfcs/text/0006-payment-proofs/#future-possibilities","title":"Future possibilities","text":"<ul> <li>Payment proofs could potentially be added to invoice payments in the future, but at the cost of an additional round of communication.</li> </ul>"},{"location":"grin-rfcs/text/0006-payment-proofs/#references","title":"References","text":"<ul> <li>Tx slate structure</li> <li>Beam's payment proof model</li> </ul>"},{"location":"grin-rfcs/text/0007-node-api-v2/","title":"0007 node-api-v2","text":"<ul> <li>Title: node-api-v2</li> <li>Authors: Quentin Le Sceller</li> <li>Start date: September 30th, 2019</li> <li>RFC PR: mimblewimble/grin-rfcs#28</li> <li>Tracking issue: mimblewimble/grin#3158</li> </ul>"},{"location":"grin-rfcs/text/0007-node-api-v2/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Summary</li> <li>Motivation</li> <li>Community-level explanation</li> <li>Reference-level explanation</li> <li>Current Endpoints with the v1 API</li> <li>Proposed Endpoints<ul> <li>Owner API Endpoints</li> <li>get_status</li> <li>validate_chain</li> <li>compact_chain</li> <li>get_peers</li> <li>get_connected_peers</li> <li>ban_peer</li> <li>unban_peer</li> <li>Foreign API Endpoints</li> <li>get_version</li> <li>get_header</li> <li>get_block</li> <li>get_tip</li> <li>get_kernel</li> <li>get_outputs</li> <li>get_unspent_outputs</li> <li>get_pmmr_indices</li> <li>get_pool_size</li> <li>get_stempool_size</li> <li>get_unconfirmed_transactions</li> <li>push_transaction</li> </ul> </li> <li>Errors<ul> <li>JSON-RPC Errors</li> <li>API Result Errors</li> </ul> </li> <li>Authentication</li> <li>Wallet support</li> <li>Legacy support</li> <li>API only</li> <li>Node V1 Deprecation Timeline</li> <li>Drawbacks</li> <li>Prior art</li> <li>Future possibilities</li> <li>References</li> </ul>"},{"location":"grin-rfcs/text/0007-node-api-v2/#summary","title":"Summary","text":"<p>Create a v2 JSON-RPC API for the Node API.</p>"},{"location":"grin-rfcs/text/0007-node-api-v2/#motivation","title":"Motivation","text":"<p>The previous Node API (referred to here as v1) was a REST API. This API while simple had a few drawbacks:</p> <ul> <li>Manually documented (current documentation is available here.</li> <li>Contains call with heterogenous args such as <code>?byid=xxx</code> and <code>commitment/xxx</code> which can be confusing and lack some uniformity.</li> <li>Uses REST which is bound to HTTP while v2 wallet API uses JSON-RPC.</li> <li>No difference between node management and simple information endpoints (i.e. exposing the node on the internet would allow anyone to query sensitive endpoints)</li> </ul> <p>This RFC provides a new v2 API with: - Cleaner methods and errors. - Owner and Foreign API. - Generated documentation directly on docs.rs. - Automatic testing with doc tests. - Stronger basis for future improvements.</p>"},{"location":"grin-rfcs/text/0007-node-api-v2/#community-level-explanation","title":"Community-level explanation","text":"<p>This new API will be particularly useful for wallet developer and should ultimately simplify their work on Grin. Moreover, this RFC does not introduce any breaking changes as the v1 REST API will still be around until completely deprecated.</p>"},{"location":"grin-rfcs/text/0007-node-api-v2/#reference-level-explanation","title":"Reference-level explanation","text":""},{"location":"grin-rfcs/text/0007-node-api-v2/#v1-endpoints","title":"V1 Endpoints","text":"<p>While the endpoints are documented in details here, here is an overview of the REST API Endpoints of the v1 API.</p> <pre><code>[\n  \"get blocks\",\n  \"get headers\",\n  \"get chain\",\n  \"post chain/compact\",\n  \"get chain/validate\",\n  \"get chain/kernels/xxx?min_height=yyy&amp;max_height=zzz\",\n  \"get chain/outputs/byids?id=xxx,yyy,zzz\",\n  \"get chain/outputs/byheight?start_height=101&amp;end_height=200\",\n  \"get status\",\n  \"get txhashset/roots\",\n  \"get txhashset/lastoutputs?n=10\",\n  \"get txhashset/lastrangeproofs\",\n  \"get txhashset/lastkernels\",\n  \"get txhashset/outputs?start_index=1&amp;max=100\",\n  \"get txhashset/merkleproof?n=1\",\n  \"get pool\",\n  \"post pool/push_tx\",\n  \"post peers/a.b.c.d:p/ban\",\n  \"post peers/a.b.c.d:p/unban\",\n  \"get peers/all\",\n  \"get peers/connected\",\n  \"get peers/a.b.c.d\",\n  \"get version\"\n]\n</code></pre> <p>These endpoints can be grouped into 5 categories:</p> <ul> <li>miscellaneous endpoints (which contain <code>status</code> and <code>version</code> endpoints)</li> <li><code>chain</code> endpoints (which also contain <code>blocks</code>, <code>chain</code> and headers` endpoints)</li> <li><code>peer</code> endpoints</li> <li><code>pool</code> endpoints</li> <li><code>txhashset</code> endpoints</li> </ul>"},{"location":"grin-rfcs/text/0007-node-api-v2/#v2-endpoints","title":"V2 Endpoints","text":"<p>The following endpoints are kept and refactored:</p> <pre><code>[\n  \"get blocks\",\n  \"get headers\",\n  \"get chain\",\n  \"post chain/compact\",\n  \"get chain/validate\",\n  \"get chain/kernels/xxx?min_height=yyy&amp;max_height=zzz\",\n  \"get chain/outputs/byids?id=xxx,yyy,zzz\",\n  \"get chain/outputs/byheight?start_height=101&amp;end_height=200\",\n  \"get status\",\n  \"get txhashset/outputs?start_index=1&amp;max=100\",\n  \"get pool\",\n  \"post pool/push_tx\",\n  \"post peers/a.b.c.d:p/ban\",\n  \"post peers/a.b.c.d:p/unban\",\n  \"get peers/all\",\n  \"get peers/connected\",\n  \"get peers/a.b.c.d\",\n  \"get version\"\n]\n</code></pre> <p>The logic of the following endpoints will NOT be implemented as they are purely internals:</p> <pre><code>  \"get txhashset/roots\",\n  \"get txhashset/lastoutputs?n=10\",\n  \"get txhashset/lastrangeproofs\",\n  \"get txhashset/lastkernels\",\n  \"get txhashset/merkleproof?n=1\",\n</code></pre> <p>The new Owner API endpoint methods are the following:</p> <ul> <li>get_status</li> <li>validate_chain</li> <li>compact_chain</li> <li>get_peers</li> <li>get_connected_peers</li> <li>ban_peer</li> <li>unban_peer</li> </ul> <p>The new Foreign API endpoint methods are the following:</p> <ul> <li>get_version</li> <li>get_header</li> <li>get_block</li> <li>get_tip</li> <li>get_kernel</li> <li>get_outputs</li> <li>get_unspent_outputs</li> <li>get_pool_size</li> <li>get_stempool_size</li> <li>get_unconfirmed_transactions</li> <li>push_transaction</li> </ul> <p>When running <code>grin</code> with defaults, the V2 apis are available at - <code>localhost:3413/v2/owner</code> for the owner API. - <code>localhost:3413/v2/foreign</code> for the foreign API.</p>"},{"location":"grin-rfcs/text/0007-node-api-v2/#owner-api-endpoints","title":"Owner API Endpoints","text":""},{"location":"grin-rfcs/text/0007-node-api-v2/#get_status","title":"get_status","text":"<p>Returns various information about the node, the network and the current sync status.</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"get_status\",\n  \"params\": [],\n  \"id\": 1\n}\n{\n\"id\": 1,\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"Ok\": {\n      \"protocol_version\": \"2\",\n      \"user_agent\": \"MW/Grin 2.x.x\",\n      \"connections\": \"8\",\n      \"tip\": {\n        \"height\": 371553,\n        \"last_block_pushed\": \"00001d1623db988d7ed10c5b6319360a52f20c89b4710474145806ba0e8455ec\",\n        \"prev_block_to_last\": \"0000029f51bacee81c49a27b4bc9c6c446e03183867c922890f90bb17108d89f\",\n        \"total_difficulty\": 1127628411943045\n      },\n      \"sync_status\": \"header_sync\",\n      \"sync_info\": {\n        \"current_height\": 371553,\n        \"highest_height\": 0\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"grin-rfcs/text/0007-node-api-v2/#validate_chain","title":"validate_chain","text":"<p>Trigger a validation of the chain state.</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"validate_chain\",\n    \"params\": [],\n    \"id\": 1\n}\n{\n  \"id\": 1,\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"Ok\": null\n  }\n}\n</code></pre>"},{"location":"grin-rfcs/text/0007-node-api-v2/#compact_chain","title":"compact_chain","text":"<p>Trigger a compaction of the chain state to regain storage space.</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"compact_chain\",\n    \"params\": [],\n    \"id\": 1\n}\n{\n  \"id\": 1,\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"Ok\": null\n  }\n}\n</code></pre>"},{"location":"grin-rfcs/text/0007-node-api-v2/#get_peers","title":"get_peers","text":"<p>Retrieves information about peers. If <code>null</code> is provided, <code>get_peers</code> will list all stored peers.</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"get_peers\",\n    \"params\": [\"70.50.33.130:3414\"],\n    \"id\": 1\n}\n{\n  \"id\": 1,\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"Ok\": [\n      {\n        \"addr\": \"70.50.33.130:3414\",\n        \"ban_reason\": \"None\",\n        \"capabilities\": {\n          \"bits\": 15\n        },\n        \"flags\": \"Defunct\",\n        \"last_banned\": 0,\n        \"last_connected\": 1570129317,\n        \"user_agent\": \"MW/Grin 2.0.0\"\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"grin-rfcs/text/0007-node-api-v2/#get_connected_peers","title":"get_connected_peers","text":"<p>Retrieves a list of all connected peers.</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"get_connected_peers\",\n    \"params\": [],\n    \"id\": 1\n}\n{\n  \"id\": 1,\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"Ok\": [\n      {\n        \"addr\": \"35.176.195.242:3414\",\n        \"capabilities\": {\n          \"bits\": 15\n        },\n        \"direction\": \"Outbound\",\n        \"height\": 374510,\n        \"total_difficulty\": 1133954621205750,\n        \"user_agent\": \"MW/Grin 2.0.0\",\n        \"version\": 1\n      },\n      {\n        \"addr\": \"47.97.198.21:3414\",\n        \"capabilities\": {\n          \"bits\": 15\n        },\n        \"direction\": \"Outbound\",\n        \"height\": 374510,\n        \"total_difficulty\": 1133954621205750,\n        \"user_agent\": \"MW/Grin 2.0.0\",\n        \"version\": 1\n      },\n      {\n        \"addr\": \"148.251.16.13:3414\",\n        \"capabilities\": {\n          \"bits\": 15\n        },\n        \"direction\": \"Outbound\",\n        \"height\": 374510,\n        \"total_difficulty\": 1133954621205750,\n        \"user_agent\": \"MW/Grin 2.0.0\",\n        \"version\": 1\n      },\n      {\n        \"addr\": \"68.195.18.155:3414\",\n        \"capabilities\": {\n          \"bits\": 15\n        },\n        \"direction\": \"Outbound\",\n        \"height\": 374510,\n        \"total_difficulty\": 1133954621205750,\n        \"user_agent\": \"MW/Grin 2.0.0\",\n        \"version\": 1\n      },\n      {\n        \"addr\": \"52.53.221.15:3414\",\n        \"capabilities\": {\n          \"bits\": 15\n        },\n        \"direction\": \"Outbound\",\n        \"height\": 0,\n        \"total_difficulty\": 1133954621205750,\n        \"user_agent\": \"MW/Grin 2.0.0\",\n        \"version\": 1\n      },\n      {\n        \"addr\": \"109.74.202.16:3414\",\n        \"capabilities\": {\n          \"bits\": 15\n        },\n        \"direction\": \"Outbound\",\n        \"height\": 374510,\n        \"total_difficulty\": 1133954621205750,\n        \"user_agent\": \"MW/Grin 2.0.0\",\n        \"version\": 1\n      },\n      {\n        \"addr\": \"121.43.183.180:3414\",\n        \"capabilities\": {\n          \"bits\": 15\n        },\n        \"direction\": \"Outbound\",\n        \"height\": 374510,\n        \"total_difficulty\": 1133954621205750,\n        \"user_agent\": \"MW/Grin 2.0.0\",\n        \"version\": 1\n      },\n      {\n        \"addr\": \"35.157.247.209:23414\",\n        \"capabilities\": {\n          \"bits\": 15\n        },\n        \"direction\": \"Outbound\",\n        \"height\": 374510,\n        \"total_difficulty\": 1133954621205750,\n        \"user_agent\": \"MW/Grin 2.0.0\",\n        \"version\": 1\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"grin-rfcs/text/0007-node-api-v2/#ban_peer","title":"ban_peer","text":"<p>Bans a specific peer.</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"ban_peer\",\n    \"params\": [\"70.50.33.130:3414\"],\n    \"id\": 1\n}\n{\n  \"id\": 1,\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"Ok\": null\n  }\n}\n</code></pre>"},{"location":"grin-rfcs/text/0007-node-api-v2/#unban_peer","title":"unban_peer","text":"<p>Unbans a specific peer.</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"unban_peer\",\n    \"params\": [\"70.50.33.130:3414\"],\n    \"id\": 1\n}\n{\n  \"id\": 1,\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"Ok\": null\n  }\n}\n</code></pre>"},{"location":"grin-rfcs/text/0007-node-api-v2/#foreign-api-endpoints","title":"Foreign API Endpoints","text":""},{"location":"grin-rfcs/text/0007-node-api-v2/#get_version","title":"get_version","text":"<p>Returns the node version and block header version (used by grin-wallet).</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"get_version\",\n  \"params\": [],\n  \"id\": 1\n}\n{\n\"id\": 1,\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"Ok\": {\n      \"node_version\": \"2.1.0-beta.2\",\n      \"block_header_version\": 2\n    }\n  }\n}\n</code></pre>"},{"location":"grin-rfcs/text/0007-node-api-v2/#get_header","title":"get_header","text":"<p>Gets block header given either a height, a hash or an unspent output commitment. Only one parameter is required. If multiple parameters are provided only the first one in the list is used.</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"get_header\",\n    \"params\": [null, \"00000100c54dcb7a9cbb03aaf55da511aca2c98b801ffd45046b3991e4f697f9\", null],\n    \"id\": 1\n}\n{\n  \"id\": 1,\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"Ok\": {\n      \"cuckoo_solution\": [\n        9886309,\n        35936712,\n        43170402,\n        48069549,\n        70022151,\n        97464262,\n        107044653,\n        108342481,\n        118947913,\n        130828808,\n        144192311,\n        149269998,\n        179888206,\n        180736988,\n        207416734,\n        227431174,\n        238941623,\n        245603454,\n        261819503,\n        280895459,\n        284655965,\n        293675096,\n        297070583,\n        299129598,\n        302141405,\n        313482158,\n        321703003,\n        351704938,\n        376529742,\n        381955038,\n        383597880,\n        408364901,\n        423241240,\n        436882285,\n        442043438,\n        446377997,\n        470779425,\n        473427731,\n        477149621,\n        483204863,\n        496335498,\n        534567776\n      ],\n      \"edge_bits\": 29,\n      \"hash\": \"00000100c54dcb7a9cbb03aaf55da511aca2c98b801ffd45046b3991e4f697f9\",\n      \"height\": 374336,\n      \"kernel_root\": \"d294e6017b9905b288dc62f6f725c864665391c41da20a18a371e3492c448b88\",\n      \"nonce\": 4715085839955132421,\n      \"output_root\": \"12464313f7cd758a7761f65b2837e9b9af62ad4060c97180555bfc7e7e5808fa\",\n      \"prev_root\": \"e22090fefaece85df1441e62179af097458e2bdcf600f8629b977470db1b6db1\",\n      \"previous\": \"0000015957d92c9e04c6f3aec8c5b9976f3d25f52ff459c630a01a643af4a88c\",\n      \"range_proof_root\": \"4fd9a9189e0965aa9cdeb9cf7873ecd9e6586eac1dd9ca3915bc50824a253b02\",\n      \"secondary_scaling\": 561,\n      \"timestamp\": \"2019-10-03T16:08:11+00:00\",\n      \"total_difficulty\": 1133587428693359,\n      \"total_kernel_offset\": \"0320b6f8a4a4180ed79ecd67c8059c1d7bd74afe144d225395857386e5822314\",\n      \"version\": 2\n    }\n  }\n}\n</code></pre>"},{"location":"grin-rfcs/text/0007-node-api-v2/#get_block","title":"get_block","text":"<p>Gets block details given either a height, a hash or an unspent output commitment. Only one parameter is required. If multiple parameters are provided only the first one in the list is used.</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"get_block\",\n    \"params\": [374274, null, null],\n    \"id\": 1\n}\n{\n  \"id\": 1,\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"Ok\": {\n      \"header\": {\n        \"cuckoo_solution\": [\n          1263501,\n          14648727,\n          42430559,\n          58137254,\n          68666726,\n          72784903,\n          101936839,\n          104273571,\n          123886748,\n          131179768,\n          155443226,\n          162493783,\n          164784425,\n          167313215,\n          169806918,\n          183041591,\n          184403611,\n          210351649,\n          215159650,\n          239995384,\n          240935454,\n          257742462,\n          280820644,\n          300143903,\n          303146496,\n          311804841,\n          341039986,\n          354918290,\n          363508555,\n          377618528,\n          396693709,\n          397417856,\n          399875872,\n          413238540,\n          413767813,\n          432697194,\n          436903767,\n          447257325,\n          453337210,\n          459401597,\n          496068509,\n          511300624\n        ],\n        \"edge_bits\": 29,\n        \"hash\": \"000001e16cb374e38c979c353a0aaffbf5b939da7688f69ad99efda6c112ea9b\",\n        \"height\": 374274,\n        \"kernel_root\": \"e17920c0e456a6feebf19e24a46f510a85f21cb60e81012f843c00fe2c4cad6e\",\n        \"nonce\": 4354431877761457166,\n        \"output_root\": \"1e9daee31b80c6b83573eacfd3048a4af57c614bd36f9acd5fb50fbd236beb16\",\n        \"prev_root\": \"9827b8ffab942e264b6ac81f2b487e3de65e411145c514092ce783df9344fa8a\",\n        \"previous\": \"00001266a73ba6a8032ef8b4d4f5508407ffb1c270c105dac06f4669c17af020\",\n        \"range_proof_root\": \"3491b8c46a3919df637a636ca72824377f89c4967dcfe4857379a4a82b510069\",\n        \"secondary_scaling\": 571,\n        \"timestamp\": \"2019-10-03T15:15:35+00:00\",\n        \"total_difficulty\": 1133438031814173,\n        \"total_kernel_offset\": \"63315ca0be65c9f6ddf2d3306876caf9f458a01d1a0bf50cc4d3c9b699161958\",\n        \"version\": 2\n      },\n      \"inputs\": [],\n      \"kernels\": [\n        {\n          \"excess\": \"08761e9cb1eea5bfcf771d1218b5ec802798d6eecaf75faae50ba3a1997aaef009\",\n          \"excess_sig\": \"971317046c533d21dff3e449cc9380c2be10b0274f70e009aa2453f755239e3299883c09a1785b15a141d89d563cdd59395886c7d63aba9c2b6438575555e2c4\",\n          \"features\": \"Coinbase\",\n          \"fee\": 0,\n          \"lock_height\": 0\n        }\n      ],\n      \"outputs\": [\n        {\n          \"block_height\": 374274,\n          \"commit\": \"09d33615563ba2d65acc2b295a024337166b9f520122d49730c73e8bfb43017610\",\n          \"merkle_proof\": \"00000000003e6f5e000000000000000f60fe09a7601a519d9be71135404580ad9de0964c70a7619b1731dca2cd8c1ae1dce9f544df671d63ff0e05b58f070cb48e163ca8f44fb4446c9fe1fc9cfef90e4b81e7119e8cf60acb9515363ecaea1ce20d2a8ea2f6f638f79a33a19d0d7b54cfff3daf8d21c243ba4ccd2c0fbda833edfa2506b1b326059d124e0c2e27cda90268e66f2dcc7576efac9ebbb831894d7776c191671c3294c2ca0af23201498a7f5ce98d5440ca24116b40ac98b1c5e38b28c8b560afc4f4684b81ab34f8cf162201040d4779195ba0e4967d1dd8184b579208e9ebebafa2f5004c51f5902a94bf268fd498f0247e8ba1a46efec8d88fa44d5ecb206fbe728ee56c24af36442eba416ea4d06e1ea267309bc2e6f961c57069e2525d17e78748254729d7fdec56720aa85fe6d89b2756a7eeed0a7aa5d13cfb874e3c65576ec8a15d6df17d7d4856653696b10fb9ec205f5e4d1c7a1f3e2dd2994b12eeed93e84776d8dcd8a5d78aecd4f96ae95c0b090d104adf2aa84f0a1fbd8d319fea5476d1a306b2800716e60b00115a5cca678617361c5a89660b4536c56254bc8dd7035d96f05de62b042d16acaeff57c111fdf243b859984063e3fcfdf40c4c4a52889706857a7c3e90e264f30f40cc87bd20e74689f14284bc5ea0a540950dfcc8d33c503477eb1c60\",\n          \"mmr_index\": 4091742,\n          \"output_type\": \"Coinbase\",\n          \"proof\": \"7adae7bcecf735c70eaa21e8fdce1d3c83d7b593f082fc29e16ff2c64ee5aaa15b682e5583257cf351de457dda8f877f4d8c1492af3aaf25cf5f496fce7ca54a0ef78cc61c4252c490386f3c69132960e9edc811add6415a6026d53d604414a5f4dd330a63fcbb005ba908a45b2fb1950a9529f793405832e57c89a36d3920715bc2d43db16a718ecd19aeb23428b5d3eeb89d73c28272a7f2b39b8923e777d8eb2c5ce9872353ba026dc79fdb093a6538868b4d184215afc29a9f90548f9c32aa663f9197fea1cadbb28d40d35ed79947b4b2b722e30e877a15aa2ecf95896faad173af2e2795b36ce342dfdacf13a2f4f273ab9927371f52913367d1d58246a0c35c8f0d2330fcddb9eec34c277b1cfdaf7639eec2095930b2adef17e0eb94f32e071bf1c607d2ef1757d66647477335188e5afc058c07fe0440a67804fbdd5d35d850391ead3e9c8a3136ae1c42a33d5b01fb2c6ec84a465df3f74358cbc28542036ae4ef3e63046fbd2bce6b12f829ed193fb51ea87790e88f1ea686d943c46714b076fb8c6be7c577bca5b2792e63d5f7b8f6018730b6f9ddaf5758a5fa6a3859d68b317ad4383719211e78f2ca832fd34c6a222a8488e40519179209ad1979f3095b7b7ba7f57e81c371989a4ace465149b0fe576d89473bc596c54cee663fbf78196e7eb31e4d56604c5226e9242a68bda95e1b45473c52f63fe865901839e82079a9935e25fe8d44e339484ba0a62d20857c6b3f15ab5c56b59c7523b63f86fa8977e3f4c35dc8b1c446c48a28947f9d9bd9992763404bcba95f94b45d643f07bb7c352bfad30809c741938b103a44218696206ca1e18f0b10b222d8685cc1ed89d5fdb0c7258b66486e35c0fd560a678864fd64c642b2b689a0c46d1be6b402265b7808cd61a95c2b4a4df280e3f0ec090197fb039d32538d05d3f0a082f5\",\n          \"proof_hash\": \"cfd97db403c274220bb0dbaf3ecc88e483c0b707d8e6f16dfda37cd4f2c3211c\",\n          \"spent\": false\n        }\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"grin-rfcs/text/0007-node-api-v2/#get_tip","title":"get_tip","text":"<p>Returns details about the state of the current fork tip.</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"get_tip\",\n    \"params\": [],\n    \"id\": 1\n}\n{\n  \"id\": 1,\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"Ok\": {\n      \"height\": 374350,\n      \"last_block_pushed\": \"000000543c69a0306b5463b92939643442a44a6d9be5bef72bea9fc1d718d310\",\n      \"prev_block_to_last\": \"000001237c6bac162f1add2b122fab6a254b9fcc2c4b4c8c632a8c39855521f1\",\n      \"total_difficulty\": 1133621604919005\n    }\n  }\n}\n</code></pre>"},{"location":"grin-rfcs/text/0007-node-api-v2/#get_kernel","title":"get_kernel","text":"<p>Returns a <code>LocatedTxKernel</code> based on the kernel excess. The <code>min_height</code> and <code>max_height</code> parameters are both optional. If not supplied, <code>min_height</code> will be set to 0 and <code>max_height</code> will be set to the head of the chain. The method will start at the block height <code>max_height</code> and traverse the kernel MMR backwards, until either the kernel is found or min_height is reached.</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"get_kernel\",\n    \"params\": [\"09c868a2fed619580f296e91d2819b6b3ae61ab734bf3d9c3eafa6d9700f00361b\", null, null],\n    \"id\": 1\n}\n{\n  \"id\": 1,\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"Ok\": {\n      \"height\": 374557,\n      \"mmr_index\": 2211662,\n      \"tx_kernel\": {\n        \"excess\": \"09c868a2fed619580f296e91d2819b6b3ae61ab734bf3d9c3eafa6d9700f00361b\",\n        \"excess_sig\": \"1720ec1b94aa5d6ba4d567f7446314f9a6d064eea69c5675cc5659f65f290d80b0e9e3a48d818cadba0a4e894bbc6eb6754b56f53813e2ee0b1447969894ca4a\",\n        \"features\": \"Coinbase\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"grin-rfcs/text/0007-node-api-v2/#get_outputs","title":"get_outputs","text":"<p>Retrieves details about specifics outputs. Supports retrieval of multiple outputs in a single request. Support retrieval by both commitment string and block height. Last field are for whether or not the response will include rangeproof and merkle proof.</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"get_outputs\",\n    \"params\": [\"09bab2bdba2e6aed690b5eda11accc13c06723ca5965bb460c5f2383655989af3f\",\"08ecd94ae293863286e99d37f4685f07369bc084ba74d5c59c7f15359a75c84c03\"],376150, 376154, true, true],\n    \"id\": 1\n}\n{\n  \"id\": 1,\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"Ok\": [\n      {\n        \"block_height\": 374568,\n        \"commit\": \"09bab2bdba2e6aed690b5eda11accc13c06723ca5965bb460c5f2383655989af3f\",\n        \"merkle_proof\": null,\n        \"mmr_index\": 4093403,\n        \"output_type\": \"Transaction\",\n        \"proof\": \"e30aa961d6f89361a9a3c60f73e3551f50a3887212e524b5874ac50c1759bb95bc8e588d82dd51d84c7cbaa9abe79e0b8fe902bcfda17276c24d269fbf636aa2016c65a760a02e18338a33e83dec8e51fbfd953ee5b765d97ce39ba0850790d2104812a1d15d5eaa174de548144d3a7d413906d85e22f89065ef727910ee4c573494520c43e36e83dacee8096666aa4033b5e8322e72930c3f8476bb7be9aef0838a2ad6c28f4f5212708bf3e5954fc3971d66b7835383b96406fa65415b64ecd53a747f41d785c3e3615c18dfdbe39a0920fefcf6bc55fe65b4b215b1ad98c80fdafbef6f21ab60596f2d9a3e7bc45d750e807d5eb883dadde1625d4f20af9f1315b8bea08c97fad922afe2000c84c9eb5f96b2a24da7a637f95c1102ecfc1257e19bc4120082f5ee76448c90abd55108256f8341e0f4009cfc3906a598de465467ee1ee072bfd3384e1a0b9039192d1edc33092d7b09d1164c4fc4c378227a391600a8a5d5ba5fe36a2a4eabe0dbae270aefa5a5f2df810cda79211805206ad93ae08689e2675aad025db3499d43f1effc110dfb2f540ccd6eb972c02f98e8151535c099381c8aeb1ea8aad2cfdf952e6ab9d26e74a5611d943d02315e212eb06ce2cd20b4675e6f245e5302cdb8b31d46bb2e718b50ecfad2d440323826570447c2498376c8bad6e4ee97bde41c47f6a20eea406d758c53fb9e8542f114c1a277a6335ad97fdc542c6bbec756dc4a9085c319fe6f0c9e1bb043f01a43c12aa6f4dff8b1220e7f16bc56dee9ccb59fb7c3b7aa6bb33b41c33d8e4b03b6b9cb89491504210dd691b46ffe2862387339d2b62a9dc4c20d629e23eb8b06490c4999433c1b4626fb4d21517072bd8e82511c115ee47bf9a5e40f0a74177f5b573db2e277459877a01b172e026cbb3f76aaf0c61f244584f3a76804dea62175a80d777238\",\n        \"proof_hash\": \"660d706330fc36f611c50d90cb965fddf750cc91f8891a58b5e39b83a5fc6b46\",\n        \"spent\": false\n      },\n      {\n        \"block_height\": 376151,\n        \"commit\": \"08ecd94ae293863286e99d37f4685f07369bc084ba74d5c59c7f15359a75c84c03\",\n        \"merkle_proof\": \"6b2abbd334c9d75409461fba9c1acd4a8d7bc2ab0bc43143f42388b2a3a87b881505ccf8ffc8737fa6fd4fe412a082d974911bd223eae612d0d1d7ddcc09b5e6079c40b011405b2ccb49ce32473c93aea6d843488d5765fea114d3368d34cd05fcb8c2de3903fbaf39b1f064c809f9f1c0d47959d81a508957040eda55c6dce6dd8c43a79c72faffacfabe1d73055790b6249de2f7c603f186cb109eee58fb1426ea48cb781f88df9acd8996d235fe6bfe60e02aae6e3bfe38ed2599baca1430b3b637072d9bdcdc7644f873728e3cd38eff7124ea848cfad67f8e114cf8595c89a3686a4271cfb2b5098597c315c01d04270ca8f70262af967a947f49adacfa4aad8b6fd196dd0ef4e5cefa132c38c7e5f43db12b3d74f0a8d83c3404e73c6b25a12bff70a8ef4526c89b1558810bb744ede53f8c4cc8cc2555e953637722adb41ea5752281cf1f75599f7e59b17f11f5f9ce4f6b2da4141a3398f51d8b834cdc8b00f61915a41d200572a10bb2102cbae7e94aa7ced3c388dcd58282932c99a8fa66f6fc511ff3e8c60d442bbdb49cca1166328ca8c9bbc97d024570b4cc1ca6c7dba3db223e9e27fd9345b94d3cf10e2b54915b87c57e32965bc2db1b1f956d1962812738ca9b2c93fd7825adf4dffddc97aa85ca0f3f412f02d30678a816d2efbfb6778305fd5e610b6e8af30030bc059880c337bfde326b392d5dcd7c36cb0076fbccc7099b94f1f03bdb525d6e3818b6d50b93ced802957a4b03892c71b6679052bd35e92ceea71a96b22b2ed2c129755f0c74fa172f43da2790f3132a7e57e408d2fc5f1126b088cd0398e6dedcb237242e6720e12e8d7a5a1e196eda6241cfee1cc85e9d20af67f3f9bdf91160516ebcd0b8da6bb7b12229e1112b22c9f1aaef1d75441465cfee2ac1c47b5255514316ed4637e192b00ff28491168f2f2b00\",\n        \"mmr_index\": 4107711,\n        \"output_type\": \"Coinbase\",\n        \"proof\": \"7083884b5f64e4e61fb910d2c3c603f7c94490716d95e7144b4c927d0ca6ccc0e069cc285e25f38ee90c402ef26005cad2b4073eeba17f0ae3ea2b87095106ef00634f321d8a49c2feaad485bc9ee552564a6a883c99886d0d3a85af3490d718f5a5cbc70f9dcc9bf5d987fb6072132a4c247d4bbd4af927532a887b1e4250b7277771f6b82f43f4fb5a48089ed58e7d3190a19197e07acfed650f8b2cd5f103e994fb3d3735c5727f06f302bd1f182586297dd57a7951ff296bdf6106704abedc39db77f1293effaa7496a77d19420a6208bc1c589b33dad9540cb6180cccf5e085006b01309419f931e54531d770e5fe00eca584072692a7e4883fd65ed4a7c460665608ab96bf0c7d564fe96a341f14066db413a6fddc359eb11f6f962aca70ca1414c35d7941ce06b77d0a0606081b78d5e64a4501f8e8eba9f0e0889042bc54b4cbfd71087a95af63e0306dba214084d4860b0ce66dc80af44224e5a6fef55800650b05cf1639f81bfdc30950f3634d1fd4375d50c22c7f13f3dfb690e5f155a535aff041b7f800bfe74c60f606e8ab47df60754a0e08221c2a50abe643bb086433afd040a7e6290d1d00b3fe657be3bb05c67f90eb183c2acb53c81e1ca15cd8d35fe9d7d52d8f455398e905bdc77ffb211697d477af25704cf9896e8ce797f4fed03e2ba1615e3ad5646eecaa698470f99437d01d5193f041201502763e8bde51e6dc830b5c676d05c8f7f87c4972c578b8d9d5922ba29f6e4a89a123311d02b5ac44a7d5307f7ed5e4e66aaf749afc76c6fc1114445d6fafeea816a0f985eeacdbe9e6d32a8514ca4aaf7faad4e9d43cde55327ac84bac4d70a9319840e136e713aa31d639e43302f3c71a79f08f4e5c9a19a48d4b46403734cd8f3cc9b67bc26ea8e2a01e63a6f5be6e044e8ed5db5f26d15d25de75f672a79315c5e2407e\",\n        \"proof_hash\": \"7cf77fdaecef6c6fc01edca744c1521581f854a9bac0153971edbb1618fc36ad\",\n        \"spent\": false\n      },\n      {\n        \"block_height\": 376154,\n        \"commit\": \"095c12db5e57e4a1ead0870219bda4ebfb1419f6ab1501386b9dd8dc9811a8c5ff\",\n        \"merkle_proof\": \"00000000003eadc6000000000000000e13c509a17cbb0d81634215cd2482ab6d9eb58b332fcbe6b2c4fa458a63d3cb0dfe3614ebe6e52657870df225d132179fa1ea0fdc2105f0e51d03bc3765a9cd059c60d434a7cae0a3d669b37588c25410f57405c841312cfa50cf514678877a3f4ce8bd3e57723ba75a2b7d61027b2088fbabebdb7336b97ea88b00a7e809a6245def980eba18d987601f4cbd6c3cc9f12a5684fe7a1bc2565a9f8ab63c2db1afa8304f5e23d4754cd97f29c8b06dcb3de4f6d3a83079676b6e9941afe5553a7195384b564ecd6d37522cb5e452cc930d2b549af22698a8fd9bf6cad05a06b09e3f6e672b94e82c0255394b5c187ab76fda653a2491378997ba3d49f9d9c34ca93bc627fe5d98b327c03d429b5473f62672e9d73c4eafd9cb8f62e5158a1ec7eb56653696b10fb9ec205f5e4d1c7a1f3e2dd2994b12eeed93e84776d8dcd8a5d78aecd4f96ae95c0b090d104adf2aa84f0a1fbd8d319fea5476d1a306b2800716e60b00115a5cca678617361c5a89660b4536c56254bc8dd7035d96f05de62b042d16acaeff57c111fdf243b859984063e3fcfdf40c4c4a52889706857a7c3e90e264f30f40cc87bd20e74689f14284bc5ea0a540950dfcc8d33c503477eb1c60\",\n        \"mmr_index\": 4107717,\n        \"output_type\": \"Coinbase\",\n        \"proof\": \"073593bc475478f1e4b648ab261df3b0a6e5a58a617176dd0c8f5e0e1d58b012b40eb9b341d16ee22baf3645ea37705895e731dee5c220b58b0f780d781806a10dfa33e870d0494fba18aaa8a7a709bfb3ddf9eb3e4e75a525b382df68dc6f710275cdffb623373c47c1310ae63479826f435ca4520fdc13bb0d995b7d9a10a7587d61bd4a51c9e32c87f3eb6b0f862cdff19a9ac6cb04d6f7fafb8e94508a851dcf5dc6acea4271bb40117a45319da5522b966091b089698f4f940842458b5b49e212d846be35e0c2b98a00ac3d0b7ceaf081272dbed8abd84fe8f26d57bac1340e8184602436ed8c4470ef9dc214df3405de0e71703abec4456b15e122a94706852bb476213ceadf00529d00d8d3b16dc57f4e4a9a86dacfa719e00366728de42f3f830e73f6113f1e391fab07eba1b40f6466203b0ce14701230e934f6138c575660a03dbb0e59d7295df3115a4fc0909a5520d74657b319fc83481079ad6c13400175e39fa2b86071ba563ce8836320713ef8f55d4e90bee3f57df96c7aef0f2e896f57192fae9675471cd9751bcaf2b15e5a65a9733a6f7f9b8147b8f6e8dac51d056018d411fd252225cf88e56f143143f49e8a0d2e43c10de0442dbc84966817532b1256b6769db987526790a389c371a1fe7a36eacffef82877b4db7a9b5e58722ffbd0fc4fdbd7624365ee326bb8b1e60b999f513715b30f37ef6116eabf53b3524b46c33a1fac49205b39e24aa388d823269c1fc43c3599a06b69433a0a47a03bd871321afb7846a6dbfd5891bd84f89c556231745c929d08445f66f332857bfda1c4f86ae58a01007b7303f870ac24e0ba72d84c0ef4903ac2ff777e2c2dcb4d8e303c74e0c8a559686b4d4c25024ee97601787d4e5a97224af41e5d35d91744292f5a41f64d4e1cae77bebebd77a473f3b54e86f7221aac230942f0468\",\n        \"proof_hash\": \"5dd69c083e2c0fd797a499bbafedee0728849afa3476034280ecadf6eb4bffc2\",\n        \"spent\": false\n      },\n      {\n        \"block_height\": 376153,\n        \"commit\": \"0948cb346b7affe004a6f84fa4b5b44995830f1c332b03537df4c258d51d1afb50\",\n        \"merkle_proof\": \"00000000003eadc4000000000000000dfe3614ebe6e52657870df225d132179fa1ea0fdc2105f0e51d03bc3765a9cd059c60d434a7cae0a3d669b37588c25410f57405c841312cfa50cf514678877a3f4ce8bd3e57723ba75a2b7d61027b2088fbabebdb7336b97ea88b00a7e809a6245def980eba18d987601f4cbd6c3cc9f12a5684fe7a1bc2565a9f8ab63c2db1afa8304f5e23d4754cd97f29c8b06dcb3de4f6d3a83079676b6e9941afe5553a7195384b564ecd6d37522cb5e452cc930d2b549af22698a8fd9bf6cad05a06b09e3f6e672b94e82c0255394b5c187ab76fda653a2491378997ba3d49f9d9c34ca93bc627fe5d98b327c03d429b5473f62672e9d73c4eafd9cb8f62e5158a1ec7eb56653696b10fb9ec205f5e4d1c7a1f3e2dd2994b12eeed93e84776d8dcd8a5d78aecd4f96ae95c0b090d104adf2aa84f0a1fbd8d319fea5476d1a306b2800716e60b00115a5cca678617361c5a89660b4536c56254bc8dd7035d96f05de62b042d16acaeff57c111fdf243b859984063e3fcfdf40c4c4a52889706857a7c3e90e264f30f40cc87bd20e74689f14284bc5ea0a540950dfcc8d33c503477eb1c60\",\n        \"mmr_index\": 4107716,\n        \"output_type\": \"Coinbase\",\n        \"proof\": \"72950da23ad7f0d0381e2f788bf0ac6b6bcb17aaccf0373534122a95714d2d0dbf6a24822b4aab0711a595c80bc36122957111c39292f2a36a973252fb88cbda0b1d61ea8ea84f5171a61f751cac97332637b7cf74cc73144b912ba700dedaa60895f06e947f1e42a8c79d70f924f45fdcb6df5d30289f36ff77d0ae368df5775a739b7a25cbfb63f0cdbdc167b046067c2a021fe0950c7b67515b185b9e4a00ce63b795d49ae184fe5cc726d72fc05d717c4fb55dd5f65967dc282d3c47cb6f8a92cb696e5a1d8cca21214bc766e3de6271791cebf646cda97ae77035da16606f3397f71e103137358c97b9943c3e15403184f61230bd0e3954c7681a0891aa7a0cc32e82d830fb7d8759a04d1da7058630a853508df095142f22158c28bd5e3f2477ad6c8990e63d0377a0fa3d588b6584453778eb38cbaec8a33c1d3772c97a826d4a2f6953c35342993b04567e9fea6fc64fb714653f934faa1a8f635d39eb2903de4bed960a3df07dce7c2e3ff517bbc15f467d0190a579bc07b0f1a910b23269d794835bbb34e8318dcc4fd4159f8f03faa77842d445cf61af9e33caf46aa5fae0812a6476a09c0757e929271a96a245701ab14c1fdd836b92b7e763afa623017f68f1bc4eb716ce735820a1311b743dd8d5c6bb275a2e4e7d2eff8f45417b60cc937086c3e7fd3b612ae064d7237eb6a7bd1a39d8575fac312068fa060bc1ceac4df0754601edaf04ecb1b89c0661ea01a593c3763e456bebbd8487edc0ff3bc6f203965cd92b1706070c59a3795f9dee23087cea0aaec015f1b7bfe4df81818d7a37af781ca7b757ace2fa489f85215ecb85976b1c74c7f1df6d834a8bc63e887407ef6e233c55ea040bc5f2471e99ebc92f2283ff592ff751d9226bd105e68e187c91ecb236c9fa4fb060ae4d706c571ac2123da1debd12737d98be118578\",\n        \"proof_hash\": \"0ce421970d13fe9b3981e308c5d0b549982cdda9f69918289cd95ffcd09e0fc2\",\n        \"spent\": false\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"grin-rfcs/text/0007-node-api-v2/#get_unspent_outputs","title":"get_unspent_outputs","text":"<p>UTXO traversal. Retrieves last utxos since a start index until a max. Last boolean is optional to whether or not return the rangeproof.</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"get_unspent_outputs\",\n    \"params\": [1, 2, true],\n    \"id\": 1\n}\n{\n  \"id\": 1,\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"Ok\": {\n      \"highest_index\": 2078061,\n      \"last_retrieved_index\": 30,\n      \"outputs\": [\n        {\n          \"block_height\": 1,\n          \"commit\": \"08b7e57c448db5ef25aa119dde2312c64d7ff1b890c416c6dda5ec73cbfed2edea\",\n          \"merkle_proof\": null,\n          \"mmr_index\": 1,\n          \"output_type\": \"Coinbase\",\n          \"proof\": \"9330ad8cde205f317c6537eca96b866293a0489615a9a277b4d3a597c873544c82474932b641e06ac8719604ee52e895e8cd4621b6bfb85780cd9becce14d0700b83a664db2f52a26c425fd777ad88944cdfff38043a2793ed4d9aa67e36cbfd5585579fc69dda930418af5eaf603654f6f751258d2dfc8c2113c171e130f31ec1e6cce2a718e435298fce5d64ffe1bd3464fd7c87cfa92093855be034bfe4439e928bd92ad77fd0a0e00355ee1d1a9ceb1ed0c408dcfdba8c583e7598dc700aaa9f91432097259a405f5b7315a2f7658861e3349bb0dc8bf883726a215f0149ded6613e5ac0670c0c5202247d7c27c8a7d03bdb03c9cf5455463f9b42cf87403e31f8383cc4f49a34c62ae459f5801a9eed4f0ee3dfd5f55b7011c0cae393c474abd6f8c7965b9b5fff3104dd4e39542077c0c8dd2f8ffceb6bb598512d90506d0a7184f20f1498cf458787f23284b54888c9be416d103f760406357a16b6d841a303d5c95b6b474d2d7f0fea0a2a76c897dd2110e9303f54684169421147684c6f1819c33cef3f38ec995a508450c02cd1872f8065fdee723109c18b1dd2ddde75825546ecf0df0793c353b20c946cd64122cea8c116f432336899a16ad24a2aafcb8f900e09a1147135fcf2a54cbf81db308a47a08a49c77c130e5dc5e661cd55a5cc69e607055a5b08111bf61a62ea5778f85119043633f1cab8c756d756c5a34851024ac311a596b1cd919bbca43226f0ba057f6b57de2f6955b0823c3826de7f6096c1c1b6b9b8e4063e1645c0bff32f80561aaa959d97120fbc2ecd9d2be28bd0c17811dc59a88049f6d8952ee9a0a0207693c89ca3ad1197e9bfdfc03be9d845aea8d663969217e3b494cee9e652bc9f8713e2fd5cb1843848f46c3a6ab024d0e3d57ca45454cdbda414adaa835fa147deb4ffb7129cf3a8d86726a0144794\",\n          \"proof_hash\": \"6c301688d9186c3a99444f827bdfe3b858fe87fc314737a4dc1155d9884491d2\",\n          \"spent\": false\n        },\n        {\n          \"block_height\": 29,\n          \"commit\": \"09bab1ddad0f6fec1aedcd3830c5c647515ad543929e722344e4a8d390b6fdd51b\",\n          \"merkle_proof\": null,\n          \"mmr_index\": 55,\n          \"output_type\": \"Coinbase\",\n          \"proof\": \"4a5f858d4311bdd902f4446682f27f64be376283b1171060fd2ad33d85350fee13c25a030874d6308d2b325995a3fe545eb1d85ba66e2ba002b794edfdeacb3f0fd2a690b9a78137771b3633aaef2a77f62fbe4d6b4b373c4bdb7e5f58cfae361a3b4c2e4420cc0d38465b2444e01b50e57c6ebfc2afd6dda9017e54585638bddef17d181d1fd7064d975d8bb1dcfd96c89486aed4680b4d39294a141581d1f51c1acfbb80e2ffc40f8499cdc43be04cacda1e34dd6592edfc500229aa70db1c2869f974cfe9aee0cab696c198624de8ecdaf5ae481a1e46fe79fe983209459b89492f2b24416c368394c43c60c33d0fdd1792f0a58d11763e7c8b89d27da25109db346e4d7b62935d182b45dfb659829c55922350e6f7e3452d9311e527ec5b561f4d043cef865f683fce1ce2d410d414f5bcee63c4bbc00964b0fa757bdfd68158e22c1068d871a45759fbd527883c0451db6f36b15139864b6177a78ad64d326e0152914e5313a97ed7b685e5089f2758bf072c804560306bd944831f067c3413ded09330fd788f353e4ee875d3c9303dd4ec0dda9d55b4a27d7748b3247fe85cf3d26b7004e6e3379041fad136fccdacd02b06456a50ad40a3259842c0794f2d59dbd8fa6b4af065b38c388d76b82136b633b06779e4eb05b5b62ec37cdc2986327639bafa8651318f4c00c066e6f45504ec9a96874d5510b519f434a1a88175d51f86e8ee36ae18d107cfaf83e60b2e62fff032c7539be66d776e3a52c5f9b0ee6fe08820d65cd75d35c793e5ab3914adf5a97b7dba75e90d4a4c9aa844e2f1e9464cd5fc4923b475defca4e3b03e1b33353ff91ac1084712cf4445e329ffdbe1e2da16ae71dee0e914b546fdc0db9b0fcde80822ee716e9f2eec90db7aa4417d53a1266e1e8383e20c9a9548bae35c2a8e1293a49e7afbd8011a9e66e79ed6be\",\n          \"proof_hash\": \"a64ed774d824dc55123c6c5ba46d84bac15b6ead8cb60200836c2a0e74506ab0\",\n          \"spent\": false\n        }\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"grin-rfcs/text/0007-node-api-v2/#get_pmmr_indices","title":"get_pmmr_indices","text":"<p>Retrieves the PMMR indices based on the provided block height(s).</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"get_pmmr_indices\",\n    \"params\": [1, 200],\n    \"id\": 1\n}\n{\n  \"id\": 1,\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"Ok\": {\n      \"highest_index\": 398,\n      \"last_retrieved_index\": 2,\n      \"outputs\": []\n    }\n  }\n}\n</code></pre>"},{"location":"grin-rfcs/text/0007-node-api-v2/#get_pool_size","title":"get_pool_size","text":"<p>Returns the number of transactions in the transaction pool.</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"get_pool_size\",\n    \"params\": [],\n    \"id\": 1\n}\n{\n  \"id\": 1,\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"Ok\": 1\n  }\n}\n</code></pre>"},{"location":"grin-rfcs/text/0007-node-api-v2/#get_stempool_size","title":"get_stempool_size","text":"<p>Returns the number of transactions in the stem transaction pool.</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"get_stempool_size\",\n    \"params\": [],\n    \"id\": 1\n}\n{\n  \"id\": 1,\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"Ok\": 0\n  }\n}\n</code></pre>"},{"location":"grin-rfcs/text/0007-node-api-v2/#get_unconfirmed_transactions","title":"get_unconfirmed_transactions","text":"<p>Returns the unconfirmed transactions in the transaction pool. Will not return transactions in the stempool.</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"get_unconfirmed_transactions\",\n    \"params\": [],\n    \"id\": 1\n}\n{\n  \"id\": 1,\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"Ok\": [\n      {\n        \"src\": \"Broadcast\",\n        \"tx\": {\n          \"body\": {\n            \"inputs\": [\n              {\n                \"commit\": \"0992ce1827ec349e9f339ce183ffd01db39bf43999799d8191bfc267a58f0a715c\",\n                \"features\": \"Coinbase\"\n              },\n              {\n                \"commit\": \"0943a3c4ee4a22a5b086c26f8e6dc534204dafde0cf4c07e0c468d224dd79127ec\",\n                \"features\": \"Plain\"\n              }\n            ],\n            \"kernels\": [\n              {\n                \"excess\": \"083c49eaaf6380d44596f52cce4cf278cfac6dd34fbef73981002d8f1e8ee8abe4\",\n                \"excess_sig\": \"3f011e7e288231d67f42cb4f6416c4720e6170d5e3c805a52d33aa4521328f9be0303be654bc8ddcd3111aadc27c848b9cf07e0a70885ef79be70b7bb70f8c75\",\n                \"features\": {\n                  \"Plain\": {\n                    \"fee\": 7000000\n                  }\n                }\n              }\n            ],\n            \"outputs\": [\n              {\n                \"commit\": \"0873fafd4a0e4f365939e24c68eeb18aafc6674ca244a364dcdbfa8fa525e7bae1\",\n                \"features\": \"Plain\",\n                \"proof\": \"4b675be40672d5965c43d9f03880560a8ac784ee3de8768e28c236a4bc43b8c3d4bc83dee00d2b96530af9607c3b91d9a828f0234bf2aaf7e7c0e9cf936db69c04ca1b267668fbdb2f08ce05c8b119c9d886ceaafb4634b7fae7ea01966ad825dddc9ffab8093155d9c5d268160b86fcad95f4f5e66bf46ff642a51629dbdfd7bba7936846915b925d547337a1b95c33030fad4178468825936242e631797aa3a8f0a5ae0d23040938622648c8432fc247a902abad27e383affb4ec518e4f6f55f55e264bc0f99957be203cfb26d4b8e561fb36da55a50b6ef5861134c484556d701133e1dceda5ea53e731184e0a11f33d06e13ca37d03d39dd047170580534b049862fcd6c73decc7c0af45a267ed148fe6ef2cc375ffebfa8187d2fa0a134428a036d2ec1f65d3ce036b955730fc1ee43b23b574bae2b58b7adfa2a7a45cdec393d9b658857c911560aa3c44cf4435a99d68f3dbc81c82ea43e426ef0198148a90336ee72472aab5f7feea1df93ec830fe5ec642c93c1046dec955df361bfdc3ab74477f847a1b72e8735ef65a8a6d1680745c0152bfb5cbb2a4b4671491a253a1a09d5a07d55f4872c9f0a3d25e07b257926629d5bb96aed96f5debab02503eb0ac45033323cc5a46c8e5d4469ee9f3dd618a20d54d6f5740c010fe5a0fe853efeb253a6df196bd24469ac51c1be8ba84737cecdb5ab73d7c52570d2273621fb69bd7ed985bbc6999dbd2d6fd2687ae44a391d604ff232cc6b3fbedd5d1cd0cd8c658c5d56069b5a5099cc5c9f48bbf7d7e83b4f9a7bdef6eabd164c8395468f818e8cd8c1c800bc3adfd66dbcb247d1bda5a7af38c288c0beb8e0d9160bf67500094530a0f8be52e97b5c2114f5a4a333a11c7f37f4c47a437422455d8cbcfa770cdc85ec55accf48cf14550b07f1346a02fccdf280fcb24c1fb38751d889a17e\"\n              },\n              {\n                \"commit\": \"08de9e42d361cabd99e566c67f7f8599c7e6985cd285a841277f1aeb89ad6c8fe3\",\n                \"features\": \"Plain\",\n                \"proof\": \"5eb7afa00e9681e3b6425fb4256c96905303505787d6a065e88a50154410b9a371b0f879d3f97cfa00425e9c8266e180188656acdbb46cacfdfb159fb135c5eb03b08be3c231c4b21df777da2e2afe8d30db91e602dc4ceed71aeb1b45a0266cfeadc4acbf9fdf7a67f67408fbbea7bf14182bc407373d243c6875373b655695604deb575369a9b28274885601b338882219c7f508aa2a0ae1d02736af2249327145f1d3d00093f9587f0e0b408692700fac0f2a048c329e81cabaa4b997dd88923fe97420125f394e21b4835e36cce9de383d9e223df1b5a6ba6f48ffeac315991189dc2716cc7ec07f6ccc8062344d5ed4fcaddf9070f44f0c59ffe8160d1f6fdfe42b40066f51e687d38b6b5255771800ac060bd8034cd68d14eee1b2f43b6d7bf20d71549ea9a50006dd30b9a795e785385801546eb9a83721a09fc34d3b69d4ccdc0ff0fb74d224048aeb66ecff5515296cadd57f42e0717cbba7c70719a10c007db4520e868efe98a51001b67952d7bda3174195a3d76b93ee4dac60137a38b2e8309cad13ef1cfb6c467f1969385e5b334b52f4fd55da440e036d2a428e9f3be905d79f717c169060468acc6d469636fed098b1aba5cd055a120314bcab55d5b8b6889321edf373517e93ef67fbe74557ec6c0211265efefa25a34ac267cf1db891c47163bfed20d2b535abfe60390c2844dcef5f0aad5fa7f1db9f726d7f223c025861069603936a22377707cdd3915e762e7061132124c716212b0e91bb7fc5d7816366f5d169d93fe75669a6ba19057bb2450958aa6f5ada09042570f46215af5a41b623d140be574b7a8c9ab24ea48da416dbe6ec0fa3b889206fb804df8d69805ceb80f1e9d4e8b664b3939491cba946d87585c830e3dab0638fa279b5e911642f18452e2731764aa62f92bbcf194c97f344c90c1931fd2c3af4bcf6b0\"\n              }\n            ]\n          },\n          \"offset\": \"0eb2c2669ce918675c72697891e5527bd13da5a499396381409219b8bbbd8129\"\n        },\n        \"tx_at\": \"2019-10-07T16:20:08.709114Z\"\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"grin-rfcs/text/0007-node-api-v2/#push_transaction","title":"push_transaction","text":"<p>Push new transaction to our local transaction pool. Optional fluff boolean to bypass Dandelion relay (false by default).</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"push_transaction\",\n    \"params\": [ {\n      \"body\": {\n            \"inputs\": [\n              {\n                \"commit\": \"0904cbd34d0745eb00ffc3e95c9f4746738794d00268e243e9b57163a73b384102\",\n                \"features\": \"Coinbase\"\n              }\n            ],\n            \"kernels\": [\n              {\n                \"excess\": \"08385257d22f1b8a758903f78ae12545245d620cffc50e7ee7bc852c5815513dc7\",\n                \"excess_sig\": \"e001a7349fd40d4a9dfc1df275d30906fb3b304f8c7892a20ed5c9b10923c871cbabedcf322511a9ce56f10113b48855441f681280133e121b25ea1ff7efad9e\",\n                \"features\": {\n                  \"Plain\": {\n                    \"fee\": 8000000\n                  }\n                }\n              }\n            ],\n            \"outputs\": [\n              {\n                \"commit\": \"087c3ca7419751e96cdae4908bb8a92fc2826f2ad36690420b905d51beb7409ca0\",\n                \"features\": \"Plain\",\n                \"proof\": \"379ae236937883c2e1e613fb30f1b18d2a44d4173360e94bcd07862aafaf81b3aaa1154d67287cc03efde0d3981c6da8a18e2e426f5c30afc0f2e3a75012448402d8d56df52b87f4815575a56d4da174f8187e4faae64bf883b249ceed694271f84ef62a3711d36c997dff7a11111419011e36e3a070b7552415a55faaa3999f99439edccdfe5313277147fdb42be1798442bb225c2b546f5347920584b365aa81a0365b4a706c97c89617b0e6218d2c9bc15805caab27c438ed06340cc4f8dc7bfca0e9d38864c88bb0c834372f6b662b9159134f3f8ec9b8a87878739a7e516b97419ac29e1d4a2b250321470a9a6b98d07065bb7e79afc25a5ab6fc47108f53223078a64502bd4af1a109641447dab82741ebe3fbdbd803ee7a42fe2554e78fa86bd1d1e6e3b913118e9419b0be6f976b2404447d943b5f1bac19a5809fd6834797945a62d21b1ecb6ddebbc5ef94ca9e704d033bd64afde67bd3e06e2cca3bb10190188afc0af80b48dd862b86753d8b4af314763324deb1c97cf020cb87285a47cd28874bb91c6cdf858965e8b9daafbcbc1b4817d334a97d7e25e01b2d072d8dcc6418e3dc7b8e7712632f939238e65ed0731c7af02d55a8884cd8f7f88dc0f63a21955a7364562532f5716c89e14f8f23ad78f6fe2f1649e13ea8f8185f3ee63cc174684d1ef8d8c33fb25bc802f8e05e53fe200b1ea5231f588a020942e6fd7eec67301700088dae8816c16a337120063c21e1604e009df932032812f88be6473af13f802b42d8ad6fc14230fbe13ede178319a7b6540656234ec1f2fcfa70f6faa9c4b6b8150b81fe0fdc273a9bb385d766a02041a5c3f58471d42059c17d84d13ad592aa0ccf337970e7eef06f306b13288795123c9c005b815d848f359b23450656b310f09cda9ad4b7b6931805d47dcd10a8745d834a984e2055168ac3\"\n              },\n              {\n                \"commit\": \"09a7b2c1d4b346c4ebe9c6c979e32e7740446624d5439d9d7abb82166c2545e5be\",\n                \"features\": \"Plain\",\n                \"proof\": \"5fb0ee4093a153e2ed173207dbfa02b4d185f1f313ea4cbf222558819074543f19e9bcdb595a23d4ee971aafcc614b6d2774e22cee6627bc4388297fe6ebf03e0d422f3eb8003cc8516417a6b32eb22f87e1745e0ae5bf1733f2ea253399719b1ef0067934dc548c58729604d24a44040165b32d05e82c9efc9a1f30151dd73ce893ae94709ec2fe5d0f409bb54a86604f0e92915b4f93e7adde823eccf87830ae91d71a7b99967dbcc8531fee44c20c24fb6fe2a34fe86ba5da3a9235cbcdcde033ead57d65c03903a9c9ed877bf0fab9f26d08552c64ea668d5408c84b74bc3ac8335aaaa04ebcf523d36d2207fb8770e976b6fde7d04e2148de5a4169c60b1958bb840b79a8c8f356e1f1fadc35a5a7e276fcd67c354cde546548c9bf788981f38edf5a406977826aa4524004e770b3d3cd6b26f0dc99729ffd9929fa4509b145ef0c3e4293e71b964da731a47cc9f082350acf32afb64b3b12f8383c8f2cc9880131a80ea957b2908c92f21d2db7aa5d67bafb11eb07674e52b920e67a86259dd9c5dcdd18bad182fd85ec4b659c47ea2e2e8a89c57e4d2cde87958fc2ab932e169f6805d2fb14549ac93807bc426eb4cf6d29ff6a4cf22e35dbb27f04211b06b65173501c17a3bb3ff0eecc9bb05dca23379abe457ca3010ebea69e1a2f7f3ed6531bf766007cdd1ac7d6c762785fb56f36194cc2ccaee76a499a7383288e84981b103d76cbe007f66c913eacb277746e78ae08627b279ac1f9a43ab284d8a3b32c6edcd2ea99e8ea836b31a1e2582be6c41f2282cf5fc7bdb95e4b412a5eeccad29670197873a888a100c4b2704ce75137fc997a5632d81001f9b57300a9bf99edd857065be83f835e4c49d852165ba18e1c96316c153459a913773d5d86ddc26c5cd1fff38a8fbb62506b0aef6076382674c0fa95a50a03b0c3df0a688a2cbf\"\n              }\n            ]\n          },\n          \"offset\": \"0ec14d3875ad5a366418256fe65bad2a4d4ff1914e1b9488db72dd355138ca3a\"\n        },\n        true\n    ],\n    \"id\": 1\n}\n{\n  \"id\": 1,\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"Ok\": null\n  }\n}\n</code></pre>"},{"location":"grin-rfcs/text/0007-node-api-v2/#errors","title":"Errors","text":"<p>There is two kind of errors that can appear when making a call on the API v2: basic JSON-RPC errors and API result errors</p>"},{"location":"grin-rfcs/text/0007-node-api-v2/#json-rpc-errors","title":"JSON-RPC Errors","text":"<p>These errors are often due to a miscontructed JSON body. For example when there is not enough parameters:</p> <pre><code>{\n  \"error\": {\n    \"code\": -32602,\n    \"message\": \"WrongNumberOfArgs. Expected 4. Actual 5\"\n  },\n  \"id\": 1,\n  \"jsonrpc\": \"2.0\"\n}\n</code></pre> <p>or invalid type of data entered:</p> <pre><code>{\n  \"error\": {\n    \"code\": -32602,\n    \"message\": \"InvalidArgStructure \\\"start_height\\\" at position 1.\"\n  },\n  \"id\": 1,\n  \"jsonrpc\": \"2.0\"\n}\n</code></pre> <p>or method not found:</p> <pre><code>{\n  \"error\": {\n    \"code\": -32601,\n    \"message\": \"Method not found\"\n  },\n  \"id\": 2,\n  \"jsonrpc\": \"2.0\"\n}\n</code></pre> <p>this list of errors is not exhaustive, for more information about the possible error objects see the JSON RPC 2.0 specifications.</p>"},{"location":"grin-rfcs/text/0007-node-api-v2/#api-result-errors","title":"API Result Errors","text":"<p>These type of errors are due to an API error during the query. This type of error is wrapped into the result. The possible error objects are defined in the <code>grin_api</code> crate</p> <p>For example, trying to ban a peer that's already banned:</p> <pre><code>{\n  \"id\": 2,\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"Err\": {\n      \"Internal\": \"ban peer error: PeerNotFound\"\n    }\n  }\n}\n</code></pre> <p>or a block that doesn't exist:</p> <pre><code>{\n  \"id\": 2,\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"Err\": \"NotFound\"\n  }\n}\n</code></pre>"},{"location":"grin-rfcs/text/0007-node-api-v2/#authentication","title":"Authentication","text":"<p>Like the v1 API, the v2 API uses basic auth. However, the foreign and owner API do not share the same secret. - The Owner API use the same token as the V1 Rest API, usually defined in <code>.grin/main/.api_secret</code>. - The Foreign API use its own token, usually defined in <code>.grin/main/.foreign_api_secret</code>.</p>"},{"location":"grin-rfcs/text/0007-node-api-v2/#wallet-support","title":"Wallet support","text":"<p>For full compatibility, grin-wallet will migrate to use the v2 Node API.</p>"},{"location":"grin-rfcs/text/0007-node-api-v2/#legacy-support","title":"Legacy support","text":"<p>The v1 API will remain active for a time the mode of operation for its REST API will be assumed to work as currently. This setup should allow existing wallets and apps to continue working as-is until a cutoff release for legacy mode is determined.</p>"},{"location":"grin-rfcs/text/0007-node-api-v2/#api-only","title":"API only","text":"<p>Note that this RFC doe not make user-facing changes to the existing CLI (invoked by <code>grin client</code>) to invoke these functions. It's expected that the existing cli functionality will be modified to invoke the new API functions.</p>"},{"location":"grin-rfcs/text/0007-node-api-v2/#node-v1-deprecation-timeline","title":"Node V1 Deprecation Timeline","text":"<ul> <li>v3.0.0 (January 2020): Node API v1 is marked as deprecated and will be remove in next major version.</li> <li>v4.0.0 (July 2020): Node API v1 is removed from the code.</li> </ul>"},{"location":"grin-rfcs/text/0007-node-api-v2/#drawbacks","title":"Drawbacks","text":"<p>This RFC temporarily introduces some additional code complexity as v1 and v2 node API will need to coexist for the duration of the deprecation period of v1.</p>"},{"location":"grin-rfcs/text/0007-node-api-v2/#prior-art","title":"Prior art","text":"<p>This kind of JSON-RPC API is widely used for cryptocurrencies. For instance:</p> <ul> <li>Bitcoin</li> <li>Ethereum</li> <li>Monero</li> <li>Tezos</li> </ul>"},{"location":"grin-rfcs/text/0007-node-api-v2/#future-possibilities","title":"Future possibilities","text":"<p>This API simplifies the deployment of new methods and drastically simplifies the work of developers by providing a clear documentation directly on docs.rs.</p>"},{"location":"grin-rfcs/text/0007-node-api-v2/#references","title":"References","text":"<ul> <li>JSON-RPC 2.0 Specification</li> <li>Bitcoin JSON-RPC Doc</li> <li>Ethereum JSON-RPC Doc</li> <li>Monero JSON-RPC Doc</li> <li>Tezos JSON-RPC Doc</li> </ul>"},{"location":"grin-rfcs/text/0008-wallet-state-management/","title":"0008 wallet-state-management","text":"<ul> <li>Title: improved-wallet-state-management</li> <li>Authors: Michael Cordner</li> <li>Start date: Nov 4th, 2019</li> <li>RFC PR: mimblewimble/grin-rfcs#30</li> <li>Tracking issue: mimblewimble/grin-wallet#244</li> </ul>"},{"location":"grin-rfcs/text/0008-wallet-state-management/#summary","title":"Summary","text":"<p>The changes outlined in the RFC are intended to make process of updating a wallet's state from the chain more consistent for developers and more transparent to the end user.</p> <p>This includes the following changes:</p> <ul> <li>The wallet's update process is modified to be more consistent and encapsulated.</li> <li>The <code>check-repair</code> process is run periodically as part of normal wallet update operations</li> <li>The ability for the wallet to run the update process on a separate thread is added.</li> <li>A TTL (Time-to-Live) field is added to the slate</li> <li>The default output selection method is set to <code>smallest</code></li> </ul>"},{"location":"grin-rfcs/text/0008-wallet-state-management/#motivation","title":"Motivation","text":"<p>Grin wallet previously updated the state of its outputs and transactions using a combination of UTXO updates, Kernel Lookups and UTXO set scanning. These 'primitives' on their own are generally enough to keep wallet states consistent, however the manner in which they were previously invoked was less than ideal and relied heavily on manually invoking the <code>check-repair</code> process and <code>cancel</code> command.</p> <p>To rectify this situation, this RFC outlines enhancements made to the wallet update process that have the goal of ensuring wallets are always in a consistent state in a manner that is transparent to the user. After adopting these changes, most wallets should automatically keep themselves in sync with the chain in all cases, and users will not usually have to invoke the <code>check-repair</code> or <code>cancel</code> commands.</p>"},{"location":"grin-rfcs/text/0008-wallet-state-management/#community-level-explanation","title":"Community-level explanation","text":"<p>While these changes should be transparent to end users, wallet developers should note the changes to how the wallet updates itself via these processes. Special attention should be paid to the new update thread API functions, as well as the new TTL field and default selection strategy change.</p>"},{"location":"grin-rfcs/text/0008-wallet-state-management/#reference-level-explanation","title":"Reference-level explanation","text":""},{"location":"grin-rfcs/text/0008-wallet-state-management/#wallet-update-procedures","title":"Wallet Update Procedures","text":"<p>The following sections outlines the processes used in the creation and update of outputs and related transactions within the wallet.</p>"},{"location":"grin-rfcs/text/0008-wallet-state-management/#transaction-and-output-creation","title":"Transaction and Output Creation","text":""},{"location":"grin-rfcs/text/0008-wallet-state-management/#coinbase-output-transaction-creation","title":"Coinbase Output + Transaction Creation","text":"<p>Coinbase outputs and their related transactions are created via the wallet listener as part of the mining process. The workflow is:</p> <ul> <li>When mining, create a potential coinbase output for the target block.</li> <li>If the block is accepted and the output is detected in the UTXO set (via the Update by Output process, create a transaction log entry of type 'Confirmed Coinbase', with 'confirmed' set to true.</li> </ul>"},{"location":"grin-rfcs/text/0008-wallet-state-management/#transacting-payer-payee-output-transaction-creation","title":"Transacting (Payer -&gt; Payee) Output + Transaction Creation","text":"<p>Outputs and tranasctions are created during the transaction exchange process as follows. Note that the invoicing workflow is mostly identical with the roles of Payer and Payee reversed, so this workflow is not outlined separately.</p> <ul> <li>The sender creates a new 'blank' transaction Slate, adding inputs and change outputs to the slate.</li> <li>The sender generates a random kernel offset. (The kernel offset is always generated by the slate creator)</li> <li>The sender sends the slate to the payee (via file or http). If sending synchronously, (e.g. via http)  the associated transaction is saved to the log after a response from the payee's listener. If sending asynchronously, (e.g. via file), the transaction is saved immediately.</li> <li>When saved, the associated transaction is set to type 'Sent Tx' with a status of 'unconfirmed', inputs are locked internally and a change output is added with status 'unconfirmed'.</li> <li>The payee receives the slate, creates (an) output(s) for the received amount with status unconfirmed, and immediately stores a transaction in their log of type 'Received Tx' with confirmed set to false.</li> <li>The payee calculates and saves the transaction kernel commitment for later reference.</li> <li>The slate is returned to the payer for completion, who calculates and saves the transaction kernel. The transaction is sent to a node for validation.</li> </ul>"},{"location":"grin-rfcs/text/0008-wallet-state-management/#transaction-and-output-statue-update-processes","title":"Transaction and Output Statue Update Processes","text":""},{"location":"grin-rfcs/text/0008-wallet-state-management/#update-by-output-process","title":"Update by Output Process","text":"<p>The Update by Output Process is the main method by which the wallet updates its internal state, decides whether a transaction has been confirmed and when to remove or confirm individual outputs. This process works as follows:</p> <ul> <li>For every unspent output in the wallet:</li> <li>If the output's status in the user's wallet is 'unconfirmed' and it is present in the UTXO set, change the output's status to 'confirmed', and update the associated transaction status to 'confirmed'.</li> <li>If the output's status in the user's wallet is 'confirmed' and it no longer appears in the UTXO set, set its status to 'Spent'. Note these outputs will usually be locked so they cannot be selected for spending again.</li> </ul>"},{"location":"grin-rfcs/text/0008-wallet-state-management/#kernel-lookup-process","title":"Kernel Lookup Process","text":"<p>It is also possible to look up a transaction via the kernel that was stored when the transaction and outputs were created. This is necessary in cases such as where a participant in a transaction doesn't have any change outputs, which means the output update process won't detect when to mark a transaction confirmed. This process is:</p> <ul> <li>Retrieve the transaction kernel from the node using the kernel excess value calculated during the transaction creation process.</li> <li>If the kernel exists, update the status of the associated transaction to 'Confirmed'</li> </ul>"},{"location":"grin-rfcs/text/0008-wallet-state-management/#check-repair-process","title":"Check-Repair Process","text":"<p>The Update by Output process on its own is not enough to ensure the contents of a wallet is correct. There are many easily-encountered situations in the course of a wallet's operation where this process is insufficient and can potentially lead to an wallet state that's inconsistent with the UTXO set, including but not limited to:</p> <ul> <li>Manually cancelling transactions and unlocking outputs before they've had a chance to confirm on the chain.</li> <li>Running multiple wallets from the same seed</li> <li>Fork situations</li> </ul> <p>The check-repair process fixes most of these potential issues by scanning every single output in the UTXO set and testing for ownership by determining if its bullet proof can be decoded using the wallet's master key. It will then 'check and repair' all outputs and transactions in the wallet as follows:</p> <ul> <li>If an output exists in the UTXO set and is not in the wallet, create an output for the wallet at the derivation path stored in the bullet proof, and create a new transaction crediting the amount</li> <li>If an output exists in the UTXO set and is marked as 'spent', mark it as unspent and cancel any associated transaction log entries.</li> </ul> <p>Additionally, the check-repair process can take a flag instructing it to delete unconfirmed outputs and reset all outstanding transactions. If this flag is set:</p> <ul> <li>If a locked output exists in the UTXO set, unlock it and set any associated transactions to <code>cancelled</code></li> <li>If an 'unconfirmed' output is not in the UTXO set, delete it and cancel any associated transaction log entries.</li> </ul> <p>Note that the wallet <code>restore</code> process works very similarly to the check-repair process, however it must always operate on an empty wallet meaning it is limited to creating outputs and transactions in the wallet.</p>"},{"location":"grin-rfcs/text/0008-wallet-state-management/#previous-overall-update-process","title":"Previous Overall Update Process","text":"<p>All of the procedures outlined above can be considered set of 'primitives' available for the wallet to keep itself updated. The previous update process was somewhat limited, and had the tendency to require a significant amount of manual updating using the <code>check-repair</code> command. The previous process was as follows:</p> <ul> <li>Invoke the 'Update by Output' process before retrieving any info relating to the wallet state (<code>txs</code>, <code>info</code> or <code>outputs</code> commands,) or creating a new transaction. This invocation is usually done internally and in a syncronous blocking manner by each command that requires the wallet state to be as up to date as possible.</li> <li>During the <code>txs</code> retrieval command, for each unconfirmed transaction with an <code>amount recieved</code> field set to 0, invoke the 'Kernel Lookup' process.</li> <li>If the user suspects the wallet state to be inconsistent with the node's UTXO state, the user can run the manual <code>check-repair</code> command. This will scan all UTXOs in the set from position 1 in the output PMMR. The user can optionally provide a flag to remove all unconfirmed transactions.</li> <li>If a transaction and associated outputs appear 'stuck' or 'locked' due to the other party not completing a transaction, the user must manually cancel the transactions and unlock the outputs for re-use. (or provide the <code>cancel-unconfirmed</code> flag to the check-repair process)</li> <li>The default selection strategy is to 'sweep' the wallet of outputs on each transaction creation, meaning that by default, no further transaction can usually be made while a transaction is outstanding.</li> </ul>"},{"location":"grin-rfcs/text/0008-wallet-state-management/#changes-to-overall-update-process-and-procedures","title":"Changes to Overall Update Process and Procedures","text":"<p>While a combination of the 'primitives' listed above should be enough to keep a wallet's state consistent with a node's UTXO set, the previous method of invoking the vital <code>check-repair</code> command was a manual step that had to be run on the entire UTXO set each time. The overall update process is modified to incorporate the previous <code>check-repair</code> logic as part of normal operation. To ensure a wallet is only scanning the part of the UTXO set required, the wallet stores details on what parts of the UTXO set it has already scanned, and performs incremental scans as part of normal update operation.</p>"},{"location":"grin-rfcs/text/0008-wallet-state-management/#check-repair-is-renamed-to-scan","title":"<code>check-repair</code> is renamed to <code>scan</code>","text":"<p>The naming of the previous <code>check-repair</code> command and functionality implied something had gone wrong, whereas it really should be considered a necessary part of normal wallet operation. It is therefore renamed to a more friendly-sounding <code>scan</code> process.</p>"},{"location":"grin-rfcs/text/0008-wallet-state-management/#overall-update-process","title":"Overall Update Process","text":"<p>The Overall Update process is outlined as follows:</p> <ul> <li>Perform the 'Update by Output' process.</li> <li>Perform the 'Kernel Update' process for transactions where the incoming amount is 0.</li> <li>Query the wallet's internal data for the last block height scanned via the <code>scan</code> process.</li> <li>If the stored block's header hash doesn't match the version currently on the node's UTXO set, scan the range of the UTXO set corresponding to the last stored block - 100 blocks up until the current block.</li> <li>If the stored block's header matches the version on the chain, scan a range of the UTXO set corresponding to the stored block height to the current block height.</li> <li>Save the last block scanned by the <code>scan</code> process.</li> </ul>"},{"location":"grin-rfcs/text/0008-wallet-state-management/#new-recovered-wallets","title":"New / Recovered Wallets","text":"<p>Newly created and recovered wallets scan the UTXO set as follows:</p> <ul> <li>New wallets generated with a new random seed will mark themselves as <code>new</code>, and set their <code>last scanned block</code> to the block height reported on first successful contact with a node.</li> <li>Wallets recovered with an existing mnemonic will set the <code>last scanned block</code> to <code>1</code>, triggering the <code>scan</code> process and thereby restoring any associated outputs.</li> <li>The <code>restore</code> command will be removed in favor of the <code>scan</code> process.</li> </ul>"},{"location":"grin-rfcs/text/0008-wallet-state-management/#manual-scans","title":"Manual Scans","text":"<p>It is still be possible to manually scan the chain via the <code>scan</code> (<code>check</code>) command, however the command is modified to allow the user to specify a range of block heights to scan. If this is not provided, the scan occurs from the current block - 1 week's worth of blocks.</p>"},{"location":"grin-rfcs/text/0008-wallet-state-management/#invocation-of-update-process","title":"Invocation of Update Process","text":"<p>The update process was previously run inline in a synchronous blocking fashion as part of individual wallet commands. With the <code>scan</code> command becoming part of normal operations, it's expected that a particular invocation of the overall update process could potentially take a long time. This is acceptable in single-use modes such as the single invocation model of <code>grin-wallet</code>, but is far less usable in environments where the wallet and Owner API stay resident and the caller may not have any particular insight as to why a call invoking the update process might be taking a long time to complete.</p> <p>To address this, the wallet provides a method of calling the Overall Update Process in its own thread that attempts to minimise its usage of the wallet lock. The Wallet's Owner API (V3 Only) is extended with the following functions:</p> <ul> <li><code>start_update_thread(interval)</code> =&gt; Starts the update thread, calling the Overall Update Process at the frequency specified</li> <li><code>stop_update_thread()</code> =&gt; Stops the update thread</li> <li><code>get_update_status()</code> =&gt; Returns the current status of the update thread, along with as much information as possible about what the thread is doing and, in the case of the <code>scan</code> process, the percentage complete.</li> </ul> <p>Further, if the update thread is currently running, commands that previously always called the Overall Update Process (such as <code>info</code>, <code>txs</code>, etc...) do not call the update process. This means that when invoked via the command line, the behaviour is unchanged. However, wallets running the Owner API can instead choose to run and monitor the background update thread at the desired frequency while keeping the user informed of any long-running update processes.</p>"},{"location":"grin-rfcs/text/0008-wallet-state-management/#transaction-ttl","title":"Transaction TTL","text":"<p>The Update process outlined above does not cover the case where a slate is exchanged and outputs are locked, but one party doesn't complete the transaction for whatever reason.</p> <p>Previously, a situation such as this meant that the outputs associated with a transaction sat locked indefinitely within a user's wallet, with the only way to unlock them a manual <code>cancel</code> command (or a <code>check-repair</code> with the <code>delete-unconfirmed</code> flag set). Worse, the wallet's default selection strategy was set to <code>all</code> meaning an entire wallet's contents usually became locked on each transaction, and thus a single uncompleted transaction would render a user's entire wallet balance unspendable.</p> <p>To rectify these problems, the following changes are made:</p> <ul> <li>A Time-To-Live (<code>TTL</code>) field is added to the Slate, which is defined as the last block height at which a wallet should attempt to complete a transaction. This field should be respected at the wallet-exchange level, but is not currently commit to at a consensus level. If a wallet detects a particular transaction's TTL has expired, it will automatically cancel the transaction and unlock associated outputs. Note this doesn't prevent the other party sending the transaction to the node after this happens, but there is no guarantee the outputs will still be available. However, if this does happen the <code>scan</code> command will correct the wallet state.</li> <li>The default output selection method is changed to <code>smallest</code>, to prevent all wallet amounts being locked on every transaction. The <code>smallest</code> strategy prefers using the smallest (or 'dust') outputs as inputs to a transaction, and it is conjectured that the overall effect on Grin's UTXO size will be negligible in the longer term, provided users continue to transact. The <code>all</code> method of output selection also has privacy implications in that it makes it easier for an observer to identify a group of outputs as belonging to a single wallet (or indeed, representing the entire contents of a wallet in most cases).</li> </ul>"},{"location":"grin-rfcs/text/0008-wallet-state-management/#unresolved-questions","title":"Unresolved questions","text":"<ul> <li>Do we limit the Kernel Lookup part of the process to just cases where there is no change output. Is there any benefit to calling it for all outstanding transactions on each lookup (or any particular downside to doing so?)</li> <li>What is the effect on UTXO set size of changing the selection method to <code>smallest</code>?</li> <li>Confirm sensible defaults for how far to scan back on a <code>scan</code></li> </ul>"},{"location":"grin-rfcs/text/0009-enable-faster-sync/","title":"0009 enable-faster-sync","text":"<ul> <li>Title: enable-faster-sync</li> <li>Authors: Antioch Peverell, John Tromp</li> <li>Start date: Oct 25, 2019</li> <li>RFC PR: mimblewimble/grin-rfcs#29</li> <li>Tracking issue: mimblewimble/grin#3173</li> </ul>"},{"location":"grin-rfcs/text/0009-enable-faster-sync/#summary","title":"Summary","text":"<p>This RFC introduces changes that reduce the time it takes for a node joining the Grin network to fully sync. Data can be downloaded in batches and partially verified without the bottleneck of waiting to receive all data. These batches can be requested from multiple peers in parallel and verified as they are received. This improves the performance and the robustness of the \"fast sync\" process and allows for futher improvements to be explored in the future. A consensus change is required to facilitate this, with a change to what we commit to in each block header. We propose making this consensus change as part of the upcoming scheduled hardfork (HF2 scheduled for Jan 2020).</p>"},{"location":"grin-rfcs/text/0009-enable-faster-sync/#motivation","title":"Motivation","text":"<p>The initial sync process involves downloading all kernels, all unspent outputs and their corresponding rangeproofs. The unspent outputs are maintained in a \"Prunable Merkle Mountain Range\" (PMMR). Briefly, this consists of unpruned output data, a set of intermediate hashes representing pruned subtrees and a \"leafset\" bitmap representing the position of unpruned, unspent outputs in the PMMR.</p> <p>The previous implementation packaged all of the above data into a single zip file, requested and received from a single peer. This was both a performance bottleneck and a single point of failure. To increase reliability and performance we split this data up into smaller chunks and request from multiple peers.</p> <p>It was previously only possible to validate the full set of unspent outputs. We were unable to validate a partial set of outputs as we compared the total output sum to the total kernel sum plus the total kernel offset. By design, there is no partial kernel sum to compare against a partial output sum.</p> <p>This RFC describes how we split the output PMMR into subtrees, requesting these subtrees along with the corresponding bitmap fragment and the necessary Merkle proofs. Each output subtree can be verified with its corresponding bitmap fragment. By committing to the leafset bitmap in addition to the output PMMR we can verify the output subtrees.</p> <p>The final \"sum to zero\" validation remains unchanged but the partial verification of the individual output subtrees allows for more granular, and earlier verification of the data as it is received.</p>"},{"location":"grin-rfcs/text/0009-enable-faster-sync/#community-level-explanation","title":"Community-level explanation","text":"<p>Validation of full transaction history is not necessary when joining the Grin network and access to full block history is not required. The initial sync process involves downloading all block headers, all kernels, all unspent outputs and their corresponding rangeproofs. Historical spent outputs are not necessary for validation. Nodes prune historical spent outputs, with a few days of recent history retained. Kernels are not pruned and must be retained indefinitely.</p> <p>The unspent outputs are maintained in a \"Prunable Merkle Mountain Range\" (PMMR). Briefly, this consists of unpruned output data, a set of intermediate hashes representing pruned subtrees and a \"leafset\" bitmap representing the position of unpruned, unspent outputs in the PMMR. Subtrees of the output PMMR are requested from peers and these subtrees are verified together with the corresponding fragment of the leafset bitmap. Merkle proofs are provided to prove inclusion of both the output subtree and bitmap fragments beneath the root committed to in the block header. Once all subtrees are received and verified, the unspent outputs are summed together and checked against the sum of all kernels plus the kernel offset from the block header.</p> <p>This allows us to download outputs from multiple peers, in parallel and verify them as they are received. The node does not need to wait for the full output PMMR to be received before validation can begin.</p>"},{"location":"grin-rfcs/text/0009-enable-faster-sync/#reference-level-explanation","title":"Reference-level explanation","text":"<p>The leafset bitmap is committed to by splitting the bitmap into smaller fragments, adding these fragments to an MMR and committing to the root of the bitmap MMR.</p> <p>The leafset bitmap represents leaf positions, in insertion order, of the underlying output PMMR. The output PMMR is append-only and the order of these outputs does not change. The first (leftmost) bit in the bitmap maps directly to the first output inserted into the output PMMR. The next bit in the bitmap maps to the second output inserted into the output PMMR etc. The bitmap <code>11100010</code> represents outputs <code>[0, 1, 2, 6]</code> in the PMMR. The bitmap is then split into smaller fragments of 1024 bits, representing contiguous sequences of bits of the bitmap. The two fragments <code>0000...0001, 1000...0000</code> represent outputs <code>[1023, 1024]</code> in the output PMMR. Every fragment is exactly 1024 bits in length with the final fragment padded with <code>0</code> values to fill the full 1024 bits.</p> <p>The bitmap MMR itself is not append-only as fragments of the bitmap will be updated over time as outputs are spent. Recent outputs are more likely to be spent than old output, resulting in updates clustering around the most recent (rightmost) fragments in the MMR. This has the nice property of minimizing the amount of updating and rehashing necessary to keep the bitmap MMR updated over time as older fragments will change only rarely.</p> <p>Merkle proofs can be provided for both a subtree of the output PMMR and a fragment in the bitmap MMR. These are used during validation to locate the output subtree in the overall output PMMR and to verify the bitmap fragment corresponds to the same output positions.</p> <p>To commit to the root of both the output PMMR and the root of the bitmap MMR we hash the roots together and commit to this single composite root <code>H(output_root|bitmap_root)</code> in the the block header. This allows us to reuse the existing <code>output_root</code> field on the header to commit to both MMR roots.</p>"},{"location":"grin-rfcs/text/0009-enable-faster-sync/#drawbacks","title":"Drawbacks","text":"<p>These changes necessitate a change to the data committed to in the block header. This is a consensus breaking change and comes with all risks and complexity inherent to any consensus breaking change. As block headers are retained indefinitely the implementation will need to maintain compatibility for headers pre and post hardfork indefinitely.</p>"},{"location":"grin-rfcs/text/0009-enable-faster-sync/#rationale-and-alternatives","title":"Rationale and alternatives","text":"<p>We believe we cannot make the desired changes to fast sync without committing to the leafset bitmap. The previous approach of implicitly validating this as part of the overall \"sum to zero\" kernel validation does not allow for a batched approach. The previous approach was by design \"all or nothing\" with validation only possible once we have downloaded the full set of kernels and unspent outputs.</p> <p>The details are around precisely how to commit to this bitmap and there are various alternatives possible here. The leafset bitmap is implemented as a \"roaring bitmap\" internally but we want to commit to a canonical representation of this data. The obvious choice here is the uncompressed bitmap data itself. We could simply hash the full bitmap but this is not efficient as we would need to rehash all the data for every block header. The other extreme would be to treat each individual bit in the bitmap as a leaf of a Merkle tree. This would also be inefficent as we would require a 32 byte hash for every individual bit. The proposed solution is to break the bitmap up into smaller chunks and add these chunks as leaves of an MMR. Recent outputs are more likely to be spent than older outputs and bitmap chunks to the right of the MMR are more likely to change over time. These rightmost chunks have shorter paths to the associated peak in the MMR with correspondingly shorter Merkle proofs. The cost of updating more recent fragments is also minimized as the number of rehashing operations up to the peak is small.</p> <p>The proposal is to break the bitmap up into 1024 bit (128 byte) chunks and use these as leaves in the bitmap MMR.</p> <p>The other question is what data to add to the header itself. We propose combining the bitmap root and the output MMR root into a single <code>output_root</code> hash on the block header. This changes the semantics of the existing <code>output_root</code> field. This solutiuon has the advantage of maintaining the existing header serialization. No new header field would be necessary. An alternative solution would be to keep the two MMR roots separate and to introduce the new bitmap root as a new header field. The would affect serialization at both the p2p layer and the local database and would add significant complexity to the implementation.</p> <p>The two roots are closely related and we propose committing to them together as a single combined hash.</p>"},{"location":"grin-rfcs/text/0009-enable-faster-sync/#references","title":"References","text":"<ul> <li>Merkle Mountain Range (OpenTimestamps)</li> <li>Prunable Merkle Mountain Ranges (Grin)</li> </ul>"},{"location":"grin-rfcs/text/0010-online-transacting-via-tor/","title":"0010 online-transacting-via-tor","text":"<ul> <li>Title: online-transacting-via-tor</li> <li>Authors: David Burkett</li> <li>Start date: September 1, 2019</li> <li>RFC PR: mimblewimble/grin-rfcs#24</li> <li>Tracking issue: mimblewimble/grin-wallet#280</li> </ul>"},{"location":"grin-rfcs/text/0010-online-transacting-via-tor/#retired","title":"RETIRED","text":"<p>This RFC has been retired and has been superseded by RFC#0015: slatepack.</p>"},{"location":"grin-rfcs/text/0010-online-transacting-via-tor/#summary","title":"Summary","text":"<p>Describes a standardized addressing and communication protocol for building Grin transactions.</p> <p>Wallets will attempt to connect to the recipient directly to build transactions over a TOR hidden service similar to how http(s) transaction building works today.</p> <p>This RFC does not cover the offline transacting problem.</p>"},{"location":"grin-rfcs/text/0010-online-transacting-via-tor/#motivation","title":"Motivation","text":"<p>Grin is unique in that it requires the sender and receiver to interact in order to transact. This presents a lot of unique challenges that most coins don\u2019t have to deal with. There are a number of different incompatible standards for sending and receiving, resulting in confusion and headaches for many users. The hope is that the addressing mechanism described here will become the new default method for sending and receiving, deprecating several less secure and less private methods in the process.</p>"},{"location":"grin-rfcs/text/0010-online-transacting-via-tor/#community-level-explanation","title":"Community-level explanation","text":"<p>From an end-user perspective, there should no longer be a need to configure routers and firewalls to receive grins. Sending and receiving should feel like any other cryptocurrency, where a simple encoded address is all you need to share before receiving. No firewall or router configuration should be necessary.</p>"},{"location":"grin-rfcs/text/0010-online-transacting-via-tor/#reference-level-explanation","title":"Reference-level explanation","text":""},{"location":"grin-rfcs/text/0010-online-transacting-via-tor/#addressing","title":"Addressing","text":"<p>Onion addresses for TOR hidden services are generated from an ed25519 public key (32 bytes), and include a checksum and a version[1]. This provides an equivalent level of security as bitcoin addresses, and can be ephemeral or permanent, depending on the user\u2019s needs. Grin addresses should be generated and base32 encoded in the same way as TOR v3 addresses.</p> <p>Although ed25519 is a different curve than used by the grin protocol, we can still use our HD wallets to generate deterministic ed25519 public keys (and therefore Grin addresses). For account <code>m/0</code>, addresses will be generated using keychain paths <code>m/0/1/x</code>, for account <code>m/1</code>, addresses will be generated using <code>m/1/1/x</code>, etc. To generate addresses for a keychain path, we derive the private key in the usual way, but then blake2b hash the derived key to get the ed25519 secret key, which can then be used to calculate the public key and address.</p>"},{"location":"grin-rfcs/text/0010-online-transacting-via-tor/#tor-hidden-services","title":"TOR Hidden Services","text":"<p>TOR hidden services can be used to directly serve the existing foreign APIs. When configuring TOR (whether bundled with grin, or installed separately), you would just publish a hidden service and configure TOR to forward all traffic to port 3420. This means we can continue supporting http(s) sending/receiving with no disruption, though it\u2019s advisable to avoid sending directly over http(s) asap.In future versions of Grin, we can stop allowing non-local connections to the foreign wallet APIs.</p>"},{"location":"grin-rfcs/text/0010-online-transacting-via-tor/#drawbacks","title":"Drawbacks","text":"<p>Requires users to setup TOR, or bundle it with Grin, which could be non-trivial, and could conflict with locally installed/running versions.</p>"},{"location":"grin-rfcs/text/0010-online-transacting-via-tor/#unresolved-questions","title":"Unresolved questions","text":"<ul> <li>How often should addresses change? Should users manually request a new address, or should they auto expire? Should we support multiple?</li> </ul>"},{"location":"grin-rfcs/text/0010-online-transacting-via-tor/#future-possibilities","title":"Future possibilities","text":"<p>The changes in this RFC lead the way for: * Payment proofs * Offline transacting via SBBS/Grinbox-style relay system. See 0000-asynchronous-transacting-via-relays RFC</p>"},{"location":"grin-rfcs/text/0010-online-transacting-via-tor/#references","title":"References","text":"<ul> <li>[1] https://github.com/torproject/torspec/blob/87698dc1c0fa4cf2186f180a636fc7ad1c5fb5fd/rend-spec-v3.txt#L2059-L2081</li> <li>[2] https://github.com/mimblewimble/grin/blob/d918c5fe84e859290c9d09f5cfc167ed41d27bff/keychain/src/extkey_bip32.rs#L122</li> </ul>"},{"location":"grin-rfcs/text/0011-security-team/","title":"0011 security-team","text":"<ul> <li>Title: security-team</li> <li>Authors: joltz</li> <li>Start date: Jan 22, 2020</li> <li>RFC PR: mimblewimble/grin-rfcs#39</li> <li>Tracking issue: mimblewimble/grin-pm/#258</li> </ul>"},{"location":"grin-rfcs/text/0011-security-team/#summary","title":"Summary","text":"<p>The security team for Grin carries out the security priorities of the Grin community and core team, which are to be defined prior to formation of the team. The security team streamlines the security decision making process for the core team while maintaining a careful balance of security and transparency for the community.</p>"},{"location":"grin-rfcs/text/0011-security-team/#motivation","title":"Motivation","text":"<ul> <li>Improve transparency, efficiency, decisiveness and scalability around security-related decision making</li> <li>Dedicated support for security-related initiatives such as bilateral disclosure agreements, bug bounty programs and audit work</li> <li>Increase confidence in the ecosystem for future contributions</li> </ul> <p>A clear and structured decision making process is needed to fully support the current security process as well as community initiatives such as bilateral disclosure agreements, bug bounty programs and future audit work. This process was previously maintained by the core team who had many areas of focus, leading to a lack of clarity, timeliness and ability to decisively execute on community security initiatives.</p> <p>The security team frees up core resources to focus on other important areas while expanding dedicated resources to security work, allowing the Grin ecosystem to continue to scale. A clear decision making structure around the security process instills confidence in the greater ecosystem and encourages projects, developers and users to continue to increase contributions of time and resources into Grin.</p>"},{"location":"grin-rfcs/text/0011-security-team/#community-level-explanation","title":"Community-level explanation","text":"<p>Grin's security team is responsible for making predefined security related decisions for the Grin project. This includes, but is not limited to, decisions about the specification and implementation of Grin's security processes. As much as possible Grin's security team carries out the security priorities of the community and core team in a transparent manner.</p> <p>There may be some unique security-related cases that require the security team to make some decisions in private to protect the security of Grin users. In these cases, once it is safe to do so, the security team is responsible for sharing as many details as possible with the community for transparency and accountability purposes.</p> <p>The primary day-to-day impact this will have on the community is making available structured support around security-related initiatives such as bilateral disclosure agreements, bug bounty programs and audit work. The community and other teams will have regular opportunity to interact with, provide input to and receive input from the security team.</p>"},{"location":"grin-rfcs/text/0011-security-team/#example","title":"Example","text":"<p>Here we will walk through an example case that highlights how Grin's security team would operate, contrasting with the current process.</p> <p>In the example case, a vulnerability is disclosed to the disclosure contacts listed in Grin's security policy. It is shown that the community gains greater transparency into the decision making process and related outcomes with the proposed security team. Additionally the disclosure map is more tightly contained in the proposed process, resulting in less risk of vulnerability exploitation to the community.</p>"},{"location":"grin-rfcs/text/0011-security-team/#previous-process","title":"Previous Process","text":"<ul> <li>Grin's security contacts make initial assessment of the validity of the vulnerability disclosure</li> <li>If disclosure determined to be valid, all details of the disclosure are shared with the entire core team</li> <li>With a conversation between the entire core team, a plan of action is determined and executed, following Grin's responsible disclosure policy</li> <li>Once the vulnerability is mitigated the core team may optionally share some of the details with the community</li> </ul>"},{"location":"grin-rfcs/text/0011-security-team/#security-team-process","title":"Security Team Process","text":"<ul> <li>Grin's security contacts, all members of the security team, make initial assessment of the validity of the vulnerability disclosure</li> <li>If disclosure determined to be valid, a conversation and plan of action is determined and executed by the security team, following Grin's responsible disclosure policy</li> <li>Once the vulnerability is mitigated the security team must disclose all information that is not still security-critical with the community</li> </ul>"},{"location":"grin-rfcs/text/0011-security-team/#reference-level-explanation","title":"Reference-level explanation","text":"<p>Grin's security team will be implemented as stated below.</p>"},{"location":"grin-rfcs/text/0011-security-team/#membership","title":"Membership","text":"<ul> <li>Bootstrapped by existing security contacts (@lehnberg, @hashmap, @joltz)</li> <li>Minimum three, maximum five members</li> <li>Membership is recommended by the security team and approved by the core team</li> <li>All members must have relevant domain expertise in security, cryptography, the Grin codebase or Grin community</li> <li>All members must have high competency in maintaining personal operational security (keeping private keys secure, maintaining secure communications channels etc.)</li> <li>Membership is revoked by failure to update the canary, unanimous decision by team or decision from the core team</li> <li>Note if the core team engages in removing members from the security team without reasonable justification, the security team loses purpose, becomes ineffective and is relegated to useless security theater</li> </ul>"},{"location":"grin-rfcs/text/0011-security-team/#decision-making","title":"Decision Making","text":"<ul> <li>Distinction between security-team decisions and security-related decisions:</li> <li>The security team is responsible for making predefined security-team decisions, not all possible ambiguous security-related decisions</li> <li>Decisions are made primarily with consideration to the security priorities outlined prior to the team's formation</li> <li>Unanimous approval of security team members is needed to make all impactful decisions</li> <li>Some decisions made must also be approved by the core team to be carried out:</li> <li>Adding/removing parties from disclosure agreements</li> <li>Adding members to the security team</li> <li>Updating the security policy</li> <li>In the event that the core team does not follow a security team recommendation, a reasonable explanation must be provided as to why the security recommendation was not followed</li> <li>Some decisions must be made without fully informing the core team of all details:</li> <li>When fixing a vulnerability requires a deviation from the standard<ul> <li>In these cases not all information will be shared with core team, such as specific details to carry out an exploit, full impact and other relevant information that will create unnecessary risk if disclosed</li> </ul> </li> <li>The core team must be notified of all cases of these decisions within a reasonable time frame that does not pose a security risk (e.g. after a fix is implemented) and provided with a reasonable explanation by the security team</li> </ul>"},{"location":"grin-rfcs/text/0011-security-team/#vetoes","title":"Vetoes","text":"<ul> <li>Any member of the security team may veto an impactful security team decision</li> </ul> <p>The ability to veto an impactful security team decision is important to preserve the ability for members of the security team to make honest recommendations. Important and controversial decisions will be made and members of the security team need the ability to not sign their names to a decision they are not comfortable with that could have serious ramifications. These cases will be handled according to the Deadlocks section below.</p> <p>The security team should always strive to reach its own decisions. Constant vetoes and inability to reach unanimous decisions will dampen the advantages of the existence of the team and may render it obsolete. It is important to strike the right balance of different perspectives, expertise and reasonability in members to take advantage of the benefits that come with a diverse and functional security-related decision making process.</p>"},{"location":"grin-rfcs/text/0011-security-team/#deadlocks","title":"Deadlocks","text":"<ul> <li>Impactful security team decisions that can't be made unanimously by the security team will be made by the core team according to their decision making process</li> <li>If the core team is deadlocked, the decision made will be whichever decision, if any, will provide the end user with the greatest measure of security</li> </ul> <p>Deadlocks should be avoided at all costs. The inability of the security team to reach a unanimous decision based on the security priorities of Grin's community and core team should be a red flag to the community and core team for the health of the team. All members should be able to clearly discuss the factual merits of the options and reach a decision that is in the clear best possible interest for the security of Grin's ecosystem and users.</p>"},{"location":"grin-rfcs/text/0011-security-team/#example_1","title":"Example","text":"<p>By following the previous example in more detail, critical differences can be further explored between the current process and the proposed security team process in the handling of a unique case.</p> <p>In cases where fixing a vulnerability is so critical that it requires a deviation from the standard, the proposed process reduces the likelihood of the vulnerability being exploited with a focused decision making process and by restricting the details to essential persons only.</p>"},{"location":"grin-rfcs/text/0011-security-team/#previous-process_1","title":"Previous Process","text":"<ul> <li>Grin's security contacts make initial assessment of the validity of the vulnerability disclosure</li> <li>It is determined that the disclosed vulnerability is a critical inflation bug</li> <li>All details of the disclosure, including the steps to carry out the exploit, are shared with the entire core team</li> <li>With a conversation between the entire core team, a plan of action is determined and executed, following Grin's responsible disclosure policy</li> <li>This conversation may take days or weeks as there is no particular decision making process for security-related issues</li> <li>Once the vulnerability is mitigated the core team may optionally share some of the details with the community</li> </ul>"},{"location":"grin-rfcs/text/0011-security-team/#security-team-process_1","title":"Security Team Process","text":"<ul> <li>Grin's security contacts, all members of the security team, make initial assessment of the validity of the vulnerability disclosure</li> <li>It is determined that the disclosed vulnerability is a critical inflation bug</li> <li>A conversation and plan of action is quickly and unanimously determined and executed on by the security team, following Grin's responsible disclosure policy</li> <li>Once the vulnerability is mitigated, the security team must disclose all information that is not still security-critical with the community</li> </ul>"},{"location":"grin-rfcs/text/0011-security-team/#drawbacks","title":"Drawbacks","text":"<ul> <li>The core team is already busy and the formation and management of a security team may distract from other pressing and immediate issues</li> <li>Even though it decentralizes the core team, it potentially creates another point of centralization</li> <li>Adds resource overhead to the project that must be upheld (it is not acceptable to fail to follow through in security processes once established!)</li> <li>Possibly distracts from other important work- we don't want to spread attention too wide too early</li> <li>Adds bulk to Grin's governance structure</li> <li>The community may trust core more than a team to make critical security decisions</li> </ul>"},{"location":"grin-rfcs/text/0011-security-team/#rationale-and-alternatives","title":"Rationale and alternatives","text":"<ul> <li>One alternative, currently in use, is adding the input of a security expert to the existing core decision making process</li> <li>This is better than nothing but we lose a few benefits without a dedicated security team:<ul> <li>Strengthened security process: reduced likelihood of exploit leaks</li> <li>Improved transparency: there is currently little transparency around core's security decision making process</li> <li>Improved reaction times: informed, thoughtful, decisive actions with input from relevant experts only</li> <li>Possibility for security initiatives: clear decision making process for bilateral disclosure agreements, bug bounty programs, audit work</li> <li>Stronger commitments to the community, ecosystem and other projects: viable with a dedicated, clear decision making process</li> <li>Long-term scalability: extend capacity for security work to grow beyond the core team's attention capacity</li> </ul> </li> <li>Another alternative is to rely on an open community to handle all incidents as they come in</li> <li>This is less desirable than both the previous process and security team process:<ul> <li>Vulnerabilities would essentially be public before they can by mitigated</li> <li>There is no decision making team so mitigation actions may be slow and contentious</li> <li>There is no accountability to ensure that the responsible disclosure process is followed</li> <li>This model is much more transparent than other alternatives but comes with the unacceptable associated costs above</li> </ul> </li> </ul>"},{"location":"grin-rfcs/text/0011-security-team/#prior-art","title":"Prior art","text":"<p>grin-governance[0] and security-process[1] RFCs lay groundwork for the security-team RFC.</p>"},{"location":"grin-rfcs/text/0011-security-team/#unresolved-questions","title":"Unresolved questions","text":"<ul> <li>What are the security priorities of the Grin community and core team? (e.g. is privacy a higher priority than undetectable inflation?)</li> <li>Is this the most minimal model that can have long-term success for Grin's security-related decision making process?</li> <li>Is the single-veto model sufficient for a consistent, timely decision making process?</li> </ul>"},{"location":"grin-rfcs/text/0011-security-team/#future-possibilities","title":"Future possibilities","text":"<ul> <li>Budget allocation and management</li> <li> <p>Manage an allocated budget for possible initiatives</p> <ul> <li>Bug bounty programs</li> <li>Audits</li> <li>Full time contributors</li> <li>Development of security tooling</li> </ul> </li> <li> <p>Security team working groups</p> </li> <li>Red team</li> <li>Blue team</li> <li>Audit team</li> <li>Bug bounty team</li> <li> <p>Community outreach team</p> </li> <li> <p>Expanding security-team decisions</p> </li> <li>Currently security-team decisions are restricted to predefined decisions around the security processes</li> <li>In the future security-team decisions can be expanded to include more security-related decisions</li> </ul>"},{"location":"grin-rfcs/text/0011-security-team/#references","title":"References","text":"<ul> <li>[0] 0002 grin-governance RFC (#teams)</li> <li>[1] 0003 security-process RFC</li> </ul>"},{"location":"grin-rfcs/text/0012-compact-slates/","title":"0012 compact-slates","text":"<ul> <li>Title: Slate V4 (Compact Slates)</li> <li>Authors: Michael Cordner</li> <li>Start date: April 3, 2020</li> <li>RFC PR: mimblewimble/grin-rfcs#49</li> <li>Tracking issue: mimblewimble/grin-wallet#317</li> </ul>"},{"location":"grin-rfcs/text/0012-compact-slates/#summary","title":"Summary","text":"<p>This RFC describes the changes between version 3 and version 4 of the Slate transaction exchange format, which had the goal of reducing the contents of the Slate to be as minimal as possible.</p>"},{"location":"grin-rfcs/text/0012-compact-slates/#motivation","title":"Motivation","text":"<p>Previously, the definition of Slate versions up to V3 had been put together with no regard for its size or/and redundant/irrelevant content. In order to facilitate future exchange method possibilities, it's desirable to ensure the Slate is as compact as possible, particularly on the 'first leg' of a transaction exchange which only actually requires minimal information from the transaction initiator.</p> <p>This RFC aims to define the contents of a streamlined \"compact\" slate by:</p> <ul> <li>Removing all redundant or unnecessary Slate fields</li> <li>Shortening the names of many Slate fields</li> <li>Reducing the size of the Slate to at all phases of a transaction</li> <li>Defining an optional highly-minimized binary format for Slate output</li> </ul> <p>Although this RFC doesn't address any particular transaction exchange methods that might be facilitated by this streamlining, one could envisage possibilities such as:</p> <ul> <li>An exchange placing the entire initial slate in a QR code</li> <li>Encoding the initial slate as an easily-cut-and-paste chunk</li> </ul>"},{"location":"grin-rfcs/text/0012-compact-slates/#community-level-explanation","title":"Community-level explanation","text":"<p>There are two basic transaction workflows in a two-party Grin transaction:</p> <ul> <li> <p>In the Basic workflow, a sender adds their inputs and change outputs to a transaction, and sends them, along with the fee, the amount and their signature data to the recipient. The recipient adds a output for the amount to the transaction, adds their signature data and returns to the sender, who completes the transaction and posts.</p> </li> <li> <p>In the Invoice workflow, the invoice creator adds a new output to a transaction, and sends the amount and signature data to the payer. The payer adds their inputs and change outputs to the transaction along with their signature data and fee information, then returns to the invoicer, who completes the transaction and posts.</p> </li> </ul> <p>Although previous versions of the Slate included every party's complete inputs and outputs at every stage of the transaction, it is not technically necessary for the initiator to provide their inputs and outputs to the other party. It suffices for the initiator to store the input/output listing in their local transaction context, and only provide the amount, fee, excess and signature data to the other party. Recognising this, it is possible to ensure that the 'first-leg' of a transaction stage is extremely compact.</p> <p>For instance, version 3 of the Slate on transaction initiation may have looked something like the following:</p> <pre><code>{\n  \"version_info\": {\n    \"version\": 3,\n    \"orig_version\": 3,\n    \"block_header_version\": 2\n  },\n  \"num_participants\": 2,\n  \"id\": \"0436430c-2b02-624c-2032-570501212b00\",\n  \"tx\": {\n    \"offset\": \"d202964900000000d302964900000000d402964900000000d502964900000000\",\n    \"body\": {\n      \"inputs\": [\n        {\n          \"features\": \"Coinbase\",\n          \"commit\": \"087df32304c5d4ae8b2af0bc31e700019d722910ef87dd4eec3197b80b207e3045\"\n        },\n        {\n          \"features\": \"Coinbase\",\n          \"commit\": \"08e1da9e6dc4d6e808a718b2f110a991dd775d65ce5ae408a4e1f002a4961aa9e7\"\n        }\n      ],\n      \"outputs\": [\n        {\n          \"features\": \"Plain\",\n          \"commit\": \"0812276cc788e6870612296d926cba9f0e7b9810670710b5a6e6f1ba006d395774\",\n          \"proof\": \"dcff6175390c602bfa92c2ffd1a9b2d84dcc9ea941f6f317bdd0f875244ef23e696fd17c71df79760ce5ce1a96aab1d15dd057358dc835e972febeb86d50ccec0dad7cfe0246d742eb753cf7b88c045d15bc7123f8cf7155647ccf663fca92a83c9a65d0ed756ea7ebffd2cac90c380a102ed9caaa355d175ed0bf58d3ac2f5e909d6c447dfc6b605e04925c2b17c33ebd1908c965a5541ea5d2ed45a0958e6402f89d7a56df1992e036d836e74017e73ccad5cb3a82b8e139e309792a31b15f3ffd72ed033253428c156c2b9799458a25c1da65b719780a22de7fe7f437ae2fccd22cf7ea357ab5aa66a5ef7d71fb0dc64aa0b5761f68278062bb39bb296c787e4cabc5e2a2933a416ce1c9a9696160386449c437e9120f7bb26e5b0e74d1f2e7d5bcd7aafb2a92b87d1548f1f911fb06af7bd6cc13cee29f7c9cb79021aed18186272af0e9d189ec107c81a8a3aeb4782b0d950e4881aa51b776bb6844b25bce97035b48a9bdb2aea3608687bcdd479d4fa998b5a839ff88558e4a29dff0ed13b55900abb5d439b70793d902ae9ad34587b18c919f6b875c91d14deeb1c373f5e76570d59a6549758f655f1128a54f162dfe8868e1587028e26ad91e528c5ae7ee9335fa58fb59022b5de29d80f0764a9917390d46db899acc6a5b416e25ecc9dccb7153646addcc81cadb5f0078febc7e05d7735aba494f39ef05697bbcc9b47b2ccc79595d75fc13c80678b5e237edce58d731f34c05b1ddcaa649acf2d865bbbc3ceda10508bcdd29d0496744644bf1c3516f6687dfeef5649c7dff90627d642739a59d91a8d1d0c4dc55d74a949e1074427664b467992c9e0f7d3af9d6ea79513e8946ddc0d356bac49878e64e6a95b0a30214214faf2ce317fa622ff3266b32a816e10a18e6d789a5da1f23e67b4f970a68a7bcd9e18825ee274b0483896a40\"\n        }\n      ],\n      \"kernels\": [\n        {\n          \"features\": \"Plain\",\n          \"fee\": \"7000000\",\n          \"lock_height\": \"0\",\n          \"excess\": \"000000000000000000000000000000000000000000000000000000000000000000\",\n          \"excess_sig\": \"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n        }\n      ]\n    }\n  },\n  \"amount\": \"60000000000\",\n  \"fee\": \"7000000\",\n  \"height\": \"5\",\n  \"lock_height\": \"0\",\n  \"ttl_cutoff_height\": null,\n  \"payment_proof\": null,\n  \"participant_data\": [\n    {\n      \"id\": \"0\",\n      \"public_blind_excess\": \"033ac2158fa0077f087de60c19d8e431753baa5b63b6e1477f05a2a6e7190d4592\",\n      \"public_nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\",\n      \"part_sig\": null,\n      \"message\": null,\n      \"message_sig\": null\n    }\n  ]\n}\n</code></pre> <p>In version 4 of the Slate format, the initial Slate now looks like the following:</p> <pre><code>{\n  \"ver\": \"4:2\"\n  \"id\": \"0436430c-2b02-624c-2032-570501212b00\",\n  \"sta\": \"S1\",\n  \"off\": \"d202964900000000d302964900000000d402964900000000d502964900000000\",\n  \"amt\": \"6000000000\",\n  \"fee\": \"8000000\",\n  \"sigs\": [\n    {\n      \"xs\": \"023878ce845727f3a4ec76ca3f3db4b38a2d05d636b8c3632108b857fed63c96de\"\n      \"nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\",\n    }\n  ],\n}\n</code></pre> <p>While a \"return\" slate might look something like the following:</p> <pre><code>{\n  \"ver\": \"4:3\",\n  \"id\": \"0436430c-2b02-624c-2032-570501212b00\",\n  \"sta\": \"S2\",\n  \"off\": \"a4052c9200000001a6052c9200000002ed564fab50b75fc5ea32ce052fc9bebf\",\n  \"sigs\": [\n    {\n      \"xs\": \"03b0d73a044f1f9ae06cf96ef91593f121864b66bf7f7e7ac481b0ce61e39847fe\",\n      \"nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\",\n      \"part\": \"8f07ddd5e9f5179cff19486034181ed76505baaad53e5d994064127b56c5841b54735cb9ed2f59fb457144f7b1c8226d08b54cbdd0eb7e6492950751b0bb54f9\"\n    }\n  ],\n  \"coms\": [\n    {\n      \"c\": \"091582c92b99943b57955e52b5ccf1223780c2a2e55995c00c86fca2bcb46b6b9f\",\n      \"p\": \"49972a8d5b7c088e7813c3988ebe0982f8f0b12b849b1788df7da07b549408b0d6c99f80c0e2335370c104225ef5d282d79966e9044c959bedc3be03af6246fa07fc13eb3c60c90213c9f3a7a5ecf9a34c8fbaddc1a72e49e12dba9495e5aaa53bb6ac6ed63d8774707c57ab604d6bdc46de18da57a731fe336c3ccef92b4dae967417ffdae2c7d75864d46d30e287dd9cc15882e15f296b9bab0040e4432f4024be33924f112dd26c90cc800ac09a327b0ac3a661f63da9945fb1bcc82a7777d61d97cbe657675e22d035d2cf9ea03a89cfa410960ebc18a0a18b1909f4c5bef20b0fd13ffcf5a818ad8768d354b1c0f2e9b16dd7a9cf0641546f57d1945a98b8684d067dd085b90b40457e4c14665fb1b94feecf30a90f508ded16ba1bba8080a6866dffd0b1f01738fff8c62ce5e38e677835752a1b4072124dd9ff14ba8ff92126baebbb5f6e14fbb052f5d5b09aec11bfd880d7d4640a295aa83f184034d26f00cbdbabf9b89fddd7a7c9cc8c5d4b53fc39971e4495a8d984ac9607be89780fde528ee3f2d6b912908b4caf04f5c93f64431517af6b32d0b9c18255959f6903c6696ec71f615a0c877630a2d871f3f8a107fc80f306a94b6ad5790070f7d2535163bad7feae9263a9d3558ea1acecc4e61ff4e05b0162f6aba1a3b299ff1c3bb85e4109e550ad870c328bedc45fed8b504f679bc3c1a25b2b65ede44602f21fac123ba7c5f132e7c786bf9420a27bae4d2559cf7779e77f96b747b6d3ad5c13b5e8c9b49a7083001b2f98bcf242d4644537bb5a3b5b41764812a93395b7ab372c18be575e02c3763b4170234e5fddeb43420aadb71cb80f75cc681c1e7ffee3e6a8868c6076fd1da539ab9a12fef1c8cbe271b6de60100c9f82d826dc97b47b57ee9804e60112f556c1dce4f12ecc91ef34d69090b8c9d2ae9cbae38994a955cb\"\n    }\n  ]\n}\n</code></pre> <p>The 'return' slate from the recipient to the originator is expected to be larger, as it must include the recipient's outputs/inputs and proofs (as the party who posts the transaction needs all of this information). However, compacting the slate at each stage of its journey allows for future possibilities that may have been more difficult in previous iterations of the slate format. For instance, an initiator taking Grin payments might be expected to be better equipped to receive Grin transactions. They could present the payer with an invoice transaction for the amount compacted to the size of a QR code, which the payer could scan, accept, and then post back to the invoicer's listening wallet infrastructure.</p> <p>Compacting the slate also acts as a minor privacy-enhancer by hiding the initiator's outputs from the other party.</p>"},{"location":"grin-rfcs/text/0012-compact-slates/#reference-level-explanation","title":"Reference-level explanation","text":""},{"location":"grin-rfcs/text/0012-compact-slates/#slate-definition-json","title":"Slate Definition - JSON","text":"<p>Entries prefixed with <code>//</code> denote fields that may be omitted, as well as their default assumed values. <code>#</code> denotes a comment for the purposes of illustration.</p> <p>Field ordering is canonical.</p> <pre><code>{\n# These fields are always present\n  \"ver\": \"4:3\",\n  \"id\": \"0436430c-2b02-624c-2032-570501212b00\",\n  \"sta\": \"S1\",\n  \"off\": \"d202964900000000d302964900000000d402964900000000d502964900000000\",\n\n# These fields may or may not be present\n//\"num_parts: 2,\n//\"fee\": \"8000000\",\n//\"amt\": \"1000000000\",\n//\"feat\": 0,\n//\"ttl\": null,\n\n# Sigs is always present with at least one entry\n  \"sigs\": [\n    {\n      \"xs\": \"03b0d73a044f1f9ae06cf96ef91593f121864b66bf7f7e7ac481b0ce61e39847fe\",\n//    \"part\": null,\n      \"nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\",\n    }\n  ]\n\n# These structs may or may not be present\n\n//\"coms\": null,\n//\"proof\": null,\n//\"feat_args\": null\n}\n</code></pre> <p>A description of all fields and their meanings is as follows:</p>"},{"location":"grin-rfcs/text/0012-compact-slates/#top-level-slate-struct","title":"Top-Level Slate Struct","text":""},{"location":"grin-rfcs/text/0012-compact-slates/#fields-always-present","title":"Fields - Always present","text":"<ul> <li><code>ver</code> - The slate version and supported block header version, separated by a <code>:</code></li> <li><code>id</code> - The slate's UUID, standard hex-string encoding for UUIDs</li> <li><code>sta</code> - 2 character String representing the current stage of the the transaction. See Status Codes</li> <li><code>off</code> - The running transaction offset total, hex-string encoded. All parties select a random offset at the beginning of the transaction and subtract their offset from the excess value of their outputs. They then subtract the value of the inputs from the offset when committing to inputs, updating the total offset before sending to the next stage.</li> </ul>"},{"location":"grin-rfcs/text/0012-compact-slates/#fields-optional-depending-on-state-and-transaction-options","title":"Fields - Optional, depending on State and transaction options","text":"<ul> <li><code>num_parts</code> - The number of participants in the transaction, assumed to be 2 if omitted</li> <li><code>amt</code> - The transaction amount as a string parseable as a u64. May be omitted on a return journey.</li> <li><code>fee</code> - The transaction fee as a string parseable as a u64. May be omitted on a return journey, except during an invoice transaction.</li> <li><code>feat</code> - Kernel Features ID. If omitted, kernel is assumed to be Plain (0). If set to 1 or otherwise, any arguments required for a particular kernel feature set will be found in the <code>feat_args</code> struct.</li> <li><code>ttl</code> - Time to Live, or block height beyond which wallets should refuse to further process the transaction. Assumed 0 (no ttl) if omitted from the slate.</li> </ul>"},{"location":"grin-rfcs/text/0012-compact-slates/#structs-always-present","title":"Structs - Always present","text":"<ul> <li><code>sigs</code> - An array of signature data containing the signature information of the last participant. See Signature Data</li> </ul>"},{"location":"grin-rfcs/text/0012-compact-slates/#structs-optional-depending-on-state-of-transaction","title":"Structs - Optional, depending on state of transaction","text":"<ul> <li><code>proof</code> - An optional payment proof request. See Payment Proof Data</li> <li><code>coms</code> - The Transaction; is removed from the slate in favour of including this top-level Slate field that can be used to reconstruction the transaction object as expected by the Grin node. See Transaction Object Fields</li> <li><code>feat_args</code> - Optional arguments for Kernel features.</li> </ul>"},{"location":"grin-rfcs/text/0012-compact-slates/#status-codes","title":"Status Codes","text":"<p>Valid values of the <code>sta</code> field and their meanings are:</p> <ul> <li><code>S1</code> - Standard (payer to payee) transaction flow, new transaction that incorporates the sender's inputs and change output(s), if any. Sender's signature nonce, excess (with kernel offset) is included and ready for sending to recipient.</li> <li><code>S2</code> - Standard transaction flow, recipient has created their outputs(s) and supplied their excess, nonce and partial signature, ready to return to recipient for completion.</li> <li><code>S3</code> - Standard transaction flow, Slate complete, contains all inputs, outputs and final signatures, and is ready for posting</li> <li><code>I1</code> - Invoice (payee to payer) transaction flow, new transaction that incorporates the Invoicer's output(s). Invoicer's signature nonce and excess (with kernel offset) is included and ready for sending to Invoicee.</li> <li><code>I2</code> - Invoice workflow, Invoicee has added their inputs and change output(s).  Invoicee's signature, nonce and excess is included and ready for sending back to the invoicer.</li> <li><code>I3</code> - Invoice workflow, Slate complete, contains all inputs, outputs and final signatures, and is ready for posting</li> </ul>"},{"location":"grin-rfcs/text/0012-compact-slates/#signature-data","title":"Signature Data","text":"<p>An entry in the <code>sigs</code> array is as follows:</p> <pre><code>{\n   \"xs\": \"03b0d73a044f1f9ae06cf96ef91593f121864b66bf7f7e7ac481b0ce61e39847fe\",\n   \"part\": null,\n   \"nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\",\n}\n</code></pre> <p>The <code>sigs</code> struct contains is comprised of an array of participant signature data, with each entry comprising:    * <code>xs</code> - Hex string encoded short form public key on the secp256k1 curve representing the public blind excess for the participants outputs subtracted from each party's part of the offset.    * <code>part</code> - Hex string encoded Aggregated (Schnorr) secp2561k signature represeting the participant's partial sig. May be omitted if the participant does not yet have enough data to create it    * <code>nonce</code> - Hex string encoded The public key of the nonce chosen by the participant for their partial signature</p> <p>The other party's <code>sig</code> entry is removed from the slate before sending it back to the transaction initiator during the S2 and I2 phases.</p>"},{"location":"grin-rfcs/text/0012-compact-slates/#payment-proof-data","title":"Payment Proof Data","text":"<p>If included, the proof structure is:</p> <pre><code>  \"proof\": {\n    \"saddr\": \"7e008eb593ba17d116e282d6267a3c6aad87b910933ad34dfa4d7d2c92b6ba31\",\n//  \"rsig\": null,\n    \"raddr\": \"3a425bd5da5f0f78593251ede7fad0ecf7a95679d84b2cb405255d97ce068234\"\n  }\n</code></pre> <p>The <code>proof</code> struct is an optional payment proof request that must be filled out by the recipient if requested (only valid for basic transaction flow). Its fields are as follows:</p> <ul> <li><code>saddr</code> - Hex string encoded short-form public key on the ed25519 curve, representing the sender's wallet address (see the payment proofs rfc for details.</li> <li><code>raddr</code> - Hex string encoded short-form public key on the ed25519 curve represnting the recipient's wallet address</li> <li><code>rsig</code> - Hex string encoded EdDSA ed25519 signature representing the recipient's payment-proof signature. Can be omitted if this has not yet been filled out</li> </ul>"},{"location":"grin-rfcs/text/0012-compact-slates/#transaction-object-fields","title":"Transaction Object Fields","text":"<p>The V4 Version of the Slate contains its own separate representation of Grin's internal Transaction object. (Grin's internal transaction struct definition can be found here: Transaction). Internally, the wallet will transform its representation into the format expected by the node while posting the transaction.</p> <p>The <code>tx</code> struct in a V4 Slate is removed, and is replaced instead by the following Top-Level fields. Wallets recreate the transaction object as expected by the Grin node from these fields before posting.</p> <ul> <li><code>coms</code> is an array containing the outputs and inputs that have been added to the slate. These will appear during the I1 or S2 phases of a transaction. Each entry includes:</li> <li><code>f</code>: The output features, assumed to be 'Plain' if omitted. 0 denotes Plain, 1 denotes Coinbase</li> <li><code>c</code>: The output/input commitment, hex string Encoded</li> <li><code>p</code>: The output's range proof, hex string Encoded. If this is included, the entry is assumed to be an output. If not, it is an input.</li> </ul> <p>When rebuilding the transaction kernel for the Node (done during the S3 or I3 phases,) the kernel is assumed to be 'Plain' unless the top-level <code>feat</code> field is non-zero. In this case, the kernel features are filled accordingly with any needed values from the <code>feat_args</code> struct.</p> <p>In a typical S3 phase, these fields may look something like:</p> <pre><code>  \"coms\": [\n    {\n      \"c\": \"091582c92b99943b57955e52b5ccf1223780c2a2e55995c00c86fca2bcb46b6b9f\",\n      \"p\": \"49972a8d5b7c088e7813c3988ebe0982f8f0b12b849b1788df7da07b549408b0d6c99f80c0e2335370c104225ef5d282d79966e9044c959bedc3be03af6246fa07fc13eb3c60c90213c9f3a7a5ecf9a34c8fbaddc1a72e49e12dba9495e5aaa53bb6ac6ed63d8774707c57ab604d6bdc46de18da57a731fe336c3ccef92b4dae967417ffdae2c7d75864d46d30e287dd9cc15882e15f296b9bab0040e4432f4024be33924f112dd26c90cc800ac09a327b0ac3a661f63da9945fb1bcc82a7777d61d97cbe657675e22d035d2cf9ea03a89cfa410960ebc18a0a18b1909f4c5bef20b0fd13ffcf5a818ad8768d354b1c0f2e9b16dd7a9cf0641546f57d1945a98b8684d067dd085b90b40457e4c14665fb1b94feecf30a90f508ded16ba1bba8080a6866dffd0b1f01738fff8c62ce5e38e677835752a1b4072124dd9ff14ba8ff92126baebbb5f6e14fbb052f5d5b09aec11bfd880d7d4640a295aa83f184034d26f00cbdbabf9b89fddd7a7c9cc8c5d4b53fc39971e4495a8d984ac9607be89780fde528ee3f2d6b912908b4caf04f5c93f64431517af6b32d0b9c18255959f6903c6696ec71f615a0c877630a2d871f3f8a107fc80f306a94b6ad5790070f7d2535163bad7feae9263a9d3558ea1acecc4e61ff4e05b0162f6aba1a3b299ff1c3bb85e4109e550ad870c328bedc45fed8b504f679bc3c1a25b2b65ede44602f21fac123ba7c5f132e7c786bf9420a27bae4d2559cf7779e77f96b747b6d3ad5c13b5e8c9b49a7083001b2f98bcf242d4644537bb5a3b5b41764812a93395b7ab372c18be575e02c3763b4170234e5fddeb43420aadb71cb80f75cc681c1e7ffee3e6a8868c6076fd1da539ab9a12fef1c8cbe271b6de60100c9f82d826dc97b47b57ee9804e60112f556c1dce4f12ecc91ef34d69090b8c9d2ae9cbae38994a955cb\"\n    },\n    {\n      \"c\": \"087df32304c5d4ae8b2af0bc31e700019d722910ef87dd4eec3197b80b207e3045\"\n    },\n    {\n      \"c\": \"08e1da9e6dc4d6e808a718b2f110a991dd775d65ce5ae408a4e1f002a4961aa9e7\"\n    }\n  ],\n</code></pre>"},{"location":"grin-rfcs/text/0012-compact-slates/#feature-arguments","title":"Feature arguments","text":"<p>Depending on the chosen Kernel Feature set, <code>feat_args</code> may be populated with arguments specific to the kernel. The exact arguments that will be present here depend on the value of <code>feat</code>. Currently, the only supported kernel is HeightLocked (value 1) which has the arguments:</p> <pre><code>\"feat_args\": {\n   \"lock_hgt\": \"2343234\" // For HeightLocked kernels (1)\n}\n</code></pre>"},{"location":"grin-rfcs/text/0012-compact-slates/#changes-from-existing-v3-slate","title":"Changes from existing V3 Slate","text":""},{"location":"grin-rfcs/text/0012-compact-slates/#top-level-slate-struct_1","title":"Top-Level Slate Struct","text":"<ul> <li>The <code>version_info</code> struct is removed, and is replaced with <code>ver</code>, which has the format \"[version]:[block header version]\"</li> <li><code>sta</code> is added, with possible values S1|S2|S3|I1|I2|I3|NA</li> <li><code>num_participants</code> is renamed to <code>num_parts</code></li> <li><code>num_parts</code> may be omitted from the slate. If omitted its value is assumed to be 2.</li> <li><code>amount</code> is renamed to <code>amt</code></li> <li><code>amt</code> may be removed from the slate on the S2 phase of a transaction.</li> <li><code>fee</code> may be removed from the slate on the S2 phase of a transaction. It may also be omitted when initiating an I1 transaction, and added during the I2 phase.</li> <li><code>lock_height</code> is removed</li> <li><code>feat</code> is added to the slate denoting the Kernel feature set. May be omitted from the slate if kernel is plain</li> <li><code>ttl_cutoff_height</code> is renamed to <code>ttl</code></li> <li><code>ttl</code> may be omitted from the slate. If omitted its value is assumed to be 0 (no TTL).</li> <li>The <code>participant_data</code> struct is renamed to <code>sigs</code></li> <li><code>tx</code> is removed</li> <li>The <code>coms</code> (commitments) array is added, from which the final transaction object can be reconstructed</li> <li>The <code>payment_proof</code> struct is renamed to <code>proof</code></li> <li>The <code>feat_args</code> struct is added, which may be populated for non-Plain kernels</li> <li><code>proof</code> may be omitted from the slate if it is None (null),</li> <li><code>offset</code> is added, which keeps track of the running offset total as it's modified by the participants</li> </ul>"},{"location":"grin-rfcs/text/0012-compact-slates/#participant-data-sigs","title":"Participant Data (<code>sigs</code>)","text":"<ul> <li><code>public_blind_excess</code> is renamed to <code>xs</code></li> <li><code>public_nonce</code> is renamed to <code>nonce</code></li> <li><code>part_sig</code> is renamed to <code>part</code></li> <li><code>part</code> may be omitted if it has not yet been filled out</li> <li><code>message</code> is removed</li> <li><code>message_sig</code> is removed</li> <li><code>id</code> is removed. Parties can identify themselves via the keys stored in their transaction context</li> </ul>"},{"location":"grin-rfcs/text/0012-compact-slates/#payment-proof-data-proof","title":"Payment Proof Data (<code>proof</code>)","text":"<ul> <li>The <code>sender_address</code> field is renamed to <code>saddr</code></li> <li>The <code>receiver_address</code> field is renamed to <code>raddr</code></li> <li>The <code>receiver_signature</code> field is renamed to <code>rsig</code></li> <li><code>rsig</code> may be omitted if it has not yet been filled out</li> </ul>"},{"location":"grin-rfcs/text/0012-compact-slates/#pretty-printing","title":"Pretty-Printing","text":"<p>The examples above are pretty-printed for reference, but all Slates should remove all whitespace before sending to other parties. The whitespace and formatting can be re-added anywhere the Slate needs to be presented for debugging.</p>"},{"location":"grin-rfcs/text/0012-compact-slates/#slate-definition-binary","title":"Slate Definition - Binary","text":"<p>While the JSON slate remains the first-order slate definition, and should be accepted by all wallets and APIs, wallets should also have the ability to transform slates between the JSON format and a reduced binary format suitable for armoring or direct transfer. The definition of the V4 binary slate format follows.</p> <p>All integer values are Big-Endian.</p> Slate V4 Field type len notes <code>ver.slate_version</code> u16 2 <code>ver.block_header_version</code> u16 2 <code>id</code> Uuid 16 binary Uuid representation <code>sta</code> u8 1 See Status Byte <code>offset</code> BlindingFactor 32 Optional field status u8 1 See Optional Field Status <code>num_parts</code> u8 (1) If present <code>amt</code> u64 (8) If present <code>fee</code> u64 (8) If present <code>feat</code> u8 (1) If present <code>ttl</code> u64 (8) If present <code>sigs</code> entries struct varies See Sigs Entries Optional struct status u8 1 See Optional Struct Status <code>coms</code> entries struct (varies) If present. See Coms Entries <code>proof</code> struct (varies) If present. See Proof <code>feat_args</code> entries struct (varies) If present. See Feature Args"},{"location":"grin-rfcs/text/0012-compact-slates/#status-byte","title":"Status Byte","text":"<p>Encodes slate status (<code>sta</code>) field, mapped as follows:</p> State value <code>NA</code> (Unknown) 0 <code>S1</code> 1 <code>S2</code> 2 <code>S3</code> 3 <code>I1</code> 4 <code>I2</code> 5 <code>I3</code> 6"},{"location":"grin-rfcs/text/0012-compact-slates/#optional-field-status","title":"Optional Field Status","text":"<p>A bit field that denotes the presence or absence of the optional slate fields. Each bit is mapped to particular slate field as follows:</p> Bit 7 6 5 4 3 2 1 0 field <code>ttl</code> <code>feat</code> <code>fee</code> <code>amt</code> <code>num_parts</code> <p>If the corresponding field for a bit is 1, the field is present and must be read accordingly.</p>"},{"location":"grin-rfcs/text/0012-compact-slates/#sigs-entries","title":"Sigs Entries","text":"<p>Sigs Entries contains a length-prefixed array of entries corresponding to the <code>sigs</code> struct.</p> Field type len notes length u8 1 entries struct varies array of entries, see below <p>Each Sigs Entry is structured as follows:</p> Field type len notes complete flag u8 1 If non-zero, entry contains <code>part</code> <code>xs</code> secp256k1 Public Key 33 <code>nonce</code> secp256k1 Public Key 33 <code>part</code> secp256k1 AggSig (64) If present"},{"location":"grin-rfcs/text/0012-compact-slates/#optional-struct-status","title":"Optional Struct Status","text":"<p>A bit field that denotes the presence or absence of the optional slate structures. Each bit is mapped to particular slate structure as follows:</p> Bit 7 6 5 4 3 2 1 0 struct <code>proof</code> <code>coms</code> <p>If the corresponding field for a struct is 1, the struct is present and must be read accordingly.</p>"},{"location":"grin-rfcs/text/0012-compact-slates/#coms-entries","title":"Coms Entries","text":"<p>Coms Entries contains a length-prefixed array of entries corresponding to the <code>coms</code> struct.</p> Field type len notes length u16 2 entries struct varies array of entries, see below <p>Each Coms Entry is structured as follows:</p> Field type len notes output flag u8 1 If non-zero, entry is output and contains <code>p</code> (proof) <code>f</code> u8 1 features (1 = Coinbase, 0 = Plain) <code>c</code> Commitment 33 <code>p</code> Rangeproof 675 If present"},{"location":"grin-rfcs/text/0012-compact-slates/#proof","title":"Proof","text":"<p>Optional Payment proof, with fields as follows</p> Proof Field type len notes <code>saddr</code> ed25519 Public Key 32 <code>raddr</code> ed25519 Public Key 32 rsig flag u8 1 If non-zero, <code>rsig</code> field is present <code>rsig</code> ed25519 EDCSA Sig (64) If present"},{"location":"grin-rfcs/text/0012-compact-slates/#feature-args","title":"Feature Args","text":"<p>Optional feature args, presence or absence of which should be determined by the value of the <code>feat</code> field. Currently only present if <code>feat</code> is 2.</p> Field type len notes <code>lock_hgt</code> u64 8 Lock height, present if <code>feat</code> is 2"},{"location":"grin-rfcs/text/0012-compact-slates/#unresolved-questions","title":"Unresolved questions","text":"<ul> <li>Is block header version needed?</li> <li>Nerd Kernels need to be included</li> </ul>"},{"location":"grin-rfcs/text/0012-compact-slates/#future-possibilities","title":"Future possibilities","text":"<p>This RFC is envisaged as a necessary first step for all slate-exchange possibilities that would benefit from compactness, e.g:</p> <ul> <li>Slatepack</li> <li>QR Code encoding of slates</li> <li>Armored slates</li> </ul>"},{"location":"grin-rfcs/text/0013-nrd-kernels/","title":"0013 nrd-kernels","text":"<ul> <li>Title: <code>nrd-kernels</code></li> <li>Authors: Antioch Peverell</li> <li>Start date: Mar 24, 2020</li> <li>RFC PR: Edit if merged: mimblewimble/grin-rfcs#47</li> <li>Tracking issue: mimblewimble/grin#3288</li> </ul>"},{"location":"grin-rfcs/text/0013-nrd-kernels/#summary","title":"Summary","text":"<p>Grin supports a limited implementation of \"relative timelocks\" with \"No Recent Duplicate\" (NRD) transaction kernels. Transactions can be constructed such that they share duplicate kernels. An NRD kernel instance is not valid within a specified number of blocks relative to a prior duplicate instance of the kernel. A minimum height difference must therefore exist between two instances of an NRD kernel. This provides the relative height lock between transactions.</p>"},{"location":"grin-rfcs/text/0013-nrd-kernels/#motivation","title":"Motivation","text":"<p>Relative timelocks are a prerequisite for robust payment channels. NRD kernels can be used to implement a revocable channel close mechanism. A mandatory revocation period can be introduced through a relative timelock between two transactions. Any attempt to close an old invalid channel state can be safely revoked during the revocation period.</p> <p>Recently, Ruben Somsen announced a design for Succinct Atomic Swaps (SAS) reducing the number of on-chain transactions required to implement the swap. This design uses a combination of relative locks and adaptor signatures. SAS would appear to be compatible with Grin/MW but with some caveats, namely the need for an additional transaction kernel as the NRD lock and the adaptor signature cannot co-exist on the same kernel. This is discussed in Unresolved questions below.</p>"},{"location":"grin-rfcs/text/0013-nrd-kernels/#community-level-explanation","title":"Community-level explanation","text":"<p>A minimum distance in block height is enforced between successive duplicate instances of a given NRD kernel. This can be used to enforce a relative lock height between two transactions. A transaction containing an NRD kernel will not be accepted as valid within the specified block height relative to any prior instance of the NRD kernel.</p> <p>Transactions can be constructed around an existing transaction kernel by introducing either an additional kernel or in some cases by simply adjusting the kernel offset. This allows NRD kernels to be used across any pair of transactions.</p> <p>The NRD kernel implementation aims for simplicity and a minimal approach to solving the problem of \"relative locks\". Grin does not support a general solution for arbitrary length locks between arbitrary kernels. The implementation is limited in scope to avoid adversely impacting performance and scalability. References between duplicate kernels are implicit, avoiding the need to store kernel references. Locks are limited in length to recent history, avoiding the need to inspect the full historical kernel set during verification.</p>"},{"location":"grin-rfcs/text/0013-nrd-kernels/#reference-level-explanation","title":"Reference-level explanation","text":"<p>An NRD kernel is not valid within a specified number of blocks of a previous duplicate instance of the same NRD kernel. We define duplicate here as two NRD kernels sharing the same public excess commitment. NRD kernels with different excess commitments are not treated as duplicates. An NRD kernel and a non-NRD kernel (plain kernel, coinbase kernel etc.) sharing the same excess commitment are not treated as duplicates.</p> <p>An NRD kernel has an associated relative lock height. For a block B containing this kernel to be valid, no duplicate instance of the kernel can exist in the last RH blocks (up to and including B), where RH is the relative lock height. For example, a transaction containing an NRD kernel with relative lock height 1440 (24 hours) is included in a block at height 1000000. This block is only valid if no duplicate instance of this kernel exists in any block from height 998561 (h-1439) to height 1000000 (h-0) inclusive. A duplicate instance is permitted at height 998560 (h-1440), with the transaction seen as valid. If no duplicate instance of the kernel exists within this range then the lock criteria is met.</p> <p>A kernel can be delayed by the existence of a previous kernel. The non-existence of a previous kernel has no impact on the lock criteria. Note that this implies the first singular occurrence of any NRD kernel meets the lock criteria trivially as it cannot, by definition, be locked by a previous kernel. Thus, the relative lock defaults to \"fail open\" semantics.</p> <p>Each node maintains an index of recent NRD kernels to enable efficient checking of NRD relative lock heights. Note we only need to index NRD locks and we only need to index those within recent history. Relative locks longer than 7 days are not valid. This is believed to be sufficient to cover all proposed use cases.</p> <p>The minimum value for a relative lock height is 1 meaning a prior instance of the kernel can exist in the previous block for the lock criteria to be met. An instance of the NRD kernel in the same block will invalidate the block as the lock criteria will not be met.</p> <p>NRD lock heights of 0 are invalid and it is never valid for two duplicate instances of the same NRD kernel to exist in the same block.</p> <p>It follows that two transactions containing duplicate instances of the same NRD kernel cannot be accepted as valid in the transaction pool concurrently. Current txpool behavior is \"first one wins\" semantics when receiving transactions and this will also apply to transactions containing NRD kernels. We plan to revisit this in a future \"fee\" RFC and plan to investigate the feasibility of introducing \"replace by fee\" semantics at that time.</p> <p>Grin supports \"rewind\" back through recent history to handle fork and chain reorg scenarios. 1 week of full blocks are maintained on each node and up to 10080 blocks can be rewound. To support relative lock heights each node must maintain an index over sufficient kernel history for an additional 10080 blocks beyond this rewind horizon. Each node should maintain 2 weeks of kernel history in the local NRD kernel index. This will cover the pathological case of a 1 week rewind and the validation of a 1 week long relative lock beyond that. The primary use case is for revocable payment channel close operations. We believe a 7 day period is more than sufficient for this. We do not require long, extended revocation periods and limiting this to a few days is preferable to keep the cost of verification low. The need for these revocable transactions to be included on chain should be low as these are only required in a non-cooperative situation but where required we want to minimize the cost of verification which must be performed across all nodes.</p> <p>The following kernel variants are supported in Grin -</p> <ul> <li>Plain</li> <li>Coinbase</li> <li>HeightLocked</li> <li>NoRecentDuplicate</li> </ul> <p>These are implemented as kernel \"feature\" variants -</p> <pre><code>pub enum KernelFeatures {\n    /// Plain kernel (default for Grin txs).\n    Plain = 0,\n    /// A coinbase kernel.\n    Coinbase = 1,\n    /// A kernel with an explicit absolute lock height.\n    HeightLocked = 2,\n    /// A relative height locked NRD kernel.\n    NoRecentDuplicate = 3,\n}\n</code></pre> <p>Each kernel variant includes feature specific data -</p> <pre><code># Plain\n{\n  \"fee\": 8\n}\n# Coinbase\n{\n  # empty\n}\n# Height Locked\n{\n  \"fee\": 8,\n  \"lock_height\": 295800\n}\n# No Recent Duplicate (NRD)\n{\n  \"fee\": 8,\n  \"relative_height\": 1440,\n}\n</code></pre> <p>Note that NRD kernels require no additional data beyond that required for absolute height locked kernels. The reference to the previous kernel is implicit and based on a duplicate NRD kernel excess commitment.</p> <p>The maximum supported NRD relative_height is 10080 (7 days) and the relative height can be safely and conveniently represented as a <code>u16</code> (2 bytes). This differs from absolute lock heights where <code>u64</code> (8 bytes) is necessary to specify the lock height.</p> <p>The minimum supported NRD relative_height is 1 and a value of 0 is not valid. Two duplicate instances of a given NRD kernel cannot exist simultaneously in the same block. There must be a relative height of at least 1 block between them.</p> <p>Nodes on the Grin network currently support two serialization versions for transaction kernels -</p> <p>V1 \"fixed size kernels\"</p> <p>In V1 all kernels are serialized to the same \"fixed\" number of bytes:</p> <pre><code>feature (1 byte) | fee (8 bytes) | additional_data (8 bytes) | excess commitment (33 bytes) | signature (64 bytes)\n\n03 | 00 00 00 00 01 f7 8a 40 | 00 00 00 00 00 00 05 A0 | 08 b1 ... 22 d8 | 33 11 ... b9 69\n</code></pre> <p>NRD kernels use the last 2 bytes of feature specific data for the relative lock height as big-endian u16. The first 6 bytes of feature specific data must be all zero:</p> <pre><code>00 00 00 00 00 00 05 A0\n</code></pre> <p>Note: absolute lock height (u64) and relative lock height (u16) have identical serialization in practice.</p> <p>V1 is supported for backward compatibility with nodes that do not support V2 \"variable size kernels\".</p> <p>V2 \"variable size kernels\"</p> <p>V2 kernels have been supported since Grin <code>v2.1.0</code> and V2 supports the notion of \"variable size\" kernels. See RFC-0005 \"Varible Size Kernels\" for details of this.</p> <p>NRD kernels include 8 bytes for the fee as big-endian u64 and 2 bytes for the relative lock height:</p> <pre><code>feature (1 byte) | fee (8 bytes) | relative_height (2 bytes) | excess commitment (33 bytes) | signature (64 bytes)\n\n03 | 00 00 00 00 00 6a cf c0 | 05 A0 | 09 4d ... bb 9a | 09 c7 ... bd 54\n</code></pre> <p>In V2 relative lock height is 2 bytes as big-endian u16:</p> <pre><code>05 A0\n</code></pre> <p>Note: the serialization strategy is used for both network \"on the wire\" serialization of both transactions and full blocks, and local storage, both the database for full blocks and the kernel MMR backend files. Version negotiation occurs during the initial peer connection setup process and determines which version is used for p2p message serialization. If a node uses V2 serialization for the kernel MMR backend file then it will provide a V2 txhashset based on these underlying files.</p> <p>Kernel Signature Message</p> <p>Every kernel contains a signature proving the excess commitment is a commitment to zero. The message being signed includes the features, fee and other associated data to prevent malleability of the transaction kernel and the overall transaction. The transaction fee cannot be modified after signing, for example.</p> <p>For NRD kernels the message being signed is constructed as follows with the relative lock height serialized as 2 bytes.</p> <pre><code>Hash(feature | fee | relative_height)\n\nHash(03 | 00 00 00 00 01 f7 8a 40 | 05 A0)\n</code></pre> <p>No additional data is introduced with NRD kernels beyond the 2 bytes representing the relative lock height. There is no opportunity to include arbitrary data. Any additional kernel included in a transaction is itself still a fully valid kernel. There is no explicit reference necessary that could be misused to include arbitrary data.</p> <p>An additional NRD kernel in a transaction will increase the \"weight\" of the transaction by this single additional kernel and allows for a simple way to deal with additional fees. A transaction with an additional kernel must provide additional fees to cover the additional \"weight\". NRD kernels cannot be added for free. Note that in some limited situations it is possible to replace a kernel with an NRD kernel. If the NRD lock can be introduced without adding an additional kernel then the fee does not have to be increased and the lock is effectively added for free.</p> <p>A transaction kernel consists of an excess commitment and an associated signature showing this excess is indeed a commitment to 0.</p> <p>A transaction with a single kernel can always be represented as a transaction with multiple kernels, provided the kernels excess commitments sum to the correct total excess.</p> <p>Given an existing NRD kernel with excess commitment -</p> <ul> <li>r'G + 0H</li> </ul> <p>And a transaction with single excess commitment -</p> <ul> <li>rG + 0H</li> </ul> <p>This transaction can be represented as a pair of kernels with excess commitments -</p> <ul> <li>rG + 0H =     (r'G + 0H) + (r-r'G + 0H)</li> </ul> <p>We take advantage of this to allow an arbitrary NRD kernel to be included in any transaction at construction time.</p> <p>Additionally the kernel offset included in each transaction can be used in certain situations to allow the replacement of a single transaction kernel with an NRD kernel without needing to introduce an additional kernel.</p> <p>Given an existing NRD kernel with excess commitment -</p> <ul> <li>r'G + 0H</li> </ul> <p>And a transaction with single excess commitment and kernel offset -</p> <ul> <li>rG + 0H, o</li> </ul> <p>This transaction can be rewritten to use the NRD kernel -</p> <ul> <li>r'G + 0H, (o+r-r')</li> </ul> <p>These two \"degrees of freedom\", introducing multiple kernels and adjusting the kernel offset, allowing for flexibility to introduce an NRD kernel in a variety of ways.</p> <ul> <li>Introduce NRD kernel to transaction, compensate with additional kernel.</li> <li>Introduce NRD kernel to transaction, compensate with kernel offset.</li> </ul>"},{"location":"grin-rfcs/text/0013-nrd-kernels/#payment-channel-implementation","title":"Payment Channel Implementation","text":"<p>NRD kernels can be used to delay alternate \"branches\" of conflicting transactions, enabling a payment channel implementation.</p> <p>A payment channel is represented as a single multi-party output. Each channel state transition is represented as a pair of \"close\" and \"settle\" transactions with an NRD kernel enforcing a delay between them. Funds are held in an intermediate multi-party output while delayed. The NRD kernel is reused across both transactions by adjusting kernel offsets.</p> <p>X -&gt; Y, K<sub>nrd_a</sub> \\ Y -&gt; [Z<sub>a</sub>, Z<sub>b</sub>], K<sub>nrd_a</sub></p> <p>Alice closes the channel X with their \"close\" transaction. After a delay Alice can \"settle\" the funds out to Alice and Bob.</p> <p>Attribution of \"close\" and \"settle\" transactions for each channel state is provided through endpoint specific NRD kernels. This allows the other party to \"revoke\" old invalid state without the NRD delay.</p> <p>Each channel state transition involves a new pair of \"close\" and \"settle\" transactions for each participant along with a shared \"revoke\" transaction. The \"revoke\" transaction simply spends funds back to the channel output and a plain kernel suffices.</p> <p>[Z<sub>a</sub>, Z<sub>b</sub>] -&gt; X, K<sub>rev</sub></p> <p>Alice attempts to close old invalid state (Y<sub>1</sub>):</p> <p>X -&gt; Y<sub>1</sub>, K<sub>nrd_a1</sub></p> <p>Bob can immediately revoke and close current state (Y<sub>1</sub> -&gt; Y<sub>2</sub>):</p> <p>Y<sub>1</sub> -&gt; ~[Z<sub>a</sub>, Z<sub>b</sub>]~, K<sub>nrd_b1</sub> \\ ~[Z<sub>a</sub>, Z<sub>b</sub>]~ -&gt; <sub>X</sub>, K<sub>rev_1</sub> \\ <sub>X</sub> -&gt; Y<sub>2</sub>, K<sub>nrd_b2</sub> \\ =&gt; Y<sub>1</sub> -&gt; Y<sub>2</sub>, [K<sub>nrd_b1</sub>, K<sub>rev_1</sub>, K<sub>nrd_b2</sub>]</p> <p>Bob publishes only the final cut-through multi-kernel transaction (Y<sub>1</sub> -&gt; Y<sub>2</sub>). Bob's individual settle transaction is not revealed.</p> <p>Neither party can self-revoke without introducing the NRD delay. The other party always has the opportunity to revoke first. Self-revocation cannot be used to lock funds up indefinitely.</p>"},{"location":"grin-rfcs/text/0013-nrd-kernels/#rolloutdeployment-hf3","title":"Rollout/Deployment (HF3)","text":"<p>The following rules will be enforced during rollout as part of HF3 -</p> <p>Assumptions:</p> <ol> <li>HF3 will occur at height 786,240.</li> <li>Blocks at height &gt;= 786,240 will have block version &gt;= 4.</li> </ol> <p>Block Specific Rules:</p> <ol> <li>A block containing NRD kernel(s) is only be valid if block version &gt;= 4.</li> <li>A block containing NRD kernel(s) is only valid if all defined relative lock height rules are met.</li> <li>Two duplicate NRD kernel instances cannot exist in the same block.</li> </ol> <p>Transaction Specific Rules:</p> <ol> <li>A transaction containing NRD kernel(s) will not be accepted by the local txpool/stempool unless chain head version &gt;= 4.</li> <li>A transaction containing NRD kernel(s) will not be relayed or broadcast to other nodes unless chain head version &gt;= 4.</li> <li>A transaction containing NRD kernel(s) will not be accepted by the local txpool/stempool unless it meets the defined relative lock height rule in the next block.</li> <li>A transaction containing NRD kernel(s) will not be relayed or broadcast to other nodes unless it meets the defined relative lock height rule in the next block.</li> <li>Two duplicate NRD kernel instances cannot exist in the txpool/stempool concurrently.</li> </ol>"},{"location":"grin-rfcs/text/0013-nrd-kernels/#weights-fees","title":"Weights &amp; Fees","text":"<p>For the purpose of block weight calculations, each kernel is treated as 3 \"weight units\" where each unit is approximately 32 bytes. This covers the excess commitment and the associated signature common across all kernel variants. The additional 2 bytes of \"relative height\" on NRD kernels are ignored for the purposes of calculating block weight.</p> <p>For the purpose of minimum transaction relay fees all kernels are treated as 1 \"fee unit\" with each unit being 1 milligrin. We plan to revisit the entire transaction fee structure in a future RFC. Kernel variants may affect the transaction fee calculations differently in the future.</p>"},{"location":"grin-rfcs/text/0013-nrd-kernels/#drawbacks","title":"Drawbacks","text":"<p>NRD kernels are a limited and restricted form of \"relative locks\" between kernels. These locks are limited to a period of 7 days and \"fail open\" beyond that window. This approach meets the requirements for limited revocable payment channel operations but there are likely to be use cases where this approach is not sufficient or unsuitable.</p> <p>While it would be nice to provide a fully general purpose solution that would allow arbitrary locks to be implemented, it does appear to be hard, if not impossible, to do this in Grin/MW.</p>"},{"location":"grin-rfcs/text/0013-nrd-kernels/#rationale-and-alternatives","title":"Rationale and alternatives","text":"<p>Referencing historical data in Grin and in Mimblewimble in general is difficult due to the possibility of pruning historical data. It is not possible to reference old outputs once they are spent. Historical validators must have access to any referenced data to validate consensus rules. This leaves transaction kernels as the only available data to be referenced. While arbitrary historical kernels can be referenced this is not desirable as we do not want to impose additional constraints on nodes, requiring them to maintain historical data that would otherwise be prunable.</p> <p>An earlier design iteration was \"No Such Kernel Recently\" (NSKR) locks. Where NRD references were implicit, with duplicate kernel excess commitments, NSKR kernels referenced prior kernels explicitly. These explicit references were problematic for several reasons -</p> <ul> <li>Additional overhead, both local storage and network traffic due to the explicit references.</li> <li>Optimization by referencing prior kernel based on MMR position introduced a dependency on external data (kernels can no longer be validated in isolation).</li> <li>Permitting non-existence of references due to limited window of history, opened up a vector for \"spam\" where arbitrary data could be used in place of a valid reference.</li> </ul> <p>To prevent \"spam\" a signature can be used to verify the reference was indeed a valid commitment. By including a signature along with the commitment, the reference is effectively a full transaction kernel.</p> <p>The idea of using Merkle proofs to verify inclusion of a historical referenced kernel in the kernel MMR was also considered. This gets expensive both in terms of transaction size and increased verification cost. There is also the problem of position not yet being known at transaction creation time, necessitating Merkle proof generation at block creation time by miners which adds complexity.</p>"},{"location":"grin-rfcs/text/0013-nrd-kernels/#prior-art","title":"Prior art","text":"<p>Bitcoin allows transaction inputs to be \"encumbered\" with a relative locktime based on the sequence number field. This restricts an input from spending the associated output until a certain number of blocks have passed. BIP112 describes the CHECKSEQUENCEVERIFY opcode in Bitcoin and BIP68 describes the underlying consensus changes around the sequence number field.</p> <ul> <li>Timelock#CheckSequenceVerify (bitcoin wiki)</li> <li>CheckSequenceVerify (bitcoin wiki)</li> <li>Bitcoin BIP-0068</li> <li>Bitcoin BIP-0112</li> </ul> <p>Note that relative locks in Bitcoin are based on transaction inputs and outputs, with inputs only able to spend outputs once confirmed beneath a certain number of blocks. We cannot do this in Grin due to the pruning of old data. Spent outputs will eventually be removed and cannot be relied upon as part of the validation process. Bitcoin encumbers individual outputs whereas in Grin we encumber transactions via the constituent transaction kernels.</p>"},{"location":"grin-rfcs/text/0013-nrd-kernels/#unresolved-questions","title":"Unresolved questions","text":"<p>Some investigation is still needed around the conditions necessary to allow a kernel to simply be reused with an adjustment to the kernel offset and where an additional kernel is necessary. An adjustment to the kernel offset will expose the private excess under certain conditions and cannot be done safely for all transactions.</p> <p>One outstanding question is what use cases are not covered by NRD kernels. We believe them to be sufficient for the revocable payment channel close mechanism. But they may not be sufficient for all use cases.</p> <p>Succinct Atomic Swaps (SAS) describes the use of both relative locks and adaptor signatures to implement atomic swaps with only two on-chain transactions. The secret associated with the adaptor signature is swapped to allow funds to be claimed while the relative lock locks funds prior to a refund being claimed. We note that NRD kernels and adaptor signatures are not directly compatible as a prior instance of an NRD kernel would have revealed the secret associated with the adaptor signature. That said we can produce transactions with multiple kernels and we can use this to isolate the adaptor signature on a separate kernel alongside an NRD kernel. It is an unresolved question if there is a way to modify the SAS protocol and avoid the need for these additional kernels in Grin/MW.</p>"},{"location":"grin-rfcs/text/0013-nrd-kernels/#references","title":"References","text":"<ul> <li>Original \"triggers\" mailing list post by Ruben Somsen</li> <li>\"No Such Kernel Recently\" post by John Tromp</li> <li>\"Duplicate Kernels\" post by Antioch</li> <li>\"NRD based payment channel\" post by John Tromp</li> <li>Earlier NSKR based payment channel design)</li> <li>Timelock#CheckSequenceVerify (bitcoin wiki)</li> <li>CheckSequenceVerify (bitcoin wiki)</li> <li>Bitcoin BIP-0068</li> <li>Bitcoin BIP-0112</li> <li>Succinct Atomic Swaps by Ruben Somsen</li> <li>Scriptless Scripts</li> <li>RFC-0005 \"Variable Size Kernels\"</li> </ul>"},{"location":"grin-rfcs/text/0014-general-fund-guidelines/","title":"0014 general-fund-guidelines","text":"<ul> <li>Title: general-fund-guidelines</li> <li>Authors: Michael Cordner</li> <li>Start date: Feb 07, 2020</li> <li>RFC PR: Edit if merged: mimblewimble/grin-rfcs#41</li> <li>Tracking issue: <code>N/A</code></li> </ul>"},{"location":"grin-rfcs/text/0014-general-fund-guidelines/#summary","title":"Summary","text":"<p>This RFC establishes a set of guidelines for spending the Grin Development Fund, the procedure via which funding requests can be made, and a set of procedures for managing and reporting on the fund.</p>"},{"location":"grin-rfcs/text/0014-general-fund-guidelines/#motivation","title":"Motivation","text":"<p>Previously there were no clear guidelines on how the Grin Development Fund could be spent and what types of activities could and could not be financed from the fund. This RFC presents a set of non-exhaustive guidelines intended to ensure that:</p> <ul> <li>Donators have a clear understanding of how their donations are likely to be spent.</li> <li>Those with funding ideas have a clear reference point to understand what types of proposals are likely to be considered for funding.</li> <li>Those with funding ideas have a specific process through which they can apply for funding.</li> <li>The team making spending decisions has clear, community-established guidelines against which to consider new funding requests.</li> <li>The decision-making process through which funding requests are granted is as fair, consistent and transparent as it can reasonably be.</li> <li>The wider community understands how the fund is managed and that transparency is evident.</li> </ul> <p>Note that this document does not establish hard-and-fast rules for how the fund's contents can be spent. It is meant to be an indicative focal point for the community, and is intended to evolve with the needs of the project.</p>"},{"location":"grin-rfcs/text/0014-general-fund-guidelines/#community-level-explanation","title":"Community-level explanation","text":""},{"location":"grin-rfcs/text/0014-general-fund-guidelines/#appropriate-and-inappropriate-uses-of-the-grin-development-fund","title":"Appropriate and inappropriate uses of the Grin Development Fund","text":"<p>Although spending decisions will always be made on a case-by-case basis, it is understood that the Grin Development Fund is to be used mainly to finance the development needs of the Grin project and the advancement of Grin/Mimblewimble as a whole.</p> <p>There is scope for interpretation as to what this actually means, but the following presents (non-exhaustive) guidelines as to the types of activities that would be considered appropriate to finance from the fund.</p> <ul> <li>Activities related to the continuing development needs of the Grin code-base and related projects under the GitHub mimblewimble organization. This can include:</li> <li>Fixed-term development or project-management contracts</li> <li>Infrastructure and other incidental costs</li> <li>Security audit costs</li> <li>Costs incurred for any legal matters that may arise for either the project or individual contributors arising directly from their work in good faith on the Grin project</li> <li>Running budgets for Grin teams (with funds spent at their own discretion)</li> <li>Technological research in areas that may be relevant to Grin in the future</li> <li>Cryptographic research related to Grin or Mimblewimble in general</li> <li>Fully open-sourced community-based projects that enhance the Grin ecosystem</li> <li>Supporting non-profit, community-driven and inclusive promotional efforts for the Grin Project (e.g. Grincon)</li> <li>Charitable donations toward important causes relevant to the Grin or cryptocurrency communities as a whole</li> </ul> <p>While the guidelines above give plenty of flexibility in how funds can be employed toward the advancement of the Grin project, certain types of funding requests will not be considered:</p> <ul> <li>Marketing or promotional 'offers' where a party is taking a profit or gains some financial benefit to promote Grin (regardless of how the 'opportunity' is presented)</li> <li>Cryptocurrency speculation or any kind of investment</li> </ul>"},{"location":"grin-rfcs/text/0014-general-fund-guidelines/#request-for-funding-process","title":"Request for Funding Process","text":"<p>All requests for funding should be made in the Governance Section of the Grin forum. Topics should be clearly titled \"Request for Funding: \" followed by a short description of the request.</p> <p>There is no set template for what the contents of the funding request should include, however a better reception can be attained by including:</p> <ul> <li>The exact amount requested, what the funding covers and for what time period (if applicable)</li> <li>A clear description of what will be provided to the Grin project in return, including:<ul> <li>Details of any work or research that will be performed during the period</li> <li>The expected deliverable, if applicable (for a research project, for instance)</li> </ul> </li> <li>Background information on the person making the request</li> </ul> <p>Amounts should be stated using fiat currency equivalents with the exact Cryptocurrency amount determined by the rate at the time of transfer. To assist others with conceptualizing the amounts, fiat currencies used should be reasonably global, e.g. USD, EUR, CNY, GBP.</p> <p>All community discussion on the funding request should be made within the forum thread itself, and the final decision on the request will be made by members of the core team at a public governance meeting, to take place at least one week after the request is made. The community is encouraged to display their support (or lack thereof) of a funding request at these Governance meetings, however the decision rests with the core team.</p> <p>It should also be noted that decisions should never be considered final. Those making funding requests are encouraged to revise or refine proposals based on whatever feedback is given during the request process and submit them for consideration again.</p>"},{"location":"grin-rfcs/text/0014-general-fund-guidelines/#decision-process","title":"Decision Process","text":"<p>While everyone and anyone is encouraged to create a funding request, those making requests should understand that not all funding decisions will be approved simply on the basis of them conforming to the guidelines above. Many other factors will be considered for each request, including (but not limited to):</p> <ul> <li>How well known in the community is the person making the funding request?</li> <li>Have too many similar requests been funded recently?</li> <li>How tangible is the value proposition to Grin?</li> <li>How much risk is involved relative to the size of the ask and the potential return.</li> <li>Does a prioritization call need to be made due to a limited balance in the General Fund?</li> </ul> <p>Everyone is welcome to weigh in on the merits of a funding request in the forum thread and during the public governance meeting where the funding request is finalized. The core team will strive to ensure there's a community consensus for each request, however the final decision rests with the core team. Other Grin teams who have been allocated budgets can spend funds at their own discretion, but are strongly encouraged to consider the guidelines in this RFC during their decision making process.</p>"},{"location":"grin-rfcs/text/0014-general-fund-guidelines/#tips-on-effective-proposals","title":"Tips on effective proposals","text":"<ul> <li>You proposal is likely to be better received if you're already known to the Grin community or the wider cryptocurrency community. Even more so if you've already contributed to Grin in some meaningful way.</li> <li>It might be better to keep your initial funding request small and focused, particularly if your idea is something new and radical, or if you're unknown to the Grin community.</li> <li>Be specific, professional and thorough with your proposal.</li> <li>Be respectful and professional in your response to any feedback and criticism on the proposal thread</li> </ul>"},{"location":"grin-rfcs/text/0014-general-fund-guidelines/#payout-process","title":"Payout Process","text":"<ul> <li>At the time of payout, the approved funding amount is converted to the equivalent in cryptocurrency and paid out to an address provided by the funding requestor only.</li> <li>The payout address should be provided to the core team by the requestor via a secure, verifiable channel (with cryptographic proof of identity if deemed necessary).</li> <li>Any conversion rate between the currency of the funding request and the currency that is paid out from the general fund is determined by the prevailing exchange rate at the time of the funding transaction, without exception.</li> <li>To minimize the effects of currency fluctuations on accounting transparency, all payments should be performed at pre-arranged \"signing parties\" in which mu-sig holders sample the current exchange rate. The transaction should be created, signed and broadcast as quickly as possible, with the transaction and rate reported back to the core team for tracking.</li> <li>Mu-sig holders will verify the address provided by the funding requestor several times during transaction creation and broadcasting. However, the core team is not responsible for errors or incorrect addresses provided by the requestor.</li> </ul>"},{"location":"grin-rfcs/text/0014-general-fund-guidelines/#reporting","title":"Reporting","text":"<p>The result of all funding decisions will be published in the meeting notes found in the Grin Project Management repository.</p> <p>The core team is obliged to publish a detailed spending log of all transactions made in and out of the fund, as well as quarterly transparency reports summarizing all income and spending. This and other financial reporting can be found in the /grin-pm repository.</p>"},{"location":"grin-rfcs/text/0014-general-fund-guidelines/#unresolved-questions","title":"Unresolved questions","text":"<ul> <li>This RFC is put together on the understanding that the fundamental question of 'who appoints the core team' is still outstanding. This point should be discussed separately and this RFC assumes there is an acceptable answer in place.</li> </ul>"},{"location":"grin-rfcs/text/0014-general-fund-guidelines/#future-possibilities","title":"Future possibilities","text":"<p>Ideas to further improve the funding process include creating a community funding website, where proposals can be made and vetted by the community, and support for particular ideas can be shown. Contributions towards funding could be made by community individuals and be matched with contributions from the general fund.</p>"},{"location":"grin-rfcs/text/0014-general-fund-guidelines/#references","title":"References","text":"<ul> <li>https://grin.mw/fund</li> <li>https://github.com/mimblewimble/grin-pm/</li> </ul>"},{"location":"grin-rfcs/text/0015-slatepack/","title":"0015 slatepack","text":"<ul> <li>Title: slatepack</li> <li>Authors: joltz</li> <li>Start date: May 07, 2020</li> <li>RFC PR: mimblewimble/grin-rfcs#55</li> <li>Tracking issue: mimblewimble/grin-wallet#406</li> </ul>"},{"location":"grin-rfcs/text/0015-slatepack/#summary","title":"Summary","text":"<p>Slatepack is a universal transaction standard for Grin. It is designed to provide a single coherent transaction building framework to improve both the user and developer experiences in the Grin ecosystem. All wallets and services are expected to fully support the Slatepack standard by the last scheduled hard fork in January 2021 to remain compatible.</p> <p>This document specifies the required components of the Slatepack standard and introduces them in the context of existing methods for transaction building in Grin. It assumes that Slatepack is the default supported transaction standard for Grin and is intended to operate under all conditions and edge cases. Slatepack is intended to be compatible with the objects and serialization methods defined in the Slate V4/Compact Slates RFC. This RFC is meant to replace the Slate Serialization, Armored Slates and Encrypted Slates RFCs.</p>"},{"location":"grin-rfcs/text/0015-slatepack/#motivation","title":"Motivation","text":"<p>Without a comprehensive transaction building flow, users and services are left to make their own complicated decisions about firewalls, file handling and compatibility, risking their security, privacy and sanity.</p> <p>The objective of this RFC is to converge on a simple, universal, adoptable, secure and privacy preserving workflow standard for Grin transactions: Slatepack.</p>"},{"location":"grin-rfcs/text/0015-slatepack/#community-level-explanation","title":"Community-level explanation","text":"<p>Slatepack changes the existing transaction building process in Grin in a few ways:</p> <ol> <li> <p>Users, developers and services are no longer required to choose between many possible transaction methods to use and support: Slatepack is a universal Grin transaction standard</p> <ul> <li>The transport method decision now occurs automatically for the user by following the Slatepack standard</li> <li>There is only one synchronous method and one asynchronous method supported by default to keep things simple for developers and support workers</li> </ul> </li> <li> <p>Tor is the only synchronous transaction transport method that is currently supported in the Slatepack standard</p> <ul> <li>This happens \"under the hood\" by the wallet and the user only has to keep track of a <code>SlatepackAddress</code> for their counterparty</li> <li>If Tor is not successful, the transaction process automatically falls back to using an encrypted copy and pastable <code>SlatepackMessage</code> string to complete the transaction asynchronously</li> </ul> </li> <li> <p>The asynchronous method by default is now a copy and pastable <code>SlatepackMessage</code> string instead of a file</p> <ul> <li><code>SlatepackMessage</code> is an ascii-armor string that supports encryption of its payload with a <code>SlatepackAddress</code><ul> <li>An encrypted <code>SlatepackMessage</code> is not meaningfully larger than a plain text <code>SlatepackMessage</code> with regard to transportability as proposed here</li> </ul> </li> </ul> </li> <li> <p>The difference between synchronous and asynchronous transaction methods is abstracted away from the end user with the Slatepack standard</p> <ul> <li><code>grin-wallet send -d SlatepackAddress 1.337</code> will first try to send the Grin synchronously via Tor to the <code>SlatepackAddress</code></li> <li>If that fails it will fall back to outputting an armored encrypted <code>SlatepackMessage</code> string for manual copy and paste transport</li> <li>Example <code>SlatepackAddress</code>: <code>grin1p4fuklglxqsgg602hu4c4jl4aunu5tynyf4lkg96ezh3jefzpy6swshp5x</code></li> </ul> </li> <li> <p>Asynchronous transactions are now encrypted by default by knowing the <code>SlatepackAddress</code> of your counterparty(s)</p> <ul> <li>If a counterparty is unwilling or unable to provide a <code>SlatepackAddress</code>, a plain text <code>SlatepackMessage</code> can still be exchanged</li> </ul> </li> <li> <p>Sending a mobile Grin transaction should be as easy as scanning a simple QR encoded from a bech32 <code>SlatepackAddress</code></p> <ul> <li>Or as easy as pasting the <code>SlatepackAddress</code> of your counterparty into your wallet for any other device</li> <li>Or if Tor is not accessible, or the receiving party is not online, as easy as copying and pasting a couple of <code>SlatepackMessage</code> strings with a counterparty in an alternative communication channel (email, forum, social media, instant messenger, generic web text box, carrier pigeon etc.)</li> </ul> </li> </ol>"},{"location":"grin-rfcs/text/0015-slatepack/#reference-level-explanation","title":"Reference-level explanation","text":"<p>The Slatepack standard defines the three primary components: <code>SlatepackAddress</code>, <code>SlatepackMessage</code> and <code>SlatepackWorkflow</code>.</p> <p>The <code>SlatepackAddress</code> is a shareable bech32 encoded ed25519 public key that can be used both to route synchronous transactions and to encrypt asynchronous transactions.</p> <p>The <code>SlatepackMessage</code> is an easily copy and pastable ascii-armor string that contains an encrypted slate payload by default and is used in asynchronous transactions.</p> <p>The <code>SlatepackWorkflow</code> specifies how both of these components interact in a universally adoptable transaction standard for Grin.</p>"},{"location":"grin-rfcs/text/0015-slatepack/#slatepackaddress","title":"<code>SlatepackAddress</code>","text":"<p>A <code>SlatepackAddress</code> is a bech32 encoded ed25519 public key and when shared with other parties is used to represent the ability to receive Grin transactions.</p> <p>grin-wallet already handles ed25519 keys for the v3 onion addresses in Tor transactions. These keys can be extended to be a general <code>SlatepackAddress</code> to allow a universal key format for both transport and encryption that is error-checked, QR friendly and easily human identifiable.</p> <ul> <li> <p>Existing ed25519 public keys from the wallet are bech32 encoded with <code>grin</code> as the <code>human-readable part</code> to build a <code>SlatepackAddress</code></p> <ul> <li><code>tgrin</code> is the HRP for a floonet <code>SlatepackAddress</code></li> </ul> </li> <li> <p>A <code>SlatepackAddress</code> can be decoded to its ed25519 public key which can then be mapped to an x25519 public key to be used for encryption</p> </li> </ul> <p>By default, all wallets should generate a new <code>SlatepackAddress</code> for each transaction for improved user privacy and security. Wallets can optionally support the ability for a static, reusable receiving <code>SlatepackAddress</code> with a warning about the privacy risks of reusing these addresses.</p> <p>The exact proposal for the implementation of simulatenous active <code>SlatepackAddresses</code> to enforce address uniqueness by default according to this standard is left as an implementation detail to wallets to ensure that wallets can interactively receive Grin across many <code>SlatepackAddresses</code> simulataneously and efficiently.</p> <p>ed25519 keys are bech32 encoded as <code>SlatepackAddresses</code> rather than x25519 keys because the mapping from ed25519 to x25519 is more straightforward (x25519 public keys do not carry a <code>v</code> coordinate so they can map to two possible ed25519 public keys- this is solvable but using the ed25519 as the first order key avoids a potentially complex solution).</p>"},{"location":"grin-rfcs/text/0015-slatepack/#key-generation","title":"Key Generation","text":"<p>Keys used in <code>SlatepackAddresses</code> are derived from a path from the master seed in a given wallet account. Currently the wallet uses separate derivation paths: one for the private bytes used for the blinding factor keys and one for the private bytes used to derive the ed25519 keys used to derive Tor onion addresses. ed25519 keys used for a <code>SlatepackAddress</code> are derived from this second derivation path of the master seed.</p> <p><code>SlatepackAddress</code> keys may be derived in parallel to the blinding factor derivation path such that a unique <code>SlatepackAddress</code> is derived each time a new blinding factor is derived for a transaction to satisfy the requirement for a unique <code>SlatepackAddress</code> to be used for each transaction by default.</p> <p>In a future update it may be desirable to encode the derivation path for the <code>SlatepackAddress</code> for a given encrypted <code>SlatepackMessage</code> somewhere so that the x25519 decryption keys can be derived without grinding down the path to find the right key to use.</p>"},{"location":"grin-rfcs/text/0015-slatepack/#example-slatepackaddress","title":"Example <code>SlatepackAddress</code>","text":"<pre><code>grin1p4fuklglxqsgg602hu4c4jl4aunu5tynyf4lkg96ezh3jefzpy6swshp5x\n</code></pre>"},{"location":"grin-rfcs/text/0015-slatepack/#slatepackmessage","title":"<code>SlatepackMessage</code>","text":"<p>A <code>SlatepackMessage</code> requires multiple layers of data and encoding.</p>"},{"location":"grin-rfcs/text/0015-slatepack/#serialization","title":"Serialization","text":"<p>Grin slates are serialized as first order JSON objects. Binary serialization is done on those JSON objects. Before Slatepack, users could use both binary and JSON serialization for asynchronous transactions.</p> <p>With the Slatepack standard, all asynchronous transactions serialize the slate JSON objects as binary. JSON serialization for synchronous transactions (Tor) is still used as before. The Slatepack standard serialization choices are only relevant for asynchronous transaction methods.</p> <p>The details for the binary serialization of the most recent slates at the time of this writing can be found in the Slate V4 (Compact Slates) RFC. Future variations in slate binary serialization should be referenced in an RFC and may require the update of this document.</p>"},{"location":"grin-rfcs/text/0015-slatepack/#plain-text-metadata","title":"Plain Text Metadata","text":"<p>Plain text metadata is included with Slatepack messages to indicate how to handle the encryption if any for the slate data in addition to tracking versions for compatibility. It can be expanded in future versions with new fields that are safe to include as plain text. These fields are neither encrypted nor authenticated.</p> <ul> <li><code>\"slatepack\": [Major, Minor]</code></li> <li> <p>Where <code>[Major, Minor]</code> are positive fixnum ints representing the Slatepack version used to build the <code>SlatepackMessage</code></p> </li> <li> <p><code>\"mode\": int</code></p> </li> <li>Where <code>int</code> is a positive fixnum int indicating the type of <code>SlatepackMessage</code></li> <li>0 == plain text</li> <li>1 == encrypted</li> <li>Extendable to future new modes (e.g. multiparty)</li> <li> <p>Indicates which additional metadata fields should be expected to follow</p> </li> <li> <p><code>\"sender\": SlatepackAddress</code></p> </li> <li>Only used here where <code>mode == 0</code>, otherwise this field is encrypted as described below</li> <li>Where <code>SlatepackAddress</code> is a bech32 encoded ed25519 public key generated by the sender's wallet</li> <li>For Slatepacks where the user does not wish to provide any <code>SlatepackAddress</code> a <code>0</code> value is used</li> <li>This value is used in the <code>SlatepackWorkflow</code> to attempt to complete the transaction via Tor and to otherwise encrypt a slate for asynchronous transport</li> </ul>"},{"location":"grin-rfcs/text/0015-slatepack/#encrypted-metadata","title":"Encrypted Metadata","text":"<p>Encrypted metadata is included with an encrypted <code>SlatepackMessage</code> to improve privacy for the sender of a Slatepack transaction in cases where Tor is not available. It is a basic structure containing the sender <code>SlatepackAddress</code> and potential <code>recipients_list</code> field for multiparty use to be encrypted by age. If these fields are included as plain text metadata, they would require an additional MAC field for authentication and reveal data that would be desirable to keep private.</p> <p>Note that <code>recipients_list</code> does not gain the same privacy advantages of the <code>sender</code> field because the values can be derived from the plain text data included in the age header with a bit of work.</p> <ul> <li><code>\"sender\": SlatepackAddress</code></li> <li> <p>Used to complete the <code>SlatepackWorkflow</code></p> </li> <li> <p><code>\"recipients_list\": vec&lt;SlatepackAddress&gt;</code></p> </li> <li>Only included in multiparty encrypted mode for use in future versions</li> <li>Array of recipients such that each recipients <code>SlatepackAddress</code> in <code>recipients_list</code> matches their associated <code>epk</code> and <code>emk</code> by index in the age encryption header of the encrypted payload</li> <li>E.g. <code>\"recipients_list\": [grin1a, grin1b]</code>, <code>\"age_header_recipients\": [(X25519, EPKa, EMKa), (X25519, EPKb, EMKb)]</code><ul> <li><code>grin1a</code> and <code>(X25519, EPKa, EMKa)</code> both belong to the same party as they are both at index 0</li> <li><code>grin1b</code> and <code>(X25519, EPKb, EMKb)</code> both belong to the same party as they are both at index 1</li> </ul> </li> </ul>"},{"location":"grin-rfcs/text/0015-slatepack/#encryption","title":"Encryption","text":"<p>Slatepack encryption adheres to the cryptography decisions made by age. It supports a conversion from the ed25519 signing key type that grin-wallet already uses for Tor to a x25519 encryption key type that age uses for encryption. This allows us to avoid having to make new cryptography decisions to support encrypted slates with keys already used in grin-wallet.</p> <p>While Slatepack adheres to the cryptography decisions and payload structure choices made by age in its encrypted payloads, this data alone is not sufficient to handle all possible <code>SlatepackWorkflow</code> steps (because the age recipient header data contains x25519 keys, we want ed25519 keys for the workflow as key mapping in the other direction is not desirable).</p> <p>It should also be noted that a <code>SlatepackAddress</code> could be used to do generic age encryption by decoding the bech32 to the ed25519 public key and mapping that to its corresponding x25519 public key used in age. An <code>age Address</code> could also be used as a <code>SlatepackAddress</code> with some extra effort: bech32 decode to the x25519 public key and then follow Signal's lead to attempt to solve the problem of an x25519 key mapping to two ed25519 keys to give a single ed25519 public key to be used to build a <code>SlatepackAddress</code> by bech32 encoding with <code>slatepack</code> as the HRP.</p>"},{"location":"grin-rfcs/text/0015-slatepack/#payload-age-encryption","title":"Payload (age Encryption)","text":"<p>A binary serialized slate and associated <code>Encrypted Metadata</code> fields are concatenated and encrypted according to the age encryption specification. The steps taken here follow age as closely as possible to avoid losing any security properties. A fairly well-reviewed age library in rust is available to use for implementation.</p> <p>Any deviations in Slatepack encryption from the exact cryptography steps and decisions made in age are unintentional and should be corrected unless they are explicitly stated as a deviation from the cryptography decisions made by age.</p> <p>An encrypted Slatepack payload is built with the same steps as an encrypted age payload, where the X25519 keys are derived from a participants <code>SlatepackAddress</code>.</p> <p>E.g. <code>age_encrypt(sender + slate_binary)</code> where <code>mode == 1</code> and <code>sender</code> is a valid <code>SlatepackAddress</code></p>"},{"location":"grin-rfcs/text/0015-slatepack/#armor","title":"Armor","text":"<p>The payload that will be armored is an optionally encrypted, binary serialized <code>Slatepack</code> JSON object and any associated encrypted metadata. Armor is <code>Framing</code> wrapped around a <code>SimpleBase58Check</code> encoded <code>Payload</code>.</p>"},{"location":"grin-rfcs/text/0015-slatepack/#framing","title":"Framing","text":"<p>Armor uses specific <code>Headers</code>, <code>Footers</code> and <code>Periods</code> as <code>Framing</code> to contain its <code>Payload</code>.</p> <ul> <li><code>Header</code></li> <li>Supported Headers:<ul> <li><code>BEGINSLATEPACK</code></li> </ul> </li> <li> <p>Regex: <code>^[&gt;\\n\\r\\t ]*BEGINSLATEPACK[&gt;\\n\\r\\t ]*$</code></p> </li> <li> <p><code>Footer</code></p> </li> <li>Supported Footers<ul> <li><code>ENDSLATEPACK</code></li> </ul> </li> <li> <p>Regex: <code>^[&gt;\\n\\r\\t ]*ENDSLATEPACK[&gt;\\n\\r\\t ]*$</code></p> </li> <li> <p><code>Periods</code></p> </li> <li> <p>All data of an armored slate up to the first <code>.</code> is the framing header</p> </li> <li>All data after the first <code>.</code> and before the second <code>.</code> is the <code>SimpleBase58Check</code> encoded payload which contains the slate data</li> <li>All data after the second <code>.</code> and before the third <code>.</code> is the framing footer</li> <li>Any data after the third <code>.</code> is ignored</li> </ul>"},{"location":"grin-rfcs/text/0015-slatepack/#encoding-simplebase58check","title":"Encoding <code>SimpleBase58Check</code>","text":"<p><code>SlatepackMessage</code> armor payloads are encoded similar to legacy bitcoin addresses, with the primary differences being that the <code>SimpleBase58Check</code> used here does not include version bytes and includes the error checking code at the beginning of the payload instead of at the end.</p> <ol> <li> <p><code>SHA256(SHA256(SLATEPACK_MESSAGE_BINARY))</code></p> </li> <li> <p>First four bytes from previous step are <code>ERROR_CHECK_CODE</code></p> </li> <li> <p>Concatenate <code>ERROR_CHECK_CODE + SLATEPACK_MESSAGE_BINARY</code></p> </li> <li> <p>Base58 encode the output from the previous step to complete the armor <code>Payload</code></p> </li> </ol> <p>It should be noted that the <code>ERROR_CHECK_CODE</code> does not have a robust error checking ability because a double sha256 hash is not a proper error check code and the encoding scheme itself was meant to be used for bitcoin addresses which are much smaller than slate payloads.</p> <p>A more robust error correction option was not chosen here because the consequences of the failure to detect an error are not as severe as they would be for a bitcoin address as further validation would need to occur for Grin. The purpose is to catch some characters being accidentally added or lost during armor transport rather than preventing a spend to an address we don't know the key to spend from.</p>"},{"location":"grin-rfcs/text/0015-slatepack/#formatting","title":"Formatting","text":"<ul> <li><code>WORD_LENGTH</code>: <code>15</code></li> <li> <p>Number of <code>SimpleBase58Check</code> encoded characters per word; chosen for human readability across device screen sizes</p> </li> <li> <p><code>LINE_BREAK</code>: <code>200</code> words</p> </li> <li> <p>Number of words of <code>WORD_LENGTH</code> to include before inserting a newline; chosen for user friendliness in terminals and messaging applications</p> </li> <li> <p><code>MAX_STRING_SIZE</code>: <code>1MB</code></p> </li> <li>Maximum size for an armored <code>SlatepackMessage</code> string without requiring a file container</li> <li>If a <code>SlatepackMessage</code> exceeds this value it must be handled as a <code>.slatepack</code> file instead of a string</li> <li>This parameter chosen to cover as many cases as possible and still be supported by most clipboards</li> </ul> <p><code>WORD_LENGTH</code> and <code>LINE_BREAK</code> parameters are adjustable as a formatting convenience. <code>MAX_STRING_SIZE</code> is fixed and cannot be exceeded without wrapping the armored <code>SlatepackMessage</code> in a <code>.slatepack</code> file.</p>"},{"location":"grin-rfcs/text/0015-slatepack/#edge-case-large-slates-1mb","title":"Edge Case: Large Slates (&gt;1MB)","text":"<p>Some slate payloads may be so large that they cannot be reliably handled across all clipboards. To handle these edge cases, a <code>SlatepackMessage</code> will be expected to be passed in a <code>.slatepack</code> file format in cases where Tor is unsuccessful and the armored <code>SlatepackMessage</code> string output would exceed 1MB. A file format was chosen as opposed to a multi-part message approach because messages are already written to file by default by grin-wallet and they are potentially simpler to handle from an implementation perspective.</p> <p>While wallets must support handling these edge cases to avoid all possible cases where a wallet cannot spend or receive a valid transaction, it would be reasonable for services and exchanges to support the Slatepack standard without the requirement of handling the rare file edge case.</p>"},{"location":"grin-rfcs/text/0015-slatepack/#example-slatepack-json-object","title":"Example Slatepack JSON Object","text":""},{"location":"grin-rfcs/text/0015-slatepack/#mode-0-plain-text","title":"Mode 0: Plain Text","text":"<p>In this plain text example, neither the sender nor the receiver wish to share a <code>SlatepackAddress</code></p> <pre><code>{\n  \"slatepack\": [1, 0],\n  \"mode\": 0,\n  \"sender\": \"0\",\n  \"payload\": &lt;binary serialized slate&gt;\n}\n</code></pre>"},{"location":"grin-rfcs/text/0015-slatepack/#mode-1-encrypted","title":"Mode 1: Encrypted","text":"<pre><code>{\n  \"slatepack\": [1, 0],\n  \"mode\": 1,\n  \"payload\": &lt;age encrypted binary: sender slatepack address + binary serialized slate&gt;,\n}\n</code></pre>"},{"location":"grin-rfcs/text/0015-slatepack/#example-slatepackmessage","title":"Example <code>SlatepackMessage</code>","text":"<pre><code>BEGINSLATEPACK. 4H1qx1wHe668tFW yC2gfL8PPd8kSgv\npcXQhyRkHbyKHZg GN75o7uWoT3dkib R2tj1fFGN2FoRLY\nGWmtgsneoXf7N4D uVWuyZSamPhfF1u AHRaYWvhF7jQvKx\nwNJAc7qmVm9JVcm NJLEw4k5BU7jY6S eb. ENDSLATEPACK.\n</code></pre>"},{"location":"grin-rfcs/text/0015-slatepack/#slatepackworkflow","title":"<code>SlatepackWorkflow</code>","text":"<p>Adoption of the Slatepack standard allows for a unified workflow that can still function without knowledge of a <code>SlatepackAddress</code> from a counterparty.</p>"},{"location":"grin-rfcs/text/0015-slatepack/#with-a-slatepackaddress","title":"With a <code>SlatepackAddress</code>","text":"<ol> <li> <p><code>grin-wallet send -d grin1p4fuklglxqsgg602hu4c4jl4aunu5tynyf4lkg96ezh3jefzpy6swshp5x 1.337</code></p> </li> <li> <p>Sender wallet derives an onion v3 address from <code>grin1p4fuklglxqsgg602hu4c4jl4aunu5tynyf4lkg96ezh3jefzpy6swshp5x</code> and attempts to complete the transaction synchronously via Tor</p> </li> <li> <p>(Fallback) If the synchronous transaction fails, a <code>SlatepackMessage</code> string is encrypted to the <code>SlatepackAddress</code> and output for manual asynchronous transport by the user</p> </li> </ol>"},{"location":"grin-rfcs/text/0015-slatepack/#without-a-slatepackaddress","title":"Without a <code>SlatepackAddress</code>","text":"<ol> <li> <p><code>grin-wallet send 1.337</code></p> </li> <li> <p>A <code>SlatepackMessage</code> string is output for manual asynchronous transport by the user</p> </li> </ol>"},{"location":"grin-rfcs/text/0015-slatepack/#with-qr-codes","title":"With QR Codes","text":"<p>A QR-based <code>SlatepackWorkflow</code> will always begin with a standard QR size because they are encoded directly from a bech32 <code>SlatepackAddress</code>.</p> <p>This encoding simultaneously provides a derivable onion address to attempt a synchronous transaction (<code>bech32 -&gt; ed25519 -&gt; onionv3</code>) and a derivable encryption key (<code>bech32 -&gt; ed25519 -&gt; x25519</code>) to return an encrypted Slatepack string to complete the transaction asynchronously as a fallback.</p> <p>As a consequence, a <code>SlatepackAddress</code> must be revealed by the party producing a QR code in the <code>SlatepackWorkflow</code>.</p> <ol> <li> <p>Receiver shares <code>SlatepackAddress</code> via QR</p> </li> <li> <p>Sender scans QR code and the transaction is completed synchronously via Tor by deriving the recipient's onion v3 address from their <code>SlatepackAddress</code></p> </li> <li> <p>(Fallback) If the synchronous transaction fails, a <code>SlatepackMessage</code> string is output for manual asynchronous transport by the user</p> </li> </ol>"},{"location":"grin-rfcs/text/0015-slatepack/#with-three-or-more-parties","title":"With Three or More Parties","text":"<p>Some possible future Slatepack transactions may require more than two parties to successfully build. These cases should not require any breaking changes to the core Slatepack standard workflow.</p> <p>The exact flow order (round-robin etc) will be defined by the accompanying RFCs that define the possible future multiple party slates themselves. In some cases, new slate versions may require (non-breaking) updates to this RFC. From there, the same standard Slatepack standard workflow of attempting to exchange the data via Tor first with an ascii armor fallback is still valid.</p> <p>For example, a future Slatepack version will add support for an array containing a <code>SlatepackAddress</code> for each party in the order desired to finish building the transaction. The wallet of each subsequent party will attempt to establish a connection with the next via Tor. In the event of a Tor failure it would be the responsibility of the most recent party to manually transport it to the next.</p> <p>In cases with many parties, the fallback method of the Slatepack standard could quickly become cumbersome if, for example, every third participant fails to achieve a Tor connection.</p>"},{"location":"grin-rfcs/text/0015-slatepack/#implementation-timeline","title":"Implementation Timeline","text":"<ol> <li>Initial Slatepack implementation introduced with the July 2020 hard fork</li> <li> <p>May or may not support encryption by default yet</p> </li> <li> <p>The proposed Slatepack standard is fully implemented and adopted as a universal transaction standard in last hard fork (Jan 2021)</p> </li> <li>Slatepack is the default transaction standard in all wallets and services</li> </ol>"},{"location":"grin-rfcs/text/0015-slatepack/#drawbacks","title":"Drawbacks","text":"<ul> <li> <p>This puts a lot of eggs in one basket (if Slatepack fails there will likely be confusion returning to old methods)</p> </li> <li> <p>This may be a bit rushed to have where we want it before HF schedule</p> </li> <li> <p>Deprecating HTTP(S) is already a major change- by requiring the adoption of this completely new standard in addition we risk putting a lot of effort on the shoulders of existing services in the Grin ecosystem</p> </li> </ul>"},{"location":"grin-rfcs/text/0015-slatepack/#rationale-and-alternatives","title":"Rationale and alternatives","text":"<ul> <li> <p>By adding new options without simplifying the workflow for users we risk confusion and friction</p> </li> <li> <p>We could just add an option for copy and pastable slates instead of introducing an entirely new universal transaction flow standard</p> </li> </ul>"},{"location":"grin-rfcs/text/0015-slatepack/#prior-art","title":"Prior art","text":"<p>Note that while previous asynchronous Mimblewimble transaction solutions require a relatively short TTL for a counterparty to successfully connect to their respective network before transactions fail (currently 72 hours for Tari DHT Network, 24 hours for Beam SBBS), Grin Slatepack transactions can remain valid indefinitely without spamming the network when using the ascii armor fallback.</p>"},{"location":"grin-rfcs/text/0015-slatepack/#tari","title":"Tari","text":"<p>Tari uses the Tari DHT Network to support asynchronous Mimblewimble transactions. This approach is comprehensive and comprises of the entire peer to peer messaging network, including both nodes and wallets. This is distinct from Slatepack which is strictly an approach to transaction building between wallet software, not general protocol messaging.</p> <p>Similar to Slatepack, Tari users derive a public key from their master seed (which is represented to users as emojis instead of bech32) and is used to look up peers in peer databases (as opposed to directly routing to a traditional Tor hidden service as in Slatepack). By default, Tari, like Slatepack, uses Tor for communication.</p> <p>While Slatepack and Tari both have addresses that decode to public keys used to find and communicate with counterparty wallets via Tor, they both handle the Tor failure case differently. Tari seems to rely on its custom DHT network to gracefully handle this at the cost of the complexity of a custom DHT layer. Slatepack falls back to an unopinionated, encrypted ascii armor string for the user to transport \"outside of the Grin network\" to complete the transaction.</p> <p>The advantage for Slatepack is significantly reduced complexity by using Tor directly with an unopinionated fallback mode. The disadvantage for Slatepack is that transactions don't \"magically\" just work if Tor communication is failing- they still require some effort from the user to transport the ascii armor themselves.</p> <p>Note that these details were taken from early documentation and not code- transactions in Tari may behave differently in practice.</p>"},{"location":"grin-rfcs/text/0015-slatepack/#beam","title":"Beam","text":"<p>Beam uses the SBBS gossip protocol to support asynchronous mimblewimble transactions. SBBS adds a nontrivial amount of complexity and attack surface to the core Beam software. In exchange, Beam receives a somewhat user-friendly mechanism for users to build transactions asynchronously. The asynchronous fallback method for Slatepack transactions is a simple ascii armor string that does not contain an opinion about a particular protocol with which to exchange the data.</p> <p>The advantage with the Slatepack method is that much less code is required to support these transactions which can improve the overall stability and security of the codebase running the Grin network. The disadvantage of this for Slatepack is that asynchronous transactions don't \"magically\" work- they still need to be between users via an outside channel (instant message, text box, email etc). Slatepack makes the tradeoff of slightly more work for the end user in exchange for a simpler and potentially more secure network for Grin.</p>"},{"location":"grin-rfcs/text/0015-slatepack/#unresolved-questions","title":"Unresolved questions","text":"<ul> <li> <p>How to handle key derivation harmoniously?</p> </li> <li> <p>What are unmentioned security considerations for using the same base key to both map to an onion address and map to an encryption key used in transactions?</p> </li> <li> <p>Related, what are unmentioned security considerations to <code>SlatepackAddress</code> reuse?</p> </li> <li> <p>Should we still use double-sha256 in <code>SimpleBase58Check</code> or take the opportunity to use a BCH or CRC code which may be more appropriate for error detection on slatepack messages?</p> </li> <li> <p>Is additional engineering desired here if there will always be further validation of the slate payload before a spend can occur?</p> </li> <li> <p>If addresses are not reused by default and since wallets need to be able to conduct multiple transactions in parallel, they need the ability to listen on all \"active\" addresses at the same time</p> </li> </ul>"},{"location":"grin-rfcs/text/0015-slatepack/#future-possibilities","title":"Future possibilities","text":"<ul> <li> <p>Extended to support future modes (payment channel, payjoin, multiple counterparties etc)</p> </li> <li> <p>An entirely different standard could be adopted in the future if non-interactive transactions become the default, eliminating the need for Slatepack</p> </li> <li>It might be possible for a new standard to remain compatible with the existing <code>SlatepackAddress</code> to allow a more generic <code>GrinAddress</code></li> </ul>"},{"location":"grin-rfcs/text/0015-slatepack/#references","title":"References","text":"<ul> <li>Bitcoin BIP173</li> <li>age - File Encryption Tool &amp; Format</li> <li>age Rust library</li> <li>Ed25519 Keys</li> <li>Ed25519 to Curve25519</li> <li>Using Ed25519 signing keys for encryption</li> <li>Armored Slates RFC</li> <li>Saltpack</li> <li>Tor v3 Specification</li> <li>Signal Docs XEdDSA</li> <li>How Tari Works</li> <li>Beam Docs SBBS</li> </ul>"},{"location":"grin-rfcs/text/0016-simplify-governance/","title":"0016 simplify-governance","text":"<ul> <li>Title: <code>simplify-governance</code></li> <li>Authors: @paouky, @lehnberg</li> <li>Start date: <code>Sep 11, 2020</code></li> <li>RFC PR: mimblewimble/grin-rfcs#67</li> </ul>"},{"location":"grin-rfcs/text/0016-simplify-governance/#summary","title":"Summary","text":"<p>This governance iteration replaces the previous process that was set out in RFC#0002 with a simplified and better-defined version. Specifically, it:</p> <ul> <li>defines its remit to be around the repos, projects, and communities that are centered around the /mimblewimble GitHub organization;</li> <li>reverts the core team to the original technocratic council structure, whose sole responsibility is managing the general fund; and</li> <li>explicitly enables individual contributors and teams to self-organize for other aspects of decision making.</li> </ul>"},{"location":"grin-rfcs/text/0016-simplify-governance/#motivation","title":"Motivation","text":"<p>RFC#0002 was an iteration on governance in response to the sudden disappearance of Ignotus Peverell, the founder of Grin. Introduced together with the RFC process as defined in RFC#0001, it served its purpose to formalize a structure for how the project would organize and make decisions. Over time however, it became clear that while the structure had its benefits, it came with its own drawbacks.</p>"},{"location":"grin-rfcs/text/0016-simplify-governance/#flaws-of-the-previous-structure","title":"Flaws of the previous structure","text":"<ol> <li>All critical decision making became centralized around the core team.</li> <li>Consensus changes</li> <li>Releases</li> <li>Spending decisions</li> <li>RFC approvals</li> <li>Project leadership</li> <li>It established a negative feedback loop for contributors:</li> <li>It created an \u201cus\u201d and \u201cthem\u201d in the community; Those on the inside (part of the core team), and those on the outside (not part of the core team).</li> <li>This in turn led to the assumption that the core team were \u201cresponsible\u201d for the project\u2019s direction and success, which fostered complacency by non-core members.</li> <li>This in turn led to more work for the core team, which made it more tolling to be a member of it, reinforcing the notion of \"us\" and \"them\" in point 1 above.</li> <li>The core team structure would either suck up or turn away contributors. Either: there were no new core team members added, which would be bad for contributor morale, and bad for the legitimacy of the structure;    Or: those that contributed the most in the community would be added, which would lead to only core team members being the strong contributors. Which in turn would reinforce the \u201cus\u201d and \u201cthem\u201d situation described above.</li> <li>Despite all the authority vested in the core team, there were no real checks and balances.</li> <li>Core team members had the right to stay for an indefinite time, there were no terms.</li> <li>Only core members could add new core members or remove existing ones.</li> <li>Community members could protest and object in case of conflict, but nothing technically would prevent the core team from going against the will of the community.</li> <li>Sub-teams had few non-core team members active. Because of the general lack of non-core engagement, it ended up being core team members filling up most of the spots in the sub-teams, defeating their purpose.</li> <li>The remit and scope of governance was left undefined. Was the process supposed to govern Grin the wider network? Or Grin the implementation under the /mimblewimble github organization? How does the grin forum and grin.mw website fit into this? There were a lot of ambiguities as to what exactly was being governed.</li> </ol>"},{"location":"grin-rfcs/text/0016-simplify-governance/#objectives-of-the-new-structure","title":"Objectives of the new structure","text":"<ol> <li>Establish a clear scope. Make it explicitly defined what the new structure applies to.</li> <li>Keep things simple. Less is more. One of Grin's design objectives is minimalism. This should be applied to its governance model, as much as anywhere else.</li> <li>Empower contributors. Make it easy for new contributors to get involved, pick up tasks, and feel responsible for some part of the project.</li> <li>Reduce centralization and single point of failure risk. Avoid having all key decisions go through a single structure.</li> </ol>"},{"location":"grin-rfcs/text/0016-simplify-governance/#community-level-explanation","title":"Community-level explanation","text":"<p>The new structure can be broken down into three areas: Scope, Teams, and Participation.</p>"},{"location":"grin-rfcs/text/0016-simplify-governance/#scope","title":"Scope","text":"<p>The explicit remit of this governance structure is defined as all the repos that are organized under the GitHub organization /mimblewimble along with its existing and future communities and websites. This will be referred to as \"the Project\" below for clarity purposes, which include among other:</p> <ul> <li>/grin, /grin-wallet, and /grin-miner</li> <li>/grin-pm, /grin-rfcs, and /grin-security</li> <li>https://grin.mw</li> <li>https://docs.grin.mw</li> <li>https://forum.grin.mw</li> <li>keybase @grincoin team</li> <li>Mimblewimble mailing list</li> <li>Grin General Fund</li> </ul>"},{"location":"grin-rfcs/text/0016-simplify-governance/#teams","title":"Teams","text":"<p>There is no hierarchical organization, and there is no \"official\" representative or group of representatives of the Project. Teams form and self-organize based on need. Teams are any group that carry out specific tasks or have specific responsibilities or have privileged access to tools or services related to the Project. They are responsible for their own processes and policies.</p>"},{"location":"grin-rfcs/text/0016-simplify-governance/#technocratic-council","title":"Technocratic Council","text":"<p>The Core Team as per RFC#0002 is removed. The existing members form the team that was known as the Technocratic Council prior to RFC#0002. The main purpose of the council is to manage the keys to the Grin General Fund and have final say in spending decisions. The technocratic council does not have a say in the matters of other teams.</p>"},{"location":"grin-rfcs/text/0016-simplify-governance/#other-teams","title":"Other teams","text":"<p>Examples of existing teams with various degree of organization that are seamlessly transitioned into their own autonomous structures include:</p> <ul> <li>node development team</li> <li>wallet dev team</li> <li>security team</li> <li>forum, keybase, and mailing list admins and moderators</li> </ul>"},{"location":"grin-rfcs/text/0016-simplify-governance/#participation","title":"Participation","text":"<ul> <li>Each team is responsible for how to add or remove team members. Where practical, open and unrestricted participation is encouraged.</li> <li>As much as possible of discussion and team organization should be made in public. Note-keeping is encouraged to make it easier for newcomers to get up to speed.</li> <li>As with any other aspect of the Project, contributors are required to adhere to the Code of Conduct.</li> </ul>"},{"location":"grin-rfcs/text/0016-simplify-governance/#reference-level-explanation","title":"Reference-level explanation","text":"<p>This section covers some of the more technical details\u00a0of the process.</p>"},{"location":"grin-rfcs/text/0016-simplify-governance/#naming","title":"Naming","text":"<p>Where there needs to be clarification between Grin (the implementation in /mimblewimble/grin), and Grin (the wider network consensus running any number of different implementations), it is suggested that existing conventions are followed and the former is referred to by the user agent name <code>MW/Grin</code> or <code>mw/grin</code>.</p>"},{"location":"grin-rfcs/text/0016-simplify-governance/#rfc-process","title":"RFC process","text":"<p>The RFC process as defined in RFC#0001 remains unchanged, and is how \"significant changes\" are proposed. Teams can assign RFCs to themselves if RFCs relate to their areas. Other community members are free to opine on proposals.</p>"},{"location":"grin-rfcs/text/0016-simplify-governance/#funding","title":"Funding","text":"<p>The funding process remains as described in RFC#0014: General Fund Guidelines, with the difference that it is the Technocratic Council who now has final say on spending decisions.</p>"},{"location":"grin-rfcs/text/0016-simplify-governance/#consensus-breaking-changes","title":"Consensus-breaking changes","text":"<p>Network wide consensus rules are out of scope of this process. Significant changes to mw/grin are introduced via the existing RFC process.</p>"},{"location":"grin-rfcs/text/0016-simplify-governance/#disagreements-dissent","title":"Disagreements / Dissent","text":"<ul> <li>Teams are expected to resolve their internal disputes to the best of their abilities.</li> <li>Dysfunctional teams are replaced by forming new teams and contributors are encouraged to migrate over.</li> <li>Where there is disagreement between teams, other teams and community members can be asked to mediate.</li> </ul>"},{"location":"grin-rfcs/text/0016-simplify-governance/#drawbacks","title":"Drawbacks","text":"<ul> <li>Lack of final decision-making authority. With no clear decision-making process to fall back on in case of major disagreements, a community split, and therefore a network fork, becomes more likely.</li> <li>Hierarchy is still present, but no longer as visible. There are still some contributors with decision making authority, and some without. Before, this was codified explicitly. Now this is subtle and fluid.</li> <li>Tasks may fall in between cracks easier. Without a team with ultimate responsibility picking up slack, some things might simply not get done and progress may slow.</li> <li>Lack of contributors may lead to the same people in charge everywhere. Similar to the previous structure, if there are not enough new contributors joining, it ends up being the same people occupying all the different positions.</li> </ul>"},{"location":"grin-rfcs/text/0016-simplify-governance/#rationale-and-alternatives","title":"Rationale and alternatives","text":"<p>A forum post on forum.grin.mw solicited ideas for alternatives to the previous structure. Some of those included:</p> <ul> <li>Establishing different teams being responsible for funds, code repos, and direction;</li> <li>Separating consensus protocol decisions from repository decisions;</li> <li>Spending the General Fund more aggressively in order to try out new directions and ideas;</li> <li>Simplifying or removing the RFC process altogether; and</li> <li>Creating a \"House of Representatives\" to balance out the powers of the Core team.</li> </ul> <p>Additional options include:</p> <ul> <li>Doing nothing; and</li> <li>Attempting to establish a governance process that involves the entire network, current (and future?) implementations.</li> </ul> <p>The rationale for pursuing the specific approach that is outlined in this RFC is because it:</p> <ul> <li>Establishes a scope for the process, which is contained and well defined;</li> <li>Simplifies the structure significantly compared to what was before;</li> <li>Has been tried in the past in the project, with some success;</li> <li>Can be implemented easily, and does not carry much migration risk;</li> <li>Can easily be evolved further by introducing new structures and processes if and when those are mandated; and</li> <li>Is not likely to leave the project significantly worse off than before.</li> </ul>"},{"location":"grin-rfcs/text/0016-simplify-governance/#prior-art","title":"Prior art","text":"<p>This replaces RFC#0002 with something closer to the governance process that was in place earlier in the project's life cycle.</p>"},{"location":"grin-rfcs/text/0016-simplify-governance/#unresolved-questions","title":"Unresolved questions","text":"<ul> <li>What is the governance process between different implementations?</li> <li>How can the funds and\u00a0the spending decisions of the General Fund become more decentralized, removing the function of the Technocratic Council?</li> <li>How can commit rights to the Project repos be formalized better?</li> </ul>"},{"location":"grin-rfcs/text/0016-simplify-governance/#future-possibilities","title":"Future possibilities","text":"<ul> <li>Should we stop accepting donations to addresses controlled by a single entity?</li> </ul>"},{"location":"grin-rfcs/text/0016-simplify-governance/#references","title":"References","text":"<ul> <li>RFC#0002: grin-governance</li> <li>RFC#0001: rfc-process</li> <li>/mimblewimble GitHub organization: https://github.com/mimblewimble</li> <li>https://forum.grin.mw/t/dismantling-the-core-team-and-governance-structure/</li> </ul>"},{"location":"grin-rfcs/text/0017-fix-fees/","title":"0017 fix-fees","text":"<ul> <li>Title: fix-fees</li> <li>Authors: John Tromp</li> <li>Start date: August 23, 2020</li> <li>RFC PR: mimblewimble/grin-rfcs#63</li> <li>Tracking issue: mimblewimble/grin/issues/3459</li> </ul>"},{"location":"grin-rfcs/text/0017-fix-fees/#summary","title":"Summary","text":"<p>Change Grin's minimum relay fees to be weight proportional and make output creation cost about a Grin-cent. Restrict fees to 40 bits, using 4 of the freed up 24 bits to specify the desired tx priority, and leaving the remaining 20 bits for future use. NOTE: this is a hard-forking change.</p>"},{"location":"grin-rfcs/text/0017-fix-fees/#motivation","title":"Motivation","text":"<p>The former fee requirements suffer from being somewhat arbitrary, and not miner incentive compatible. They are not even linear; to avoid a negative minimum fee, they are rounded up to <code>BASE_FEE</code>. As a consequence, the minimum fees for the aggregate of two transactions was not necessarily equal to the sum of the individual ones. Worse, a miner had no incentive to include a transaction that pays 0 fees, while they take resources to relay. The current (and foreseeable) low price of Grin makes spamming the UTXO set rather cheaper than desired. Fee overpaying, for higher priority to be included in full blocks, fails when aggregated with minimal fee transactions.</p>"},{"location":"grin-rfcs/text/0017-fix-fees/#community-level-explanation","title":"Community-level explanation","text":"<p>For clarity, let's adopt the following definitions. Let the feerate of a transaction be the fees paid by the transaction divided by the transaction weight with regards to block inclusion (<code>Transaction::weight_as_block</code>). Let the <code>minfee</code> of a transaction be the amount of fees required for relay and mempool inclusion. A transaction paying at least <code>minfee</code> in fees is said to be relayable.</p> <p>Grin constrains the size of blocks by a maximum block weight, which is a linear combination of the number of inputs, outputs, and kernels.  When blocks fill up, miners are incentivized to pick transactions in decreasing order of feerate. Ideally then, higher feerate transactions are more relayable than lower feerate ones. Having a lower feerate transaction be relayable while a higher feerate transaction is not is very much undesirable and a recipe for problems in a congested network.</p> <p>The only way to avoid this mismatch between relay and block inclusion incentives is to make the minimum relay fee be proportional to the block weight of the transaction. This leaves only the constant of proportionality to be decided. We can calibrate the fee system by stipulating that creating one output should cost at least one Grin-cent (formerly 0.4 Grin-cent).</p> <p>We want minfee to be linear to make splitting and combining of fees well-behaved. For instance, two parties in a payjoin may each want pay their own input and output fees, while splitting the kernel fee, without overpaying for the whole transaction.</p> <p>Only the least significant 40 bits will be used to specify a fee, while some of the remaining bits will specify a minimum fee overpayment factor as a power-of-2, preventing aggregation with lesser overpaying transactions, and earlier inclusion into full blocks.</p> <p>The largest possible 40-bit fee is 2^40 - 1 nanogrin, or approximately 1099.5 grin, which should be more than enough to guarantee inclusion in the next available block. Technically speaking, transactions can pay higher fees by having multiple kernels, but we still want to avoid that kind of friction. As a side effect, this limits the damage of fat fingering a manually entered fee amount.</p>"},{"location":"grin-rfcs/text/0017-fix-fees/#reference-level-explanation","title":"Reference-level explanation","text":"<p>The minimum relay fee of a transaction shall be proportional to <code>Transaction::weight_as_block</code>, which uses weights of <code>BLOCK_INPUT_WEIGHT</code> = 1, <code>BLOCK_OUTPUT_WEIGHT</code> = 21, and <code>BLOCK_KERNEL_WEIGHT</code> = 3, which correspond to the nearest multiple of 32 bytes that it takes to serialize. Formerly, we used <code>Transaction::weight</code>, which uses arbitrary weights of -1, 4, and 1 respectively, but also non-linearly rounds negative results up to 1 (as happens when the number of inputs exceeds the number of kernels plus 4 times the number of outputs).</p> <p>The <code>Transaction::weight_as_block</code> shall be multiplied by a base fee. This will not be hardcoded, but configurable in grin-server.toml, using the already present <code>accept_fee_base</code> parameter. There is no reason to use different fees for relay and mempool acceptance. Its value shall default to <code>GRIN_BASE</code> / 100 / 20 = 500000, which makes each output incur just over 1 Grin-cent in fees.</p> <p>The 64-bit fee field in kernel types <code>Plain</code> and <code>HeightLocked</code> shall be renamed to <code>fee_bits</code> and be composed of bitfields { <code>future_use</code>: 20, <code>fee_shift</code>: 4, fee: 40 }. All former uses of the fee will use <code>fee_bits</code> &amp; <code>FEE_MASK</code>, where <code>FEE_MASK = 0xffffffffff</code>.</p> <p>A nonzero fee shift places an additional restriction on transaction relay and mempool inclusion. Namely, a transaction containining a kernel with <code>fee_shift = s</code> must pay a total fee of at least 2^s times the minfee (the minfee shifted left by <code>fee_shift</code>).</p> <p>Aggregation of two relayable transactions should only happen when the result remains relayable. By linearity, this is always the case for two transactions with identical fee shift. Transactions with differing fee shift can be aggregated only if either one pays more than required by their fee shift.</p> <p>For instance, suppose two transactions have the same minfee. If one pays 3 times the minfee with a fee shift of 1, while the other pays exactly minfee with a zero fee shift, then both can be aggregated into one that pays twice the joint minfee (which is double the old one).</p> <p>While a transaction can choose an arbitrarily high feerate to incentivize early inclusion into full blocks, the fee shift provides for 16 different levels of protection against feerate dilution (through transaction aggregation).</p> <p>The new tx relay rules and new fee computation in wallets shall take effect at the HF4 block height of 1048320 (but see below about alternatives for 3rd party wallets).</p> <p>The 20 bits of <code>future_use bits</code> provide a possible soft-forking mechanism. We can imagine a future soft-fork further constraining the validity of kernels, or the relayability of transactions containing them, depending on the value of some of these bits.</p>"},{"location":"grin-rfcs/text/0017-fix-fees/#drawbacks","title":"Drawbacks","text":"<p>Leaving 20 bits of <code>future_use</code> increases the amount of zero cost zero friction spam that can be added to the chain.  However, we already have a similar amount of spammable bits in the lock height of HeightLocked kernels, where any lock height under the current height of around a million has no effect. So this appears to be an acceptable increase.</p> <p>At the time of writing, only one other perceived drawback could be identified, which is what motivated the former fee rules. A negative weight on inputs was supposed to encourage spending many outputs, and lead to a reduction in UTXO size. But this aligned poorly with miner incentives, as for instance they have no economic reason to include zero fee transactions. A positive weight on inputs is no serious drawback, as long as creation of outputs is more strongly discouraged. Most wallets, especially those relying on payjoins, do about equal amounts of output creation and spending, the difference being just the wallet's UTXO set.  Mining pools are the major exception. While they obviously don't incur any fees in coinbase creation, they need not spend fees on spending them either, as they can mine these payout transactions directly.</p>"},{"location":"grin-rfcs/text/0017-fix-fees/#rationale-and-alternatives","title":"Rationale and alternatives","text":"<p>There are no good alternative to economically significant fees. Any blockchain lacking them is an open invitation to abuse. For chains with a maximum blocksize, fees are also necessary to allow prioritization of transactions.</p> <p>There is a small window prior to HF4 where transactions constructed using the former lower won't be finalized before HF4 and will thus fail to be relayed. Third party wallets are free to switch fee computation some arbitrary time before HF4 to minimize this risk.</p> <p>Instead of a fee shift, one could specify a fee factor. So then a transaction containing a kernel with the <code>fee_factor</code> bitfield having value f would require total fees of at least f+1 times minfee (preserving old behaviour for a 0 bitfield). A reasonable overpayment range would then require 8 bits instead of the 4 used for fee shift, and would create 256 levels of priority. It does seem wasteful though, to allow a distinction between, say, overpaying by 128 times, or by 129 times. Worse still, that many priority levels will severely reduce the potential for aggregation when blocks fill up. To maximize aggregation opportunities then, forcing priority levels to be a factor of 2 apart seems quite reasonable.</p> <p>We can avoid a consensus change by keeping the fee at the full 64 bits, instead using its least significant 4 bits to specify a fee shift. This only makes sense if we never plan to make any use of the top 24 bits, which would always be forced to 0 unless someone pays a monstrous fee, most likely by accident. It would also lead to balances that are no longer a multiple of a milligrin, making for slightly worse UX.</p>"},{"location":"grin-rfcs/text/0017-fix-fees/#prior-art","title":"Prior art","text":"<p>Several chains have suffered spam attacks. In early days, bitcoin was swamped with feeless wagers on Satoshi Dice [1]. At least those served some purpose.</p> <p>Nano was under a deluge of meaningless 0-value back and forth transfers for weeks, that added dozens of GB of redundant bloat to its chain data [2]. Although nano requires client PoW as a substitute for fees, these attacks showed that the PoW was poorly calibrated and not an effective deterrant.</p>"},{"location":"grin-rfcs/text/0017-fix-fees/#unresolved-questions","title":"Unresolved questions","text":""},{"location":"grin-rfcs/text/0017-fix-fees/#future-possibilities","title":"Future possibilities","text":"<p>While the input and kernel weights are pretty fixed, the output weight is subject to improvements in range proof technology. If Grin implements BP+, the weight should go down from 21 to 18. That would make outputs incur slightly less than a Grin-cent in fees, which is not worth bothering with. If range proofs were to halve in size though, then we might want to double the base fee to compensate.</p> <p>If Grin ever becomes worth many dollars, then a lowering of fees is desirable. This can then be achieved by getting the majority of running nodes to reconfigure their base fee to a lower value, after which wallets can have their fee computation adjusted. In the converse case, where Grin becomes worth only a few cents, then an increase in fees might be needed to avoid spam. Both cases will be much easier to deal with if they coincide with a hard fork, but those may not be on the horizon.</p>"},{"location":"grin-rfcs/text/0017-fix-fees/#references","title":"References","text":"<p>[1] Satoshi Dice</p> <p>[2] Nano github</p>"},{"location":"grin-rfcs/text/0018-fix-daa/","title":"0018 fix-daa","text":"<ul> <li>Title: fix-daa</li> <li>Authors: John Tromp</li> <li>Start date: July 23, 2020</li> <li>RFC PR: mimblewimble/grin-rfcs#61 </li> <li>Tracking issue: mimblewimble/grin#3473</li> </ul>"},{"location":"grin-rfcs/text/0018-fix-daa/#summary","title":"Summary","text":"<p>Change Grin's DAA (Difficulty Adjustment Algorithm) from the current damped simple moving average (dsma) to a weighted-target exponential moving average (wtema). Also, restrict the future-time-limit (FTL) window to 5 minutes.</p>"},{"location":"grin-rfcs/text/0018-fix-daa/#motivation","title":"Motivation","text":"<p>The current DAA suffers from oscillatory behaviour, and also requires keeping the last 60 block on hand. wtema is simpler to state, requires only the last 2 blocks, and fixes the oscillatory behaviour. The current FTL window of 12 minutes appears rather arbitrary. It matches the 2-hour window used in bitcoin when expressed in their respective blocktimes, but we prefer a more natural amount in terms of clock time.</p>"},{"location":"grin-rfcs/text/0018-fix-daa/#community-level-explanation","title":"Community-level explanation","text":"<p>Grin aims for a 1 minute average block time. Thus, if the last block took exactly 1 minute to solve, then network difficulty remains the same in Grin's DAA.  If it took 2 minutes to solve, then network difficulty should be decreased. But only by a small percentage. Halving network difficulty would make it way too erratic.  Similarly, if the last block took less than a minute to solve, then network difficulty should be increased a little. Grin's DAA uses a simple formula to express the factor by which to change network difficulty, in terms of the ratio of last block time to ideal block time.</p> <p>A future-time-limit of 5 minutes naturally corresponds to the hour markers on a clock. The trade-off for FTL is between impact of timestamp manipulation and risk of divergence between local and actual clock time. For properly configured systems (e.g. correct time-zone and daylight-savings-time settings) we expect drifts of several minutes to be quite noticeable, and likely to be corrected by operators.</p>"},{"location":"grin-rfcs/text/0018-fix-daa/#reference-level-explanation","title":"Reference-level explanation","text":"<p>In wtema-M, the factor by which to lower network difficulty after every block is 1 + (t/T - 1) / M, where T is the ideal block time of 60 seconds, t is the last block time in seconds, and M is a mean life time.  Grin requires strictly increasing timestamps in consecutive blocks, so t &gt; 0. In M blocks, the difficulty can thus be increased by at most (1-1/M)^-M ~ e.</p> <p>The maximum allowed clock drift (FTL parameter) is to be 5 minutes; blocks whose timestamp exceeds the local time by more than 5 minutes are ignored and not relayed. This parameter is not hardcoded but to be specified in grin-server.toml</p>"},{"location":"grin-rfcs/text/0018-fix-daa/#drawbacks","title":"Drawbacks","text":"<p>At the time of writing, the only apparent drawback is that using the difference of consecutive timestamps makes the DAA more susceptible to timestamp manipulation. To quantify the effect of this, let's say that miners maximally misrepresent m typical consecutive block times as one m-minute block + m-1 instant blocks. Instead of keeping network difficulty constant, this would divide it by (1+(m-1)/M) * (1-1/M)^m. For m much smaller than M, and M &gt; 100, this is only a tiny increase in difficulty. If m is as large as k*M+1 then this is (approximately) dividing by (1+k)/e^k, i.e. multiplying by e^k/(1+k). This is not something that miners should be interested in doing, as they generally want to maximize rewards by minimizing difficulty, so this kind of timestamp manipulation seems unlikely. On the other hand, they have a small incentive to misrepresent block times as being more regular (closer to T) than they really are, since for m blocks taking a total time of m*T, setting timestamps exactly 1 minute apart minimizes the new difficulty. For instance, reporting a 30-second block and a 90-second block as two 1-minute blocks, changes the adjustment factor from (1-1/2M)(1+1/2M) = 1-1/4M^2 to 1, which for M &gt; 100 is pretty negligible, indistinguishable from noise among realistic graphrate fluctuations.</p> <p>The risk of NTP (Network Time Protocol) based local clocks diverging by more than 5 minutes is somewhat larger than with a 12 minute threshold.</p>"},{"location":"grin-rfcs/text/0018-fix-daa/#rationale-and-alternatives","title":"Rationale and alternatives","text":"<p>The simplest fix to the current DAA to reduce the problem of oscillations is to increase the damping factor. The reason Grin went with a small damping factor was to make the DAA very responsive to changes in graphrate. This responsiveness will suffer from increasing the damping factor. It makes sense to consider changing not just a parameter in the current DAA, but the DAA altogether, as alternatives may offer better trade-offs between stability and responsiveness. They may also achieve greater overall simplicity, both conceptually and in implementation.</p> <p>An FTL window of 1 minute, matching the blocktime, was considered as being the least arbitrary, and also leaving little room for timestamp manipulation. However, some worries remained that NTP is not robust enough to practically guarantee sub-minute drift even for properly configured systems.</p>"},{"location":"grin-rfcs/text/0018-fix-daa/#prior-art","title":"Prior art","text":"<p>The current DAA in Bitcoin Cash suffers from the same oscillatory behaviour that Grin's DAA does. Which is what led various BCH developers to do extensive research on possible alternatives [1] [2]. They identified two DAAs as being superior to others. These two, wtema, and asert, also happen to behave nearly identically. While wtema is simpler in that it doesn't need exponentiation, it would need special safeguards to robustly deal with the possibility of very negative solvetimes. Since Grin requires strictly increasing timestamps, it doesn't need any such safeguards, making wtema the preferred choice for Grin.</p> <p>Before adding a dependence on number of parent uncles, Ethereum uses a DAA that can be seen as a close approximation of wtema: After every block, increase network difficulty by a factor of 1 - (t/T - 1) / M. Comparing with wtema above, we see that instead of dividing by (1+x), they multiply by (1-x). Even though Ethereum, like Grin, enforces positive solvetimes, they still need to guard against division by 0 in this form.</p>"},{"location":"grin-rfcs/text/0018-fix-daa/#unresolved-questions","title":"Unresolved questions","text":"<p>While this RFC argues for adopting wtema as a new DAA, it doesn't want to argue for a specific value of the half life M. In Grin tradition, an integral number of hours is preferable, to limit arbitrariness. Either 2 hours, 3 hours, or 4 hours, all offer a resonable balance of responsiveness and stability. These 3 choices as well as Grin's current DAA with various damping factor choices are implemented at [3], which allows for easy comparison across many scenarios.</p>"},{"location":"grin-rfcs/text/0018-fix-daa/#future-possibilities","title":"Future possibilities","text":"<p>Although Grin graphrate has been relatively stable throughout its short history, as a GPU mineable coin available at nicehash, it's always at risk of sudden temporary surges in graphrate, to which it should be able to respond quickly. The current DAA does that, but at a cost (of oscillatory behaviour). In a future where Grin mining is dominated by Cuckatoo32 ASICs and where Grin is the C32 coin with the largest daily issuance,  the graphrate should be naturally stable, with the need for responsiveness lessened. We should however account for the possibility of other coins adopting Cuckatoo32 as well. If, like most coins, they opt for a finite supply, then in initial years they may well have a daily issuance exceeding that of Grin. That would put us in the same situation as Bitcoin Cash competing with Bitcoin for ASIC hashrate. Having such a well vetted DAA will be a reassurance for years to come.</p> <p>Future improvements in network clock synchronization might make a reduction of FTL down to one minute viable.</p>"},{"location":"grin-rfcs/text/0018-fix-daa/#references","title":"References","text":"<p>[1] archive.org</p> <p>[2] read.cash</p> <p>[3] (tromp github)https://github.com/tromp/difficulty</p>"},{"location":"grin-rfcs/text/0019-deprecate-http-tx/","title":"0019 deprecate-http-tx","text":"<ul> <li>Title: Deprecate HTTP(S) Transactions</li> <li>Authors: joltz</li> <li>Start date: April 28 2020</li> <li>RFC PR: mimblewimble/grin-rfcs#54</li> <li>Tracking issue: mimblewimble/grin-wallet#523</li> </ul>"},{"location":"grin-rfcs/text/0019-deprecate-http-tx/#summary","title":"Summary","text":"<p>Deprecating HTTP(S) as a transaction method helps preserve privacy for Grin users during the slate exchange process while building transactions. By only allowing the http listener in <code>grin-wallet</code> to listen on localhost by default, users and services will be encouraged to use more privacy-friendly transaction methods like Tor or directly exchanging armored slates via the Slatepack standard. This improves privacy for the Grin ecosystem by ensuring that services do not force Grin users into transaction methods that can easily violate their privacy like HTTP(S).</p>"},{"location":"grin-rfcs/text/0019-deprecate-http-tx/#motivation","title":"Motivation","text":"<p>Previously, Grin slates could be exchanged over HTTP(S) as a convenient method to take the required steps to exchange slate data between wallets to build a transaction. This method was commonly adopted by exchanges and services who already had infrastructure in place to configure wallets to listen for incoming HTTPS requests.</p> <p>Unfortunately, while convenient, this method of exchange requires the sender and receiver to reveal their IP addresses to route the network packets. This is bad for user privacy because without taking extra obfuscating steps, an IP address can often be traced to an individual.</p> <p>While steps can be taken to obfuscate a users true IP (like using a VPN), it is undesirable for a privacy-preserving technology like Grin to rely on this method for conventional use. It does not seem natural for users that are concerned about their privacy enough to use a technology like Grin to at the same time accept that their IP address is revealed when exchanging Grin with many services.</p> <p>Deprecating HTTP(S) provides a few benefits:   - User experience is improved by not having to manage firewall settings like port forwarding to accept Grin transactions from most users   - Wallet developer experience is improved with the need to support fewer transaction methods   - Users will no longer be encouraged to engage in transaction methods that potentially violate privacy during the transaction building process   - The ecosystem can converge around a universally accepted transaction flow that is privacy preserving</p> <p>The overall expected outcome is a privacy improvement for users that may otherwise have to reveal their IP address to send or receive Grin.</p>"},{"location":"grin-rfcs/text/0019-deprecate-http-tx/#community-level-explanation","title":"Community-level explanation","text":"<p>Deprecating HTTP(S) means that the old method of sending and listening for transactions over traditional HTTP(S) is no longer supported to help preserve privacy for Grin users who may not be aware of the risk to privacy using HTTP(S) poses.</p> <p>This reduces the overall number of transaction transport methods that need to be supported but requires that all services and wallets that previously only accepted/sent HTTP(S) transactions to upgrade at least to the version this RFC is implemented in to support their users.</p> <p>For the average user this means that to send or receive Grin they can use the Slatepack method. It is no longer possible to send and receive Grin via the HTTP(S) method without custom configuration.</p> <p>For wallet developers, it is no longer necessary to be concerned about managing HTTP(S) endpoints. All transactions will be conducted via Tor or asynchronous exchange of armored slate strings with the Slatepack standard. It can no longer be assumed that the counterparty in the transaction supports HTTP(S).</p> <p>Previously, some services like exchanges only supported HTTP(S) Grin transactions. This change impacts these services significantly.</p> <p>Slatepack with Tor is the closest replacement to HTTP(S), but for some services the use of Tor is unacceptable, not possible or not allowed. These services will will need to refactor the user flow to allow supporting manual copying and pasting of Slatepack armored transaction messages instead, as the HTTP(S) method is no longer supported for <code>grin-wallet</code>.</p>"},{"location":"grin-rfcs/text/0019-deprecate-http-tx/#reference-level-explanation","title":"Reference-level explanation","text":"<p>The technical and implementation details for this RFC are simple: no new features are added and some existing features are restricted:</p> <ul> <li> <p><code>grin-wallet</code> http listener only accepts connections from localhost</p> </li> <li> <p><code>grin-wallet listen</code> no longer accepts <code>-e</code> argument</p> </li> <li> <p><code>grin-wallet send -d</code> requires a valid Slatepack address</p> </li> </ul>"},{"location":"grin-rfcs/text/0019-deprecate-http-tx/#deprecation-timeline","title":"Deprecation Timeline","text":"<ul> <li> <p>With v4.0.0 a public announcement will be made to notify the Grin ecosystem that HTTP(S) will be fully deprecated in v5.0.0</p> </li> <li> <p>With v4.0.0 wallets will warn users that their privacy may be at risk when sending or listening via HTTP(S) and that the method will be deprecated in next major release</p> </li> <li> <p>With v5.0.0 wallets will no longer support sending transactions via HTTP(S)</p> </li> <li> <p>With v5.0.0 wallets will only accept connections from localhost by default.</p> </li> </ul>"},{"location":"grin-rfcs/text/0019-deprecate-http-tx/#drawbacks","title":"Drawbacks","text":"<ul> <li> <p>Forces changes to existing transaction building workflows that use HTTP(S)</p> </li> <li> <p>Remaining transaction options (Slatepack via Tor and armored message) may not be appealing for services already exclusively using HTTP(S)</p> </li> <li> <p>Forces \"always on\" wallet listeners to use Tor or to build out logic to support handling armored slates in the UX flow</p> </li> <li> <p>Potentially makes a technology that is already challenging for services to adopt even more challenging to adopt</p> </li> <li> <p>Those that do not value privacy as a first-order objective may see this as an unnecessary inconvenience</p> </li> <li> <p>Friction could cause some services to avoid Grin completely rather than adding support for a new transaction method</p> </li> </ul>"},{"location":"grin-rfcs/text/0019-deprecate-http-tx/#rationale-and-alternatives","title":"Rationale and alternatives","text":"<p>By not deprecating HTTP(S) an opportunity is lost to provide an additional layer of privacy to present and future Grin supporters.</p> <p>Deprecating HTTP only while continuing to support HTTPS would not likely be viable. As currently implemented, removing HTTP support would also mean removing HTTPS support. Allowing HTTPS while blocking HTTP may beyond the scope of <code>grin-wallet</code> configuration.</p>"},{"location":"grin-rfcs/text/0019-deprecate-http-tx/#prior-art","title":"Prior art","text":"<p>A general comparison of transaction methods for Grin is available and provides many considerations when weighing possible transaction methods, including HTTP(S).</p> <p>Bitcoin previously used a similar transaction method (send to IP) which was deprecated as well for many valid reasons. While the arguments presented in this RFC are primarily derived from the objective of delivering privacy, there are other good reasons previously discussed in the context of Bitcoin. These discussions can be found partially in the bitcointalk post accompanying the PR that removed this feature for Bitcoin.</p> <p>Note that Grin is not quite in the same position as Bitcoin was when they deprecated this method as an alternative method existed that did not require interaction was available (P2PKH). Grin will still require interaction for the foreseeable future, either directly via Tor or asynchronously via Slatepack armored messages.</p>"},{"location":"grin-rfcs/text/0019-deprecate-http-tx/#unresolved-questions","title":"Unresolved questions","text":"<ul> <li> <p>Is it acceptable to the ecosystem to remove a commonly used transaction method?</p> </li> <li> <p>Will the adoption of this RFC cause an unacceptable loss of support from existing adopting services?</p> </li> <li> <p>Will deprecating HTTP(S) grow or reduce adoption in the next 6-12 months? 1-3 years? 5-10 years?</p> </li> </ul>"},{"location":"grin-rfcs/text/0019-deprecate-http-tx/#future-possibilities","title":"Future possibilities","text":"<p>This RFC along with others can eventually support ecosystem convergence around a single acceptable transaction building workflow supported by all wallets and services.</p>"},{"location":"grin-rfcs/text/0019-deprecate-http-tx/#references","title":"References","text":"<p>https://bitcointalk.org/index.php?topic=9334.0</p> <p>https://github.com/bitcoin/bitcoin/pull/253</p> <p>https://github.com/mimblewimble/grin-pm/issues/283</p> <p>https://github.com/mimblewimble/grin-rfcs/blob/master/text/0015-slatepack.md</p>"},{"location":"grin-rfcs/text/0020-pibd-messages/","title":"0020 pibd messages","text":"<ul> <li>Title: pibd-messages</li> <li>Authors: Jasper van der Maarel, Antioch Peverell</li> <li>Start date: September 14, 2020</li> <li>RFC PR: mimblewimble/grin-rfcs#68 </li> <li>Tracking issue: mimblewimble/grin#68</li> </ul>"},{"location":"grin-rfcs/text/0020-pibd-messages/#summary","title":"Summary","text":"<p>This RFC defines new peer-to-peer messages that are required to enable a novel sync method. This method reduces node bootstrapping time and increases overall robustness of the sync process. It introduces the concept of \"segments\", which are packets of self-contained partial state that can be downloaded and verified independently from each other. After downloading all segments and performing some additional verification steps, the full state can be reconstructed. </p>"},{"location":"grin-rfcs/text/0020-pibd-messages/#motivation","title":"Motivation","text":"<p>In Grin, the state of the chain at a certain block is defined by the set of all historical kernels, the unspent outputs and the corresponding rangeproofs. This state is stored in four distinct (Prunable) Merkle Mountain Ranges ((P)MMRs): the output bitmap MMR, the output PMMR, the rangeproof PMMR and the kernel MMR. In the old sync process, all of this data was packaged in a single zip file and downloaded from a single peer. The incoming data could only be verified after the full zip file had been downloaded. Because of the reliance on a single peer at a time, it is bottlenecked by the upload bandwidth of that peer. It is also a single point of failure. Any corrupted data or connection interruption potentially wastes a lot of time, as the download has to be started from scratch from another peer.</p> <p>Using the eight new peer-to-peer messages introduced in this RFC, we no longer have to rely on the download of the txhashset.zip file. Instead, bootstrapping nodes can download segments of the MMRs simultaneously from multiple peers and use them to reconstruct the full state. Malicious peers are detected quickly by virtue of each segment being independently verifiable.</p>"},{"location":"grin-rfcs/text/0020-pibd-messages/#community-level-explanation","title":"Community-level explanation","text":"<p>As previously mentioned, the chainstate at a certain block is represented by the four MMRs. The PMMR [1] is a datastructure similar to a Merkle tree, which allows us to efficiently prove membership of an element inside the tree.</p> <p>It allows us to calculate a single hash representing the entire dataset: the root. The block header stores the roots of the different MMRs, committing to the state at that point in time.</p> <p>The peer-to-peer messages introduced in this RFC enable us to split the MMRs up into segments. Each of those segments contains a subset of the MMR data, accompanied with a membership proof in the MMR. The proof allows us to recalculate the MMR root using the segment data. If the MMR root matches the hash committed to in the block header, the segment is valid.</p> <p>Bootstrapping nodes will download all segments of the four MMRs in parallel and reconstruct the full MMR from them. After some additional verification steps the new state is accepted and the node is synced.</p>"},{"location":"grin-rfcs/text/0020-pibd-messages/#reference-level-explanation","title":"Reference-level explanation","text":"<p>This RFC introduces the concept of MMR segments, which are subtrees of the full MMR, along with hashes of pruned subtrees and a Merkle proof. For each of the four relevant (P)MMRs (output bitmap, output, rangeproof and kernel) we create 2 new peer-to-peer messages: a request and a response.</p> <p>Clients can signify support for segment requests by signaling it in their capabilities using a new bit flag: <code>PIBD_HIST = 1 &lt;&lt; 4</code>.</p> <p>The reference implementation for this RFC can be found in [3-6].</p>"},{"location":"grin-rfcs/text/0020-pibd-messages/#mmr-segments","title":"MMR segments","text":"<p>We define a (P)MMR segment at segment height <code>h</code> as a set of <code>N = 2^h</code> consecutive leaves, along with the necessary data to verify membership of the leaves in the original MMR. Each segment is consecutive with the previous and is identified by the tuple <code>(H, h, i)</code> where <code>H</code> is the block hash, <code>h</code> is the segment \"height\" and <code>i</code> is a zero-based segment index: segment <code>(H, h, i)</code> contains the non-pruned leaves with leaf position in the interval <code>[i*N, (i+1)*N)</code> of the MMR state at the block with hash <code>H</code>. The final segment is allowed to have less than <code>N</code> elements because the full MMR does not necessarily contain a multiple of <code>N</code> leaves.</p> <p>Concretely, a segment contains the following items: - The identifier tuple <code>(H, h, i)</code>. - List of MMR positions and corresponding list of intermediary hashes, sorted by MMR position in ascending order. At a minimum it should contain all intermediary hashes that are required in order to reconstruct the subtree root. These lists are ignored for non-prunable MMRs. - A list MMR positions and a corresponding list of leaves in the segment (leaf index range <code>[i * 2^h, (i+1) * 2^h)</code>), sorted by MMR position in ascending order. At a minimum it should contain all unpruned leaves and the direct sibling of every unpruned leaf. - The segment Merkle proof.</p> <p>After receiving a segment, clients should verify if its contents are contained in the MMR by performing the following two steps:  1) calculate the root of the segment (using the leaf data and intermediary hashes) and  2) reconstruct the full MMR root using the segment root and the segment merkle proof and compare it to the root in the block header.</p> <p>Clients are allowed to request fully pruned segments. In case of a fully pruned segment the list of leaves is expected to be empty and the list of hashes to contain a single entry: the first unpruned parent of the segment root. The proof is expected to contain the required hashes to reconstruct the MMR root from the first unpruned parent onwards.</p> <p>Clients should only ever request or respond with segments for the most recent canonical block for which <code>height &lt;= STATE_SYNC_THRESHOLD &amp;&amp; height % TXHASHSET_ARCHIVE_INTERVAL == 0</code>. This is the same block as the txhashset.zip file is based on.</p> <p>Clients are free to choose a segment size by setting the height within a certain range in their requests. This allowed range is set differently depending on the MMR contents. The following table has concrete values for the different MMR types and the allowed height range. The upper bound has been chosen such that a single segment roughly corresponds to the maximum size of a block (1,348,032 B). The lower bound is set such that the segment size is roughly an sixteenth of the maximum size.</p> MMR Type Prunable? Leaf size (B) Height range Maximum segment size (B) Output bitmap No 128 [9,13] 1,114,177 + proof Outputs Yes 34 [11,15] 1,376,353 + proof Range proofs Yes 675 [7,11] 1,398,881 + proof Kernels No ~114 (variable) [9,13] 999,489 + proof <p>Because the block header only commits to <code>H(output_root|bitmap_root)</code> [2] as opposed to each of the roots separately, the output bitmap segments and output segments require an additional field to specify the root of the other MMR. </p>"},{"location":"grin-rfcs/text/0020-pibd-messages/#segment-root","title":"Segment root","text":"<p>A segment can be viewed as a valid MMR with its starting position shifted. Therefore we define the segment root analogous to an MMR root [1]: we iteratively hash the peaks in the segment from right to left. However instead of including the segment size in the hashing calculation, we substitute it with the full MMR size. This ensures that the root of the final segment is the same as the bagged peaks on the full MMR, greatly simplifying our merkle proof.</p> <p>The segment root can be calculated by iterating over all MMR positions in the segment range. If the position is a leaf: check (for prunable MMRs) to see if the element is expected to be there (based on presence of the element or its sibling in the bitmap) and if it is get it from the list of leaves, hash it and store the hash in a list of temporary hashes. For all other positions: if both children are not present in the list of temporary hashes (i.e. they are both pruned), do nothing. If either or both hashes are present in the temporary list, hash them together and store the new hash in the temporary list. If only one of the children was present, obtain the hash of the other child from the list of hashes in the segment instead. After looping through all positions, we are either left with 1 entry (full segment) or multiple entries (partially filled, final segment) in the list of temporary hashes. If there are multiple, bag them together. This leaves a single hash, the segment root.</p>"},{"location":"grin-rfcs/text/0020-pibd-messages/#segment-merkle-proof","title":"Segment merkle proof","text":"<p>Whenever a node receives an MMR segment, it needs to be able to verify that its contents are in fact part of the MMR. This is usually done by providing a merkle proof, which in short is a list of hashes that, combined with a leaf hash, is used to calculate the root. If it successfully reproduces the root, the proof is considered to be valid.</p> <p>It would be very inefficient and redundant to provide a separate merkle proof for each leaf in the segment. Therefore we create a single optimized merkle proof per segment, based on two observations: firstly, a full segment (<code>2^h</code> elements) forms a full binary subtree in the MMR.  This means it has a single root.  Secondly, the final segment is potentially only partially filled (number of elements is not a power of 2).  If this is the case, each of the peaks in the segment are direct peaks in the MMR.</p> <p>As such, a segment merkle proof is simply a list of hashes: 1. The siblings along the path from the subtree root (final MMR position of the segment) up to its corresponding peak in the MMR 2. Peaks to the right of our subtree, bagged together to a single hash 3. Peaks to the left (from right to left) with a position smaller than the first MMR position of the segment  For efficiency reasons the peaks on the right side of our subtree are bagged together. Note that this procedure will also behave as expected for the partially filled final segment, since in that case step and 1 and 2 will not produce any hashes and step 3 will give us all the other peaks in the MMR.</p> <p>Verifying a proof is done by iteratively hashing our segment root together with the hashes in the list above. If the final hash corresponds to the MMR root, the segment is considered valid. </p>"},{"location":"grin-rfcs/text/0020-pibd-messages/#p2p-messages","title":"p2p messages","text":"<p>This RFC introduces 8 new peer-to-peer messages that follow request-response semantics: 2 for each MMR type.</p> <p>Each request contains the segment identifier triplet <code>(H, h, i)</code>: - block hash <code>H</code> (32 bytes) - segment height <code>h</code> (1 byte) - zero-based segment index <code>i</code> (8 bytes)</p> <p>The corresponding reference impl Rust type is <code>SegmentRequest</code> [6].</p> <p>The response is a segment as explained in the previous section: - block hash <code>H</code> (32 bytes) - segment height <code>h</code> (1 byte) - zero-based segment index <code>i</code> (8 bytes) - length of intermediary hashes list <code>N_h</code> (8 bytes) - list of intermediary hash positions (<code>8 * N_h</code> bytes) - list of intermediary hashes (<code>32 * N_h</code> bytes) - length of leaf list <code>N_l</code> (8 bytes) - list of leaf positions (<code>8 * N_l</code> bytes) - list of leaf data (variable, depends on leaf data type) - segment merkle proof: number of hashes <code>N_m</code> (8 bytes) and the list of hashes (<code>32 * N_m</code> bytes) - OutputSegment only:  root hash of the output bitmap MMR at block hash <code>H</code> (32 bytes)</p> <p>The corresponding reference impl Rust types are <code>SegmentResponse&lt;T&gt;</code> and <code>OutputSegmentResponse</code> [6].</p> <p>The output bitmap segments use a specialized (de)serialization scheme instead. First, consider all the leaves in the segment as belonging to a single continuous bitmap. Split this bitmap up in blocks of <code>2^16</code> bits each. Each block is (de)serialized independently, with different encodings depending on the block cardinality (reference impl. [5]).</p> <p>First, start off by writing the following data: - number of chunks contained in the block <code>N_ch &lt;= 64</code> (1 byte)</p> <p>If the cardinality is less than 4096, write the following data: - serialization mode <code>1u8</code> (1 byte) - cardinality <code>N_pos</code> (2 bytes) - list of positive positions (<code>2 * N_pos</code> bytes)</p> <p>If <code>2^16 - cardinality = N_neg</code> is less than 4096, write the following data instead: - serialization mode <code>2u8</code> (1 byte) - \"inverse\" cardinality <code>N_neg</code> (2 bytes) - list of negative positions (<code>2 * N_neg</code> bytes)</p> <p>In any other case, write the following data instead: - serialization mode <code>0u8</code> (1 byte) - full bitmap as raw bytes (<code>128 * N_ch</code> bytes)</p> <p>The full output bitmap segment response is defined as followed: - block hash <code>H</code> (32 bytes) - segment height <code>h</code> (1 byte) - zero-based segment index <code>i</code> (8 bytes) - number of blocks (2 bytes) - list of blocks (variable # of bytes) - segment merkle proof: number of hashes <code>N_m</code> (8 bytes) and the list of hashes (<code>32 * N_m</code> bytes) - root hash of the output PMMR at block hash <code>H</code> (32 bytes)</p> <p>The corresponding reference impl Rust type is <code>OutputBitmapSegmentResponse</code> [6].</p> <p>Finally, the new p2p messages are as follows:</p> ID Name MMR type Message type Rust ref. impl. type 21 GetOutputBitmapSegment Output bitmap Request <code>SegmentRequest</code> 22 OutputBitmapSegment Output bitmap Response <code>OutputBitmapSegmentResponse</code> 23 GetOutputSegment Output Request <code>SegmentRequest</code> 24 OutputSegment Output Response <code>OutputSegmentResponse</code> 25 GetRangeProofSegment Range proof Request <code>SegmentRequest</code> 26 RangeProofSegment Range proof Response <code>SegmentResponse&lt;RangeProof&gt;</code> 27 GetKernelSegment Kernel Request <code>SegmentRequest</code> 28 KernelSegment Kernel Response <code>SegmentResponse&lt;TxKernel&gt;</code>"},{"location":"grin-rfcs/text/0020-pibd-messages/#drawbacks","title":"Drawbacks","text":"<p>Rewinding the bitmap accumulator to an old state is a relatively expensive operation. The accumulator is not append-only and a rewind can cause large parts of it to be rewritten. Implementations will most likely be required to (temporarily) store the old accumulator state either on disk or in memory, increasing the memory/storage requirements of running a node.</p> <p>The amount of data required to be stored here is however much less than is required to support the txhashset.zip sync method.</p>"},{"location":"grin-rfcs/text/0020-pibd-messages/#rationale-and-alternatives","title":"Rationale and alternatives","text":"<p>The most obvious alternative to this proposal would be to keep the txhashset.zip sync method around indefinitely. However, we do believe that this would be detrimental in the long term. Outside of the disadvantages of this method mentioned in the motivation section, the method relies on the precise on-disk bit representation of MMRs. We would be unable to improve upon the storage without breaking this sync method. Furthermore, the zip sync method has been victim to a critical vulnerability before [7]. While this vulnerability is long since patched, it is a testament to the complications that could arise in using zip archives as a synchronisation method. Zip archives are a blunt tool and it would be unfortunate to have to permanently support it when we have access to a much more precise and efficient method.</p> <p>We briefly considered adding a separate request for the output and bitmap roots at a certain height, as a block header only commits to the hash of the concatenated values: <code>H(output_root|bitmap_root)</code>. While this would save a small amount of bandwidth compared to the current proposal, it would hurt our ability to precisely determine malicious peers. If verification on a bitmap or output segment were to fail, it could be caused by either an invalid segment or by a collision in the roots. We would be unable to distinguish between these two scenarios, forcing us to assume both peers are malicious. However by including the other root hash directly into the segment response messages, we ensure all required data originates from the same peer.</p>"},{"location":"grin-rfcs/text/0020-pibd-messages/#future-possibilities","title":"Future possibilities","text":""},{"location":"grin-rfcs/text/0020-pibd-messages/#deprecate-txhashetzip","title":"Deprecate txhashet.zip","text":"<p>Upon connection, nodes signal whether they support zip sync and/or PIBD sync separately. This allows us to deprecate and eventually remove support for the zip sync method in a future version. It would remove the need for nodes to keep a copy of the most recent txhashset archive around, saving disk space.</p> <p>Once the txhashset zip method has been removed, we could possibly relax a requirement on our segments. Currently, for any pair of sibling leaves where only one of them is spent, we require both of them to still be present in the segment. This is because it is expected nodes will still support the zip sync method. In this sync method, this property of sibling leaves has to hold due to historical implementation reasons. Removing support for the zip sync could allow us to remove this requirement.</p> <p>The precise details of the removal of support of the sync method and relaxation of segment requirement is considered to be out of the scope of this RFC.</p>"},{"location":"grin-rfcs/text/0020-pibd-messages/#header-segments","title":"Header segments","text":"<p>Since nodes already maintain a block header MMR, we could re-use the existing segment infrastructure to introduce block header segments. Although further investigation is required, this has the potential to speed up the header sync, which is the first step in the synchronisation process.</p>"},{"location":"grin-rfcs/text/0020-pibd-messages/#references","title":"References","text":"<ul> <li>[1] Merkle mountain ranges</li> <li>[2] RFC 0009: enable faster sync</li> <li>[3] Reference implementation - segments</li> <li>[4] Reference implementation - segmenter</li> <li>[5] Reference implementation - output bitmap message (de)ser</li> <li>[6] Reference implementation - messages</li> <li>[7] CVE-2019-9195</li> </ul>"},{"location":"grin-rfcs/text/0021-fix-prior-fees/","title":"0021 fix prior fees","text":"<ul> <li>Title: fix-prior-fees</li> <li>Authors: John Tromp</li> <li>Start date: January 21, 2021</li> <li>RFC PR: mimblewimble/grin-rfcs#0021</li> <li>Tracking issue: https://github.com/mimblewimble/grin/issues/3635</li> </ul>"},{"location":"grin-rfcs/text/0021-fix-prior-fees/#summary","title":"Summary","text":"<p>Carry the restriction of fees, to 40 bits since HF4, back to all history. Do not change <code>headerversion</code> despite the hard-forking nature.</p>"},{"location":"grin-rfcs/text/0021-fix-prior-fees/#motivation","title":"Motivation","text":"<p>This makes the <code>FeeFields</code> methods <code>fee()</code> and <code>fee_shift()</code> height independent, as well as several other functions which end up calling them. This results in nontrivial code and consensus model simplification, with no downside, which is always a good thing.</p>"},{"location":"grin-rfcs/text/0021-fix-prior-fees/#community-level-explanation","title":"Community-level explanation","text":"<p>The largest fee to appear on mainnet prior to Hark Fork 4 is 2.404 Grin. This means that extending the current 40-bit fee restriction to the pre-HF4 history preserves validity.  While this is technically a hard-forking change, we could treat it as an optional update. An attacker could in theory split the network by creating an ultra-deep reorg that includes a pre-HF4 fee exceeding 40 bits. However, the split damage would utterly pale in comparison to having a many months deep reorg in the first place.  So in practice this change does not justify a header version bump and mandatory upgrade.</p>"},{"location":"grin-rfcs/text/0021-fix-prior-fees/#reference-level-explanation","title":"Reference-level explanation","text":"<p>When computing the fee paid by a transaction, take all the fee fields in transaction kernels, and  mask out all but the least significant 40 bits. This masking used to be conditional on the header version of a argument height being at least 5 [1].</p>"},{"location":"grin-rfcs/text/0021-fix-prior-fees/#drawbacks","title":"Drawbacks","text":"<p>None!</p>"},{"location":"grin-rfcs/text/0021-fix-prior-fees/#rationale-and-alternatives","title":"Rationale and alternatives","text":"<p>There is no compelling reason for leaving a height dependency in the fee method.</p>"},{"location":"grin-rfcs/text/0021-fix-prior-fees/#unresolved-questions","title":"Unresolved questions","text":"<p>How many months should we wait after HF4 before rolling out this code simplification? I propose that 3 months is more than enough, making this RFC acceptable from mid April 2021 onwards.</p>"},{"location":"grin-rfcs/text/0021-fix-prior-fees/#future-possibilities","title":"Future possibilities","text":""},{"location":"grin-rfcs/text/0021-fix-prior-fees/#references","title":"References","text":"<p>[1] transaction.rs</p>"},{"location":"wiki/resources/","title":"Resources","text":""},{"location":"wiki/resources/#more-documents","title":"More Documents","text":"<ul> <li>Build and run automation </li> <li>Run a node on google cloud for free </li> <li>How to mine with grin-miner </li> <li>Monetary policy </li> </ul>"},{"location":"wiki/resources/#talks","title":"Talks","text":""},{"location":"wiki/resources/#playlists","title":"Playlists","text":"<ul> <li>grincon0 </li> <li>grinconUS(0) </li> <li>grinAmsterdam </li> <li>grincon1 </li> </ul>"},{"location":"wiki/resources/#other","title":"Other","text":"<ul> <li>Mimblewimble, Scaling Bitcoin'16 </li> <li>Mimblewimble, SF Bitcoin Developers`16</li> <li>Mimblewimble, BPASE'17</li> <li>Mimblewimble &amp; Scriptless Scripts, RWC'18</li> <li>A View on Grin, HCPP'19, Slides </li> </ul>"},{"location":"wiki/resources/#forum","title":"Forum","text":""},{"location":"wiki/resources/#announcements","title":"Announcements","text":"<ul> <li>Hardforks on Grin v5.0.0 and beyond </li> <li>Dismantling the core team and governance structure</li> </ul>"},{"location":"wiki/resources/#development-and-technical-discussions","title":"Development and  Technical Discussions","text":"<ul> <li>How to store Grin in cold storage?</li> <li>Raspberry Pi 4 - Standalone Grin-Node PoC by Grinnode.live </li> <li>How to open port 3414 (and why)</li> <li>Use of NRD kernels in payment channels</li> <li>Transaction Aggregation</li> <li>TX Graph Confidentality</li> <li>Queries about transaction aggregation</li> <li>Aggregate merkle proofs</li> <li>Unique kernels thread #73</li> <li>Sending a transaction to more parties than originally intended</li> <li>Reasoning behind block weight limit</li> <li>Play attacks and possible mitigations</li> <li>Replay attacks and possible mitigations</li> <li>Grin transactions user interactivity</li> <li>Eliminate finalize step</li> <li>Integrated payment proofs and round minimization</li> <li>Communicating with grin-wallet API (Tutorial)</li> <li>Pep talk for one sided transactions</li> </ul>"},{"location":"wiki/resources/#emmission-model","title":"Emmission Model","text":"<ul> <li>Emission Rate of GRIN</li> <li>Questioning core assumptions on emmission model</li> <li>Linear emmission is fair to late adopters</li> </ul>"},{"location":"wiki/resources/#mining","title":"Mining","text":"<ul> <li>PoW specification</li> <li>Scheduled PoW upgrades proposal</li> <li>Choice of ASIC Resistant PoW for GPU miners</li> <li>Put later phase-outs on hold proposal</li> <li>All about C31 fade out, the C29 scale and C32</li> <li>Being ASIC resistant or not</li> <li>Grin ASIC iPOLLO-G1 Mining Tutorial</li> </ul>"},{"location":"wiki/resources/#miscellaneous","title":"Miscellaneous","text":"<ul> <li>Response to Reavealing TX Graph</li> <li>Some toughts on Privacy</li> <li>On Igno's absence </li> <li>Genesis block message</li> </ul>"},{"location":"wiki/resources/#research","title":"Research","text":"<ul> <li>Coinbase outputs as regular outputs </li> <li>Is there a potential hidden inflation problem</li> <li>Confidential Assets</li> <li>Bidirectional Payment Proofs </li> <li>Grin AUDIT 4.0.0 Release</li> <li>Grinvestigation</li> <li>Coinswap Proposal </li> </ul>"},{"location":"wiki/resources/#medium","title":"Medium","text":"<ul> <li>Grin Money Explained </li> <li>Grin's Mythical Fair Launch</li> <li>Grin Transactions Explained, Step-by-Step </li> <li>What\u2019s inside a Grin Transaction File?</li> <li>Breaking Mimblewimble\u2019s Privacy Model</li> <li>Factual inaccuracies of \u201cBreaking Mimblewimble\u2019s Privacy Model\u201d</li> <li>Mimblewimble Without the Scary Math </li> <li>Behind Mimblewimble </li> <li>An Introduction to Grin Proof-of-Work </li> <li>A Case for using soft total supply</li> </ul>"},{"location":"wiki/resources/#podcasts","title":"Podcasts","text":"<ul> <li>[Bitcoin Wednesday] Introducing Mimblewimble and Grin @jaspervdm </li> <li>[Unchained] Grin: A More Private, Lighter Bitcoin @lehnberg @yeastplume </li> <li>[The Crypto Show] Mimblewimble with Andrew Poelstra and Peter Wuillie</li> <li>[Zero Knowledge] Grin @lehnberg </li> <li>[Captain Crypto Show] Grin @yeastplume </li> <li>[What Bitcoin Did] Grin's Mimblewimble Implementation @yeastplume </li> <li>[Let's Talk Bitcoin] Privacy with Mimblewimble @yeastplume @andreas @adam.b.levine</li> </ul>"},{"location":"wiki/resources/#miscellaneous_1","title":"Miscellaneous","text":"<ul> <li>[Launchpad] Mimblewimble Mailing List Archive</li> <li>[Reddit] Mimblewimble introduced to r/bitcoin </li> <li>[Youtube] Aantonop Bitcoin Q&amp;A: Mimblewimble and Dandelion</li> <li>[Coindesk] Harry Potter Characters Join Mimblewimble 2016 </li> <li>[Github] Meeting Notes</li> <li>[Reddit] On Grin's Privacy</li> <li>[Launchpad] Scripting observations and Lightning Network implementation</li> <li>[GitHub] Grin difficulty, C29, C31 fade out and C32</li> <li>[GitHub] Fees in Mining </li> <li>[Google] Replay Attacks Summary </li> <li>[Blog] A Relatively Easy to Understand Primer on ECC</li> </ul>"},{"location":"wiki/resources/#rfcs","title":"RFCs","text":"<ul> <li>[Github] All Accepted RFCs</li> <li>[Github] All Pending RFCs</li> </ul>"},{"location":"wiki/resources/#papers","title":"Papers","text":"<ul> <li>Confidential Assets</li> <li>OWAS </li> <li>Bulletproofs](https://eprint.iacr.org/2017/1066.pdf)</li> <li>Cuckoo Cycle </li> </ul>"},{"location":"wiki/table-of-contents/","title":"Table of Contents","text":"<p>This wiki contains a high level technical overview of Grin. For more details about the implentation, please look at the Grin documentation on docs.rs</p> <ul> <li>grin: api, core, chain, util, store, keychain, p2p, pool, config, servers.</li> <li>grin_wallet: wallet_api, wallet.</li> </ul>"},{"location":"wiki/table-of-contents/#introduction","title":"Introduction","text":"<ul> <li>Grin for Bitcoiners - Explaining Grin from a Bitcoiner's perspective</li> <li>Mimblewimble - A technical introduction to Mimblewimble <ol> <li>Elliptic Curves</li> <li>Commitments</li> <li>Mimblewimble</li> </ol> </li> </ul>"},{"location":"wiki/table-of-contents/#transactions","title":"Transactions","text":"<ul> <li>Slates</li> <li>Slatepack</li> <li>Payment Proofs</li> <li>Contracts</li> </ul>"},{"location":"wiki/table-of-contents/#blocks","title":"Blocks","text":"<ul> <li>Header</li> <li>Body</li> <li>Fees &amp; Weight</li> </ul>"},{"location":"wiki/table-of-contents/#chain-state","title":"Chain State","text":"<ul> <li>Merkle Mountain Ranges</li> <li>State &amp; Pruning</li> <li>Chain Sync</li> </ul>"},{"location":"wiki/table-of-contents/#miscellaneous","title":"Miscellaneous","text":"<ul> <li>Cuckoo Cycle</li> <li>Dandelion</li> <li>Switch Commitments</li> <li>Coinbase Maturity Rule</li> <li>NRD Kernels</li> </ul>"},{"location":"wiki/table-of-contents/#api","title":"API","text":"<ul> <li>Node API</li> <li>Wallet API</li> <li>Stratum RPC</li> </ul>"},{"location":"wiki/table-of-contents/#security-process","title":"Security Process","text":"<ul> <li>Grin's Security Process</li> <li>Security Team</li> <li>Code Audits</li> </ul>"},{"location":"wiki/table-of-contents/#services","title":"Services","text":"<ul> <li>List of Services</li> <li>Slatepack Integration Guide</li> </ul>"},{"location":"wiki/table-of-contents/#more","title":"More","text":"<ul> <li>Resources</li> </ul>"},{"location":"wiki/api/node-api/","title":"Node API","text":"<p>The API is used to query a node about various information on the blockchain, networks and peers. By default, the API will listen on <code>localhost:3413</code>. The API is started at the same time as the grin node. This endpoint requires, by default, basic authentication. The username is <code>grin</code>.</p>"},{"location":"wiki/api/node-api/#node-api-v2","title":"Node API v2","text":"<p>This API version uses JSON-RPC for its requests. It is split up into a foreign API and an owner API. The documentation for these endpoints is automatically generated:</p> <ul> <li>Owner API</li> <li>Foreign API</li> </ul> <p>Basic auth passwords can be found in <code>.api_secret</code>/<code>.foreign_api_secret</code> files respectively.</p> <p>Postman</p> <p>A complete Postman collection for the Grin Node API can be found here.</p>"},{"location":"wiki/api/node-api/#node-api-v1","title":"Node API v1","text":"<p>Note: version 1 of the API will be deprecated in v4.0.0 and subsequently removed in v5.0.0. Users of this API are encouraged to upgrade to API v2.</p> <p>This API uses REST for its requests. To learn about what specific calls can be made read the node API v1 doc.</p> <p>Basic auth password can be found in <code>.api_secret</code></p>"},{"location":"wiki/api/stratum-rpc/","title":"Stratum RPC Protocol","text":"<p>Read this in other languages: Korean, \u7b80\u4f53\u4e2d\u6587.</p> <p>This document describes the current Stratum RPC protocol implemented in Grin.</p>"},{"location":"wiki/api/stratum-rpc/#messages","title":"Messages","text":"<p>In this section, we detail each message and the potential response.</p>"},{"location":"wiki/api/stratum-rpc/#getjobtemplate","title":"<code>getjobtemplate</code>","text":"<p>A message initiated by the miner. Miner can request a job with this message.</p>"},{"location":"wiki/api/stratum-rpc/#request","title":"Request","text":"Field Content id ID of the request jsonrpc \"2.0\" method \"getjobtemplate\" params null <p>Example:</p> <pre><code>{\n   \"id\":\"2\",\n   \"jsonrpc\":\"2.0\",\n   \"method\":\"getjobtemplate\",\n   \"params\":null\n}\n</code></pre> <p>The response can be of two types:</p>"},{"location":"wiki/api/stratum-rpc/#ok-response","title":"OK response","text":"<p>Example:</p> <pre><code>{\n   \"id\":\"0\",\n   \"jsonrpc\":\"2.0\",\n   \"method\":\"getjobtemplate\",\n   \"result\":{\n      \"difficulty\":1,\n      \"height\":13726,\n      \"job_id\":4,\n      \"pre_pow\":\"00010000000000003c4d0171369781424b39c81eb39de10cdf4a7cc27bbc6769203c7c9bc02cc6a1dfc6000000005b50f8210000000000395f123c6856055aab2369fe325c3d709b129dee5c96f2db60cdbc0dc123a80cb0b89e883ae2614f8dbd169888a95c0513b1ac7e069de82e5d479cf838281f7838b4bf75ea7c9222a1ad7406a4cab29af4e018c402f70dc8e9ef3d085169391c78741c656ec0f11f62d41b463c82737970afaa431c5cabb9b759cdfa52d761ac451276084366d1ba9efff2db9ed07eec1bcd8da352b32227f452dfa987ad249f689d9780000000000000b9e00000000000009954\"\n   }\n}\n</code></pre>"},{"location":"wiki/api/stratum-rpc/#error-response","title":"Error response","text":"<p>If the node is syncing, it will send the following message:</p> Field Content id ID of the request jsonrpc \"2.0\" method \"getjobtemplate\" error {\"code\":-32701,\"message\":\"Node is syncing - Please wait\"} <p>Example:</p> <pre><code>{\n   \"id\":\"10\",\n   \"jsonrpc\":\"2.0\",\n   \"method\":\"getjobtemplate\",\n   \"error\":{\n      \"code\":-32000,\n      \"message\":\"Node is syncing - Please wait\"\n   }\n}\n</code></pre>"},{"location":"wiki/api/stratum-rpc/#job","title":"<code>job</code>","text":"<p>A message initiated by the Stratum server. Stratum server will send job automatically to connected miners. The miner SHOULD interrupt current job if job_id = 0, and SHOULD replace the current job with this one after the current graph is complete.</p>"},{"location":"wiki/api/stratum-rpc/#request_1","title":"Request","text":"Field Content id ID of the request jsonrpc \"2.0\" method \"job\" params Int <code>difficulty</code>, <code>height</code>, <code>job_id</code> and string <code>pre_pow</code> <p>Example:</p> <pre><code>{\n   \"id\":\"Stratum\",\n   \"jsonrpc\":\"2.0\",\n   \"method\":\"job\",\n   \"params\":{\n      \"difficulty\":1,\n      \"height\":16375,\n      \"job_id\":5,\n      \"pre_pow\":\"00010000000000003ff723bc8c987b0c594794a0487e52260c5343288749c7e288de95a80afa558c5fb8000000005b51f15f00000000003cadef6a45edf92d2520bf45cbd4f36b5ef283c53d8266bbe9aa1b8daaa1458ce5578fcb0978b3995dd00e3bfc5a9277190bb9407a30d66aec26ff55a2b50214b22cdc1f3894f27374f568b2fe94d857b6b3808124888dd5eff7e8de7e451ac805a4ebd6551fa7a529a1b9f35f761719ed41bfef6ab081defc45a64a374dfd8321feac083741f29207b044071d93904986fa322df610e210c543c2f95522c9bdaef5f598000000000000c184000000000000a0cf\"\n   }\n}\n</code></pre>"},{"location":"wiki/api/stratum-rpc/#response","title":"Response","text":"<p>No response is required for this message.</p>"},{"location":"wiki/api/stratum-rpc/#keepalive","title":"<code>keepalive</code>","text":"<p>A message initiated by the miner in order to keep the connection alive.</p>"},{"location":"wiki/api/stratum-rpc/#request_2","title":"Request","text":"Field Content id ID of the request jsonrpc \"2.0\" method \"keepalive\" params null <p>Example:</p> <pre><code>{\n   \"id\":\"2\",\n   \"jsonrpc\":\"2.0\",\n   \"method\":\"keepalive\",\n   \"params\":null\n}\n</code></pre>"},{"location":"wiki/api/stratum-rpc/#response_1","title":"Response","text":"Field Content id ID of the request jsonrpc \"2.0\" method \"keepalive\" result \"ok\" error null <p>Example:</p> <pre><code>{\n   \"id\":\"2\",\n   \"jsonrpc\":\"2.0\",\n   \"method\":\"keepalive\",\n   \"result\":\"ok\",\n   \"error\":null\n}\n</code></pre>"},{"location":"wiki/api/stratum-rpc/#login","title":"<code>login</code>","text":"<p>A message initiated by the miner. Miner can log in on a Grin Stratum server with a login, password and agent (usually statically set by the miner program).</p>"},{"location":"wiki/api/stratum-rpc/#request_3","title":"Request","text":"Field Content id ID of the request jsonrpc \"2.0\" method \"login\" params Strings: login, pass and agent <p>Example:</p> <pre><code>{\n   \"id\":\"0\",\n   \"jsonrpc\":\"2.0\",\n   \"method\":\"login\",\n   \"params\":{\n      \"login\":\"login\",\n      \"pass\":\"password\",\n      \"agent\":\"grin-miner\"\n   }\n}\n</code></pre> <p>The response can be of two types:</p>"},{"location":"wiki/api/stratum-rpc/#ok-response_1","title":"OK response","text":"Field Content id ID of the request jsonrpc \"2.0\" method \"login\" result \"ok\" error null <p>Example:</p> <pre><code>{\n   \"id\":\"1\",\n   \"jsonrpc\":\"2.0\",\n   \"method\":\"login\",\n   \"result\":\"ok\",\n   \"error\":null\n}\n</code></pre>"},{"location":"wiki/api/stratum-rpc/#error-response_1","title":"Error response","text":"<p>Not yet implemented. Should return error -32500 \"Login first\" when login is required.</p>"},{"location":"wiki/api/stratum-rpc/#status","title":"<code>status</code>","text":"<p>A message initiated by the miner. This message allows a miner to get the status of its current worker and the network.</p>"},{"location":"wiki/api/stratum-rpc/#request_4","title":"Request","text":"Field Content id ID of the request jsonrpc \"2.0\" method \"status\" params null <p>Example:</p> <pre><code>{\n   \"id\":\"2\",\n   \"jsonrpc\":\"2.0\",\n   \"method\":\"status\",\n   \"params\":null\n}\n</code></pre>"},{"location":"wiki/api/stratum-rpc/#response_2","title":"Response","text":"<p>The response is the following:</p> Field Content id ID of the request jsonrpc \"2.0\" method \"status\" result String <code>id</code>. Integers <code>height</code>, <code>difficulty</code>, <code>accepted</code>, <code>rejected</code> and <code>stale</code> error null <p>Example:</p> <pre><code>{\n   \"id\":\"5\",\n   \"jsonrpc\":\"2.0\",\n   \"method\":\"status\",\n   \"result\":{\n      \"id\":\"5\",\n      \"height\":13726,\n      \"difficulty\":1,\n      \"accepted\":0,\n      \"rejected\":0,\n      \"stale\":0\n   },\n   \"error\":null\n}\n</code></pre>"},{"location":"wiki/api/stratum-rpc/#submit","title":"<code>submit</code>","text":"<p>A message initiated by the miner. When a miner find a share, it will submit it to the node.</p>"},{"location":"wiki/api/stratum-rpc/#request_5","title":"Request","text":"<p>The miner submit a solution to a job to the Stratum server.</p> Field Content id ID of the request jsonrpc \"2.0\" method \"submit\" params Int <code>edge_bits</code>,<code>nonce</code>, <code>height</code>, <code>job_id</code> and array of integers <code>pow</code> <p>Example:</p> <pre><code>{\n   \"id\":\"0\",\n   \"jsonrpc\":\"2.0\",\n   \"method\":\"submit\",\n   \"params\":{\n      \"edge_bits\":29,\n      \"height\":16419,\n      \"job_id\":0,\n      \"nonce\":8895699060858340771,\n      \"pow\":[\n         4210040,10141596,13269632,24291934,28079062,84254573,84493890,100560174,100657333,120128285,130518226,140371663,142109188,159800646,163323737,171019100,176840047,191220010,192245584,198941444,209276164,216952635,217795152,225662613,230166736,231315079,248639876,263910393,293995691,298361937,326412694,330363619,414572127,424798984,426489226,466671748,466924466,490048497,495035248,496623057,502828197, 532838434\n         ]\n   }\n}\n</code></pre> <p>The response can be of three types.</p>"},{"location":"wiki/api/stratum-rpc/#ok-response_2","title":"OK response","text":"<p>The share is accepted by the Stratum but is not a valid cuck(at)oo solution at the network target difficulty.</p> Field Content id ID of the request jsonrpc \"2.0\" method \"submit\" result \"ok\" error null <p>Example:</p> <pre><code>{\n   \"id\":\"2\",\n   \"jsonrpc\":\"2.0\",\n   \"method\":\"submit\",\n   \"result\":\"ok\",\n   \"error\":null\n}\n</code></pre>"},{"location":"wiki/api/stratum-rpc/#blockfound-response","title":"Blockfound response","text":"<p>The share is accepted by the Stratum and is a valid cuck(at)oo solution at the network target difficulty.</p> Field Content id ID of the request jsonrpc \"2.0\" method \"submit\" result \"block - \" + hash of the block error null <p>Example:</p> <pre><code>{\n   \"id\":\"6\",\n   \"jsonrpc\":\"2.0\",\n   \"method\":\"submit\",\n   \"result\":\"blockfound - 23025af9032de812d15228121d5e4b0e977d30ad8036ab07131104787b9dcf10\",\n   \"error\":null\n}\n</code></pre>"},{"location":"wiki/api/stratum-rpc/#error-response_2","title":"Error response","text":"<p>The error response can be of two types: stale and rejected.</p> <p>Stale share error response</p> <p>The share is a valid solution to a previous job not the current one.</p> Field Content id ID of the request jsonrpc \"2.0\" method \"submit\" error {\"code\":-32503,\"message\":\"Solution submitted too late\"} <p>Example:</p> <pre><code>{\n   \"id\":\"5\",\n   \"jsonrpc\":\"2.0\",\n   \"method\":\"submit\",\n   \"error\":{\n      \"code\":-32503,\n      \"message\":\"Solution submitted too late\"\n   }\n}\n</code></pre> <p>Rejected share error responses</p> <p>Two possibilities: the solution cannot be validated or the solution is of too low difficulty.</p> <p>Failed to validate solution error</p> <p>The submitted solution cannot be validated.</p> Field Content id ID of the request jsonrpc \"2.0\" method \"submit\" error {\"code\":-32502,\"message\":\"Failed to validate solution\"} <p>Example:</p> <pre><code>{\n   \"id\":\"5\",\n   \"jsonrpc\":\"2.0\",\n   \"method\":\"submit\",\n   \"error\":{\n      \"code\":-32502,\n      \"message\":\"Failed to validate solution\"\n   }\n}\n</code></pre> <p>Share rejected due to low difficulty error</p> <p>The submitted solution is of too low difficulty.</p> Field Content id ID of the request jsonrpc \"2.0\" method \"submit\" error {\"code\":-32501,\"message\":\"Share rejected due to low difficulty\"} <p>Example:</p> <pre><code>{\n   \"id\":\"5\",\n   \"jsonrpc\":\"2.0\",\n   \"method\":\"submit\",\n   \"error\":{\n      \"code\":-32501,\n      \"message\":\"Share rejected due to low difficulty\"\n   }\n}\n</code></pre>"},{"location":"wiki/api/stratum-rpc/#error-messages","title":"Error Messages","text":"<p>Grin Stratum protocol implementation contains the following error message:</p> Error code Error Message -32000 Node is syncing - please wait -32500 Login first -32501 Share rejected due to low difficulty -32502 Failed to validate solution -32503 Solution Submitted too late -32600 Invalid Request -32601 Method not found"},{"location":"wiki/api/stratum-rpc/#miner-behavior","title":"Miner behavior","text":"<p>Miners SHOULD, MAY or MUST respect the following rules:</p> <ul> <li>Miners SHOULD randomize the job nonce before starting</li> <li>Miners MUST continue mining the same job until the server sends a new one, though a miner MAY request a new job at any time</li> <li>Miners MUST NOT send an rpc response to a job request from the server</li> <li>Miners MAY set the RPC \"id\" and expect responses to have that same id</li> <li>Miners MAY send a keepalive message</li> <li>Miners MAY send a login request (to identify which miner finds shares / solutions in the logs), the login request MUST have all 3 params.</li> <li>Miners MUST return the supplied job_id with submit messages.</li> </ul>"},{"location":"wiki/api/stratum-rpc/#reference-implementation","title":"Reference Implementation","text":"<p>The current reference implementation is available at mimblewimble/grin-miner.</p>"},{"location":"wiki/api/wallet-api/","title":"Wallet API","text":"<p>The wallet API uses JSON-RPC requests and is split into two separate blocks of functionality:</p> <ul> <li>Owner API</li> <li>Foreign API</li> </ul> <p>Basic auth passwords can be found in <code>.api_secret</code>.</p>"},{"location":"wiki/blocks/block-body/","title":"Block Body","text":"<p>The block body contains transactions. They are aggregated into one single transaction and follow the description of a transaction body.</p>"},{"location":"wiki/blocks/block-header/","title":"Block Header","text":"<p>General format of a Block Header in a Mimblewimble/Grin:</p> Field Description Size version Version of the block 2 bytes height Height of this block since the genesis block (height 0) 8 bytes timestamp Timestamp at which the block was built 8 bytes prev_hash Hash of the block previous to this in the chain 32 bytes prev_root Root hash of the header MMR at the previous header 32 bytes output_root Merkle root of all the commitments in the TxHashSet 32 bytes range_proof_root Merkle root of all range proofs in the TxHashSet 32 bytes kernel_root Merkle root of all transaction kernels in the TxHashSet 32 bytes total_kernel_offset Total accumulated sum of kernel offsets since genesis block. 32 bytes output_mmr_size Total size of the output MMR after applying this block. 8 bytes kernel_mmr_size Total size of the kernel MMR after applying this block. 8 bytes Sub-Total: 226 bytes - - - pow Proof of work data For cuck(AR)oo 29: 174 bytes.For cuck(AT)oo 32: 189 bytes. Total: 400 bytes for C29or 415 bytes for C32"},{"location":"wiki/blocks/block-header/#pow","title":"PoW","text":"<p>General format of a Proof Of Work in a Mimblewimble/Grin:</p> Field Description Size total_difficulty Total accumulated difficulty since genesis block 8 bytes secondary_scaling Variable difficulty scaling factor for secondary proof of work 4 bytes nonce Nonce increment used to mine this block. 8 bytes proof Proof of work data cuckoo_size: 1bytecuckoo_solution of C29: 42\u221729 bits=153 bytescuckoo_solution of C32: 42\u221732 bits=168 bytes Sub-Total: 174 bytes for C29 and 189 bytes for C32"},{"location":"wiki/blocks/block-header/#example","title":"Example","text":"<p>Here is a principle example of a Mimblewimble/Grin block header. The related block is included in Mainnet chain block: 1869.</p> Offset Field Hex Value 0 version 0001 2 height 000000000000074d 10 timestamp 000000005c3ff107 18 prev_hash 00001915c97bfad5bf9bb30a1035771446770502a937bd16a8c8a8f1fc6db730 50 prev_root 2eb356e36c03f16796dd4a6eef8cbcbeabaade84eecf013516367b376d646db7 82 output_root b56ccc990181d04d57585d3f0163b4f636fe3208a024596d14221bfa7739e693 114 range_proof_root a341b87862f430f9dda5fd0b88be175b6cc81b5e84bf6882d98cc31750b5001a 146 kernel_root b3e9708378ef256d479c6b166ba0a56c26d1b2e985c5e48065dbaa8a1fa6e606 178 total_kernel_offset 0755f37fa67bc3d3f0a7eddec7117013be42afff3602e7480d7271fff92763f1 210 output_mmr_size 0000000000001445 218 kernel_mmr_size 0000000000001130 226 total_difficulty 00000108e24af3bb 234 secondary_scaling 00000473 238 nonce 712493895227b883 246 edge_bits 1d 247 edge_nonces 43c8d2e098ba28f4f3748aab7d8be1aab3353259e6c6d4c046293f1c2f92afe7c5868bc5007fc51bae789ab3776d7efefb71547144b70ae8e764921bad8cb821a0c5d2adb455e1c406e1b2e39a2db51d7c552e4c1dd78bde1eea91f0843da6b3f1cb86e4ccb93371452b66c0ab292cd42525bcbf832fe358a3b22bcf7615e8397516ad8135a709213a77347cf4de104df5585984df0246fa03 400"},{"location":"wiki/blocks/fees-and-weight/","title":"Economic Policy: Fees and Mining Reward","text":"<p>(there are several mentions on weight and fees, one of them the document below written by Igno in 2016, by you should probably wait until they're revisited (tromp rfc) before the last hard fork). WORK IN PROGRESS**</p>"},{"location":"wiki/blocks/fees-and-weight/#considerations","title":"Considerations","text":"<p>Most cryptocurrencies rely on 2 important parameters: fees dictating the cost of transacting and block rewards compensating miners for securing the chain. Rewards also play the important role of being the only source of new money creation: the total amount of tokens in existence is the sum of every reward since the genesis block.</p> <p>No cryptocurrency so far has established a fee market that would allow to fully compensate for block rewards. Even bitcoin, with its fees significantly rising (as of Oct. 2016), is still far from reaching that goal. Given the current block space supply, bitcoin fees would have to rise by at least an order of magnitude, reaching $4 USD. Even then, the stability of the currency when mining is only paid out in fee is questionable<sup>1</sup>. We also note that the security provided by a large hashrate is desirable to all participants in a cryptocurrency's economy, and not only to active transactors.</p> <p>For all these reasons, we favor a constant reward over time, remarking that it asymptotically leads to zero dilution<sup>2</sup>.</p> <p>However, any cryptocurrency needs to protect itself against malicious spamming attacks that would flood the network and bloat storage. Proof of work is an efficient and elegant way to do so but difficult to adopt due to the complex computing ecosystem a cryptocurrency evolves in (from mobile wallets to cheap super-computing). So transaction fees remain the simplest way to protect a blockchain against malicious spam.</p> <p>By acknowledging that transaction fees only act as spam prevention we gain a framework to gauge how they should be priced: proportionately to the cost incurred by the network when accepting and safekeeping the transaction. Fee Levels and Incentives</p> <p>Given that block reward is the only way new currency is introduced, and supply greatly influences value, it makes sense to price fees based on how much supply is injected in the system. It also makes sense to study this for Grin, to establish a fee baseline. We introduce the notion of fees per reward per minute.</p> <p>For example in Bitcoin, at this time the reward per minute is 1.25BTC. Transaction fees average 70 satoshis per byte for a fast confirmation, putting the average transaction price around 16,000 with a median transaction size of 230 bytes. So the fees for a transaction are priced at 0.00128% of the reward per minute. In Ethereum, factoring in the current gas price, the transaction fees are priced around 0.0028% of the reward per minute.</p> <p>It may come as a surprise that this number would be higher for Ethereum than Bitcoin, but keep in mind that it only factors supply and not demand. It also only reflects how fast supply is injected, not how much total supply is currently in existence. Nonetheless, these 2 numbers are surprisingly close, giving us a good baseline.</p> <ol> <li> <p>http://randomwalker.info/publications/mining_CCS.pdf\u00a0\u21a9</p> </li> <li> <p>By introducing new currency, each block reward dilutes all existing participants,\u00a0\u21a9</p> </li> </ol>"},{"location":"wiki/chain-state/chain-sync/","title":"Chain Sync","text":"<p>Read (part of) this in other languages: Korean. Read about fast sync in other languages: Espa\u00f1ol, Korean, \u7b80\u4f53\u4e2d\u6587.</p> <p>We describe here the different methods used by a new node when joining the network to catch up with the latest chain state. We start with reminding the reader of the following assumptions, which are all characteristics of Grin or Mimblewimble:</p> <ul> <li>All block headers include the root hash of all unspent outputs in the chain at   the time of that block.</li> <li>Inputs or outputs cannot be tampered with or forged without invalidating the   whole block state.</li> </ul> <p>We intentionally only focus on major node types and high level algorithms that may impact the security model. Detailed heuristics that can provide some additional improvements (like header first), while useful, will not be mentioned in this document.</p>"},{"location":"wiki/chain-state/chain-sync/#full-history-syncing","title":"Full History Syncing","text":"<p>This model is the one used by full nodes on most major public blockchains. The new node has prior knowledge of the genesis block. It connects to other peers in the network and starts asking for blocks until it reaches the latest block known to its peers.</p> <p>The security model here is similar to Bitcoin. We're able to verify the whole chain, the total work, the validity of each block, their full content, etc. In addition, with Mimblewimble and full UTXO set commitments, even more integrity validation can be performed.</p> <p>We do not try to do any space or bandwidth optimization in this mode (for example, once validated the range proofs could possibly be deleted). The point here is to provide history archival and allow later checks and verifications to be made.</p> <p>However, such full history sync, also called Initial Block Download (IBD), is unnecessary for a new node to fully validate the Grin chain history, as most blocks may be only partially downloaded.</p>"},{"location":"wiki/chain-state/chain-sync/#fast-sync","title":"Fast Sync","text":"<p>We call <code>fast sync</code> the process of synchronizing a new node, or a node that hasn't been keeping up with the chain for a while, and bringing it up to the latest known most-worked block. In this model we try to optimize for very fast syncing while sacrificing as little security assumptions as possible. As a matter of fact, the security model is almost identical as a full history sync, despite requiring orders of magnitude less data to download.</p> <p>At a high level, a fast-sync goes through the following process:</p> <ol> <li>Sync all block headers on the most worked chain as advertized by other nodes. Also, pick a header sufficiently back from the chain head. This is called the node horizon as it's the furthest a node can reorganize its chain on a new fork if it were to occur without triggering another new full sync.</li> <li>Once all headers have are synced, Download the full state as it was at the horizon, including the unspent output, range proof and kernel data, as well as all corresponding MMRs. This is just one large zip file named <code>txhashset</code>.</li> <li>Validate the full state.</li> <li>Download full blocks since the horizon to reach the chain head.</li> </ol> <p>A new node is pre-configured with a horizon <code>Z</code>, which is a distance in number of blocks from the head. For example, if horizon <code>Z=5000</code> and the head is at height <code>H=23000</code>, the block at horizon is the block at height <code>h=18000</code> on the most worked chain.</p> <p>The new node also has prior knowledge of the genesis block. It connects to other peers and learns about the head of the most worked chain. It asks for the block header at the horizon block, requiring peer agreement. If consensus is not reached at <code>h = H - Z</code>, the node gradually increases the horizon <code>Z</code>, moving <code>h</code> backward until consensus is reached. Then it gets the full UTXO set at the horizon block.</p> <p>With this information it can verify:</p> <ul> <li>The total difficulty on that chain (present in all block headers).</li> <li>The sum of all UTXO commitments equals the expected money supply.</li> <li>The root hash of all UTXOs match the root hash in the block header.</li> </ul> <p>Once the validation is done, the peer can download and validate the blocks content from the horizon up to the head.</p> <p>While this algorithm still works for very low values of <code>Z</code> (or in the extreme case where <code>Z=1</code>), low values may be problematic due to the normal forking activity that can occur on any blockchain. To prevent those problems and to increase the amount of locally validated work, we recommend values of <code>Z</code> of at least a few days worth of blocks, up to a few weeks.</p>"},{"location":"wiki/chain-state/chain-sync/#security-discussion","title":"Security Discussion","text":"<p>While this sync mode is simple to describe, it may seem non-obvious how it still can be secure. We describe here some possible attacks, how they're defeated and other possible failure scenarios.</p>"},{"location":"wiki/chain-state/chain-sync/#an-attacker-tries-to-forge-the-state-at-horizon","title":"An attacker tries to forge the state at horizon","text":"<p>This range of attacks attempt to have a node believe it is properly synchronized with the network when it's actually is in a forged state. Multiple strategies can be attempted:</p> <ul> <li>Completely fake but valid horizon state (including header and proof of work).   Assuming at least one honest peer, neither the UTXO set root hash nor the block   hash will match other peers' horizon states.</li> <li>Valid block header but faked UTXO set. The UTXO set root hash from the header   will not match what the node calculates from the received UTXO set itself.</li> <li>Completely valid block with fake total difficulty, which could lead the node down   a fake fork. The block hash changes if the total difficulty is changed, no honest   peer will produce a valid head for that hash.</li> </ul>"},{"location":"wiki/chain-state/chain-sync/#a-fork-occurs-thats-older-than-the-local-utxo-history","title":"A fork occurs that's older than the local UTXO history","text":"<p>Our node downloaded the full UTXO set at horizon height. If a fork occurs on a block at an older horizon H+delta, the UTXO set can't be validated. In this situation the node has no choice but to put itself back in sync mode with a new horizon of <code>Z'=Z+delta</code>.</p> <p>Note that an alternate fork at Z+delta that has less work than our current head can safely be ignored, only a winning fork of total work greater than our head would. To do this resolution, every block header includes the total chain difficulty up to that block.</p>"},{"location":"wiki/chain-state/chain-sync/#the-chain-is-permanently-forked","title":"The chain is permanently forked","text":"<p>If a hard fork occurs, the network may become split, forcing new nodes to always push their horizon back to when the hard fork occurred. While this is not a problem for short-term hard forks, it may become an issue for long-term or permanent forks. To prevent this situation, peers should always be checked for hard fork related capabilities (a bitmask of features a peer exposes) on connection.</p>"},{"location":"wiki/chain-state/chain-sync/#several-nodes-continuously-give-fake-horizon-blocks","title":"Several nodes continuously give fake horizon blocks","text":"<p>If a peer can't reach consensus on the header at h, it gradually moves back. In the degenerate case, rogue peers could force all new peers to always become full nodes (move back until genesis) by systematically preventing consensus and feeding fake headers.</p> <p>While this is a valid issue, several mitigation strategies exist:</p> <ul> <li>Peers must still provide valid block headers at horizon <code>Z</code>. This includes the   proof of work.</li> <li>A group of block headers around the horizon could be asked to increase the cost   of the attack.</li> <li>Differing block headers providing a proof of work significantly lower could be   rejected.</li> <li>The user or node operator may be asked to confirm a block hash.</li> <li>In last resort, if none of the above strategies are effective, checkpoints could   be used.</li> </ul>"},{"location":"wiki/chain-state/merkle-mountain-range/","title":"Merkle Mountain Ranges (MMR)","text":"<p>Read this in other languages: Korean, \u7b80\u4f53\u4e2d\u6587.</p>"},{"location":"wiki/chain-state/merkle-mountain-range/#structure","title":"Structure","text":"<p>For the original document describing the motivation for choosing MMR as the Merkle structure for Grin, read here.</p> <p>Merkle Mountain Ranges<sup>1</sup> are an alternative to Merkle trees<sup>2</sup>. While the latter relies on perfectly balanced binary trees, the former can be seen either as list of perfectly balance binary trees or a single binary tree that would have been truncated from the top right. A Merkle Mountain Range (MMR) is strictly append-only: elements are added from the left to the right, adding a parent as soon as 2 children exist, filling up the range accordingly.</p> <p>Grin employs MMR to stores kernels, outputs and rangeproofs, each in its own dedicated tree.</p> <p>Let's illustrates a range with 11 inserted leaves and total size 19, where each node is annotated with its order of insertion.</p> <pre><code>Height\n\n3              14\n             /    \\\n            /      \\\n           /        \\\n          /          \\\n2        6            13\n       /   \\        /    \\\n1     2     5      9     12     17\n     / \\   / \\    / \\   /  \\   /  \\\n0   0   1 3   4  7   8 10  11 15  16 18\n</code></pre> <p>This can be represented as a flat list, here storing the height of each node at their position of insertion:</p> <pre><code>0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18\n0  0  1  0  0  1  2  0  0  1  0  0  1  2  3  0  0  1  0\n</code></pre> <p>The structure can be fully described simply from its size (19). It's also fairly simple, using fast binary operations, to navigate within a MMR. Given a node's position <code>n</code>, we can compute its height, the position of its parent, its siblings, etc.</p>"},{"location":"wiki/chain-state/merkle-mountain-range/#hashing-and-bagging","title":"Hashing and Bagging","text":"<p>Just like with Merkle trees, parent nodes in a MMR have for value the hash of their 2 children. Grin uses the Blake2b hash function throughout, and always prepends the node's position in the MMR before hashing to avoid collisions. So for a leaf <code>l</code> at index <code>n</code> storing data <code>D</code> (in the case of an output, the data is its Pedersen commitment, for example), we have:</p> <pre><code>Node(l) = Blake2b(n | D)\n</code></pre> <p>And for any parent <code>p</code> at index <code>m</code>:</p> <pre><code>Node(p) = Blake2b(m | Node(left_child(p)) | Node(right_child(p)))\n</code></pre> <p>Contrarily to a Merkle tree, a MMR generally has no single root by construction so we need a method to compute one (otherwise it would defeat the purpose of using a hash tree). This process is called \"bagging the peaks\"<sup>1</sup>.</p> <p>First, we identify the peaks of the MMR; we will define one method of doing so here. We first write another small example MMR but with the indexes written as binary (instead of decimal), starting from 1:</p> <pre><code>Height\n\n2        111\n       /     \\\n1     11     110       1010\n     /  \\    / \\      /    \\\n0   1   10 100 101  1000  1001  1011\n</code></pre> <p>This MMR has 11 nodes and its peaks are at position 111 (7), 1010 (10) and 1011 (11). We first notice how the first leftmost peak is always going to be the highest and always \"all ones\" when expressed in binary. Therefore that peak will have a position of the form <code>2^n - 1</code> and will always be the largest such position that is inside the MMR (its position is lesser than the total size). We process iteratively for a MMR of size 11:</p> <pre><code>2^0 - 1 = 0, and 0 &lt; 11\n2^1 - 1 = 1, and 1 &lt; 11\n2^2 - 1 = 3, and 3 &lt; 11\n2^3 - 1 = 7, and 7 &lt; 11\n2^4 - 1 = 15, and 15 is not &lt; 11\n</code></pre> <p>(This can also be calculated non-iteratively as <code>2^(binary logarithm of size + 1) - 1</code></p> <p>Therefore the first peak is 7. To find the next peak, we then need to \"jump\" to its right sibling. If that node is not in the MMR (and it won't), take its left child. If that child is not in the MMR either, keep taking its left child until we have a node that exists in our MMR. Once we find that next peak, keep repeating the process until we're at the last node.</p> <p>All these operations are very simple. Jumping to the right sibling of a node at height <code>h</code> is adding <code>2^(h+1) - 1</code> to its position. Taking its left child is subtracting <code>2^h</code>.</p> <p>Finally, once all the positions of the peaks are known, \"bagging\" the peaks consists of hashing them iteratively from the right, using the total size of the MMR as prefix. For a MMR of size N with 3 peaks p1, p2 and p3 we get the final top peak:</p> <pre><code>P = Blake2b(N | Blake2b(N | Node(p3) | Node(p2)) | Node(p1))\n</code></pre>"},{"location":"wiki/chain-state/merkle-mountain-range/#pruning","title":"Pruning","text":"<p>In Grin, a lot of the data that gets hashed and stored in MMRs can eventually be removed. As this happens, the presence of some leaf hashes in the corresponding MMRs become unnecessary and their hash can be removed. When enough leaves are removed, the presence of their parents may become unnecessary as well. We can therefore prune a significant part of a MMR from the removal of its leaves.</p> <p>Pruning a MMR relies on a simple iterative process. <code>X</code> is first initialized as the leaf we wish to prune.</p> <ol> <li>Prune <code>X</code>.</li> <li>If <code>X</code> has a sibling, stop here.</li> <li>If 'X' has no sibling, assign the parent of <code>X</code> as <code>X</code>.</li> </ol> <p>To visualize the result, starting from our first MMR example and removing leaves [0, 3, 4, 8, 16] leads to the following pruned MMR:</p> <pre><code>Height\n\n3             14\n            /    \\\n           /      \\\n          /        \\\n         /          \\\n2       6            13\n       /            /   \\\n1     2            9     12     17\n       \\          /     /  \\   /\n0       1        7     10  11 15     18\n</code></pre>"},{"location":"wiki/chain-state/merkle-mountain-range/#merkle-proof","title":"Merkle Proof","text":"<p>In the example above, the leaf nodes are 1, 2, 4, 5, 8, 9, 11, 12. Only these nodes hash actual data, while non-leaf nodes are simply hashes of their children.</p>"},{"location":"wiki/chain-state/merkle-mountain-range/#output-set-mmr","title":"Output Set MMR","text":"<p>Let's define the functionality of generating a Merkle proof for a given entry, <code>OutX</code>, in the total output set MMR.</p> <p>A Merkle proof consists of the following:</p> <ul> <li>Hash of the leaf node representing <code>OutX</code>.</li> <li>Hash of the overall root of the tree.</li> <li>A list of hashes representing all the MMR peaks (they match the overall root when hashed together).</li> <li>A list of sibling hashes to construct branch from node <code>outX</code> to its peak.</li> <li>A list of sibling positions (left/right) to allow the branch to be reconstructed correctly.</li> </ul> <p>A Merkle proof allows us to:</p> <ul> <li>Prove inclusion of the node beneath its peak.</li> <li>Prove the peaks combine to form the overall root hash.</li> <li>Prove inclusion of an (unspent) output for a given block_header by verifying the utxo_root matches the root of the Merkle proof</li> <li>If an output is unspent at a given block header, then it is at least as old as that block.</li> </ul> <p>Coinbase Output</p> <p>The wallet maintains a Merkle proof (and corresponding block hash) for each unspent coinbase output.</p> <p>Spending a coinbase output requires the block hash and Merkle proof to be provided in the input. these are used to verify coinbase maturity (without requiring full block data for verification)</p> <ol> <li> <p>merkle-mountain-range, Peter Todd\u00a0\u21a9\u21a9</p> </li> <li> <p>Merkle Tree, Wikipedia\u00a0\u21a9</p> </li> </ol>"},{"location":"wiki/chain-state/merkle-structures%28old%29/","title":"Merkle Structures","text":"<p>Read this in other languages: Korean, \u7b80\u4f53\u4e2d\u6587.</p> <p>Mimblewimble is designed for users to verify the state of the system given only pruned data. To achieve this goal, all transaction data is committed to the blockchain by means of Merkle trees which should support efficient updates and serialization even when pruned.</p> <p>Also, almost all transaction data (inputs, outputs, excesses and excess proofs) have the ability to be summed in some way, so it makes sense to treat Merkle sum trees as the default option, and address the sums here.</p> <p>A design goal of Grin is that all structures be as easy to implement and as simple as possible. Mimblewimble introduces a lot of new cryptography so it should be made as easy to understand as possible. Its validation rules are simple to specify (no scripts) and Grin is written in a language with very explicit semantics, so simplicity is also good to achieve well-understood consensus rules.</p>"},{"location":"wiki/chain-state/merkle-structures%28old%29/#merkle-trees","title":"Merkle Trees","text":"<p>There are four Merkle trees committed to by each block:</p>"},{"location":"wiki/chain-state/merkle-structures%28old%29/#total-output-set","title":"Total Output Set","text":"<p>Each object is one of two things: a commitment indicating an unspent output or a NULL marker indicating a spent one. It is a sum-tree over all unspent outputs (spent ones contribute nothing to the sum). The output set should reflect the state of the chain after the current block has taken effect.</p> <p>The root sum should be equal to the sum of all excesses since the genesis.</p> <p>Design requirements:</p> <ol> <li>Efficient additions and updating from unspent to spent.</li> <li>Efficient proofs that a specific output was spent.</li> <li>Efficient storage of diffs between UTXO roots.</li> <li>Efficient tree storage even with missing data, even with millions of entries.</li> <li>If a node commits to NULL, it has no unspent children and its data should    eventually be able to be dropped forever.</li> <li>Support for serialization and efficient merging of pruned trees from partial archival nodes.</li> </ol>"},{"location":"wiki/chain-state/merkle-structures%28old%29/#output-witnesses","title":"Output witnesses","text":"<p>This tree mirrors the total output set but has rangeproofs in place of commitments. It is never updated, only appended to, and does not sum over anything. When an output is spent it is sufficient to prune its rangeproof from the tree rather than deleting it.</p> <p>Design requirements:</p> <ol> <li>Support for serialization and efficient merging of pruned trees from partial archival nodes.</li> </ol>"},{"location":"wiki/chain-state/merkle-structures%28old%29/#inputs-and-outputs","title":"Inputs and Outputs","text":"<p>Each object is one of two things: an input (unambiguous reference to an old transaction output), or an output (a (commitment, rangeproof) pair). It is a sum-tree over the commitments of outputs, and the negatives of the commitments of inputs.</p> <p>Input references are hashes of old commitments. It is a consensus rule that all unspent outputs must be unique.</p> <p>The root sum should be equal to the sum of excesses for this block. See the next section.</p> <p>In general, validators will see either 100% of this Merkle tree or 0% of it, so it is compatible with any design.</p> <p>Design requirements:</p> <ol> <li>Efficient inclusion proofs, for proof-of-publication.</li> </ol>"},{"location":"wiki/chain-state/merkle-structures%28old%29/#excesses","title":"Excesses","text":"<p>Each object is of the form (excess, signature). It is a sum tree over the excesses.</p> <p>In general, validators will always see 100% of this tree, so it is not even necessary to have a Merkle structure at all. However, to support partial archival nodes in the future we want to support efficient pruning.</p> <p>Design requirements:</p> <ol> <li>Support for serialization and efficient merging of pruned trees from partial archival nodes.</li> </ol>"},{"location":"wiki/chain-state/merkle-structures%28old%29/#proposed-merkle-structure","title":"Proposed Merkle Structure","text":"<p>The following design is proposed for all trees: a sum-MMR where every node sums a count of its children as well as the data it is supposed to sum. The result is that every node commits to the count of all its children.</p> <p>MMRs, or Merkle Mountain Ranges</p> <p>The six design criteria for the output set are:</p>"},{"location":"wiki/chain-state/merkle-structures%28old%29/#efficient-insertupdates","title":"Efficient insert/updates","text":"<p>Immediate (as is proof-of-inclusion). This is true for any balanced Merkle tree design.</p>"},{"location":"wiki/chain-state/merkle-structures%28old%29/#efficient-proof-of-spentness","title":"Efficient proof-of-spentness","text":"<p>Grin itself does not need proof-of-spentness but it is a good thing to support in the future for SPV clients.</p> <p>The children-counts imply an index of each object in the tree, which does not change because insertions happen only at the far right of the tree.</p> <p>This allows permanent proof-of-spentness, even if an identical output is later added to the tree, and prevents false proofs even for identical outputs. These properties are hard to achieve for a non-insertion-ordered tree.</p>"},{"location":"wiki/chain-state/merkle-structures%28old%29/#efficient-storage-of-diffs","title":"Efficient storage of diffs","text":"<p>Storing complete blocks should be sufficient for this. Updates are obviously as easy to undo as they are to do, and since blocks are always processed in order, rewinding them during reorgs is as simple as removing a contiguous set of outputs from the right of the tree. (This should be even faster than repeated deletions in a tree designed to support deletions.)</p>"},{"location":"wiki/chain-state/merkle-structures%28old%29/#efficient-tree-storage-even-with-missing-data","title":"Efficient tree storage even with missing data","text":"<p>To update the root hash when random outputs are spent, we do not want to need to store or compute the entire tree. Instead we can store only the hashes at depth 20, say, of which there will be at most a million. Then each update only needs to recompute hashes above this depth (Bitcoin has less than 2^29 outputs in its history, so this means computing a tree of size 2^9 = 512 for each update) and after all updates are done, the root hash can be recomputed.</p> <p>This depth is configurable and may be changed as the output set grows, or depending on available disk space.</p> <p>This is doable for any Merkle tree but may be complicated by PATRICIA trees or other prefix trees, depending how depth is computed.</p>"},{"location":"wiki/chain-state/merkle-structures%28old%29/#dropping-spent-coins","title":"Dropping spent coins","text":"<p>Since coins never go from spent to unspent, the data on spent coins is not needed for any more updates or lookups.</p>"},{"location":"wiki/chain-state/merkle-structures%28old%29/#efficient-serialization-of-pruned-trees","title":"Efficient serialization of pruned trees","text":"<p>Since every node has a count of its children, validators can determine the structure of the tree without needing all the hashes, and can determine which nodes are siblings, and so on.</p> <p>In the output set each node also commits to a sum of its unspent children, so a validator knows if it is missing data on unspent coins by checking whether or not this sum on a pruned node is zero.</p>"},{"location":"wiki/chain-state/merkle-structures%28old%29/#algorithms","title":"Algorithms","text":"<p>(To appear alongside an implementation.)</p>"},{"location":"wiki/chain-state/merkle-structures%28old%29/#storage","title":"Storage","text":"<p>The sum tree data structure allows the efficient storage of the output set and output witnesses while allowing immediate retrieval of a root hash or root sum (when applicable). However, the tree must contain every output commitment and witness hash in the system. This data is too big to be permanently stored in memory and too costly to be rebuilt from scratch at every restart, even if we consider pruning (at this time, Bitcoin has over 50M UTXOs which would require at least 3.2GB, assuming a couple hashes per UTXO). So we need an efficient way to store this data structure on disk.</p> <p>Another limitation of a hash tree is that, given a key (i.e. an output commitment), it's impossible to find the leaf in the tree associated with that key. We can't walk down the tree from the root in any meaningful way. So an additional index over the whole key space is required. As an MMR is an append only binary tree, we can find a key in the tree by its insertion position. So a full index of keys inserted in the tree (i.e. an output commitment) to their insertion positions is also required.</p>"},{"location":"wiki/chain-state/state-and-pruning/","title":"State and Pruning","text":"<p>Read this in other languages: Korean, \u7b80\u4f53\u4e2d\u6587.</p>"},{"location":"wiki/chain-state/state-and-pruning/#state-storage","title":"State Storage","text":"<p>Recall that the Grin chain includes the following data:</p> <ol> <li>Outputs, which include for each output:<ol> <li>A Pedersen commitment (33 bytes).</li> <li>A range proof (640KB).</li> </ol> </li> <li>Inputs, which are just output references (32 bytes).</li> <li>Transaction kernels, which include for each transaction:<ol> <li>The excess commitment sum for the transaction (33 bytes).</li> <li>A signature generated with the excess (~70 bytes).</li> </ol> </li> <li>A block header with a valid proof of work and roots of the Merkle trees.</li> </ol> <p>Each node maintains 3 MMRs:</p> <ul> <li>An output set MMR.</li> <li>Rangeproofs MMR.</li> <li>Transaction kernels MMR.</li> </ul> <p>All outputs, rangeproofs and kernels are added in their respective MMRs in the order they occur in each block (recall that block data is required to be sorted).</p>"},{"location":"wiki/chain-state/state-and-pruning/#pruning","title":"Pruning","text":"<p>As outputs get spent, both their commitment and rangeproof data can be removed. In addition, the corresponding output and range proof MMRs can be pruned of their hash entires.</p> <p>PMMR</p> <p>A pruned MMR is referred to as a PMMR.</p> <p>Following pruning, the full state of the chain consists of the following data:</p> <ul> <li>The unspent output set (UTXO).</li> <li>A rangeproof for each unspent output.</li> <li>All transaction kernels.</li> </ul> <p>In addition, all block headers are required to anchor the above state with a valid proof of work (the state corresponds to the most worked chain).</p>"},{"location":"wiki/chain-state/state-and-pruning/#validation","title":"Validation","text":"<p>Pruning removes as much data as possible while keeping all the guarantees of a full Mimblewimble-style validation. This is necessary to keep a pruning node state's sane, but also on first fast sync, where only the minimum amount of data is sent to a new node.</p> <p>The full validation of the chain state requires that:</p> <ul> <li>All kernel signatures verify against their public keys (excess commitments).</li> <li>The sum of all UTXO commitments minus the supply is a valid public key.</li> <li>The sum of all kernel public keys equals the above public key (sum of UTXO commitments minus supply).</li> <li>The root hashes of the UTXO PMMR, the range proofs PMMR and the kernels MMR   match a block header with a valid proof of work chain.</li> <li>All range proofs are valid.</li> </ul> <p>While not necessary to validate the full chain state, accepting and validating new blocks also requires the output features (coinbase or plain), making the full output data necessary for all UTXOs.</p> <p>At minimum, this requires the following data:</p> <ul> <li>The block headers chain.</li> <li>All kernels, in order of inclusion in the chain. This also allows the   reconstruction of the kernel MMR.</li> <li>All unspent outputs.</li> <li>The UTXO MMR and the range proof MMR (to learn the hashes of pruned data).</li> </ul>"},{"location":"wiki/extra-documents/always-listening-wallet/","title":"Setting up an always listening wallet","text":"<p>For some use cases, like mining Grin, it's important to have a wallet that is always listening for incoming transactions. For this use case and others like it, configuring <code>grin-wallet</code> as a service might be prefered. Be warned though that the use of a password stored in a text file is required to automatically start the service, which does provide significant security concerns. Only use these instructions when you know what you are doing, e.g. for development and small amounts of funds!</p>"},{"location":"wiki/extra-documents/always-listening-wallet/#set-up-grin-wallet-as-a-service","title":"Set up grin-wallet as a service","text":"<p>Create a service file for <code>grin-wallet</code>:</p> <pre><code>sudo nano /etc/systemd/system/grin-wallet.service\n</code></pre> <p>Paste the following content into the file. The following configuration assumes a 'grin' user will be running the process with the wallet configuration living in <code>/var/lib/grin</code>. Wallet configuration by default is saved to the user's home directory in <code>.grin</code>. If you installed the snap package, your wallet command will be <code>grin.wallet</code> instead.</p> <pre><code>[Unit]\nDescription=grin wallet\nAfter=network.target\n\n[Service]\nWorkingDirectory=/var/lib/grin\nUser=grin\nGroup=grin\nPrivateDevices=yes\nType=simple\nExecReload=/bin/kill -HUP $MAINPID\nKillMode=mixed\nKillSignal=SIGTERM\nTimeoutStopSec=60\nExecStart=/usr/local/bin/grin-wallet listen\nRestart=on-failure\nRestartSec=30\n\n[Install]\nWantedBy=multi-user.target\nAlias=grin.service\n</code></pre> <p>Tell systemd to reload (you need to do that every time you edit this file):</p> <pre><code>systemctl daemon-reload\n</code></pre> <p>Now try to start the wallet service:</p> <pre><code>sudo systemctl start grin-wallet\n</code></pre> <p>And check to see if it's running:</p> <pre><code>ps aux | grep grin-wallet\n</code></pre> <p>That should give you two lines of output like this:</p> <pre><code>grin      269149  0.0  0.0 971240 10804 ?        Sl   Aug25   0:00 /usr/local/bin/grin-wallet listen\nubuntu    336964  0.0  0.0   7004  2168 pts/0    S+   22:02   0:00 grep --color=auto grin-wallet\n</code></pre>"},{"location":"wiki/extra-documents/always-listening-wallet/#handling-a-wallet-password","title":"Handling a wallet password","text":"<p>If your wallet is configured with a password, the <code>ExecStart</code> line in <code>grin-wallet.service</code> should probably look something like this...</p> <pre><code>ExecStart=/bin/sh -c 'cat wallet-password.txt | /usr/local/bin/grin-wallet listen'\n</code></pre> <p>Drop you wallet's password in <code>wallet-password.txt</code>. Make sure this file lives in the configured <code>WorkingDirectory</code> and that correct read permissions are set. The contents of this file will be fed into the <code>grin-wallet</code> command.</p>"},{"location":"wiki/extra-documents/always-listening-wallet/#verifying-your-wallet-is-online-and-reachable","title":"Verifying your wallet is online and reachable","text":"<p>Run the following command to get your wallet's address:</p> <pre><code>grin-wallet info\n</code></pre> <p>Grab the address that is displayed and check it with the WALLETCHECK_API_URL</p> <p>More information on grinnode.live</p>"},{"location":"wiki/extra-documents/build-run-automation/","title":"Build and Run Automation","text":"<p>To get an automated build of grin and run the server, pull changes from Github, compile and restart, then run grin as a service. Tested on both Ubuntu 16.04 and Fedora 28.</p>"},{"location":"wiki/extra-documents/build-run-automation/#build-and-run-manually-the-first-time","title":"Build and run manually the first time","text":"<p>Follow the instructions in the build docs to build a binary or download the grin release binary. You should end up with a <code>.grin</code> directory in your home folder.</p>"},{"location":"wiki/extra-documents/build-run-automation/#set-up-grin-as-a-service","title":"Set up grin as a service","text":"<p>Disable the TUI before setting up grin as a service by updating the following line in <code>~/.grin/main/grin-server.toml</code> to <code>false</code>:</p> <pre><code>run_tui = false\n</code></pre> <p>Then create a service file for grin:</p> <pre><code>sudo nano /etc/systemd/system/grin.service\n</code></pre> <p>Paste the following content into the file. Ensure you update it with your own user, group, working directory, and path where you placed the grin binary.</p> <pre><code>[Unit]\nDescription=grin node\nAfter=network.target\n\n[Service]\nWorkingDirectory=/home/alice/.grin/\nUser=alice\nGroup=alice\nPrivateDevices=yes\nType=simple\nExecReload=/bin/kill -HUP $MAINPID\nKillMode=mixed\nKillSignal=SIGTERM\nTimeoutStopSec=60\nExecStart=/home/alice/mimblewimble/grin/target/release/grin\nRestart=on-failure\nRestartSec=30\n\n[Install]\nWantedBy=multi-user.target\nAlias=grin.service\n</code></pre> <p>Tell systemd to reload (you need to do that every time you edit this file):</p> <pre><code>systemctl daemon-reload\n</code></pre> <p>Now try to start the node:</p> <pre><code>sudo systemctl start grin\n</code></pre> <p>And check to see if it's running:</p> <pre><code>ps aux | grep grin\n</code></pre> <p>That should give you two lines of output like this:</p> <pre><code>alice   19175  0.4  0.6 188040 54208 ?        Ssl  17:45   0:07 /home/alice/mimblewimble/grin/target/release/grin\nalice   27481  0.0  0.0  12944  1028 pts/0    S+   18:11   0:00 grep --color=auto grin\n</code></pre> <p>SELinux</p> <p>If you use SELinux in Enforcing mode, the first time you are going to run grin via systemd is going to fail with permission errors. You can grab a profile of those permission errors using <code>audit2allow</code>, create a SELinux policy module for grin, and add that module in SELinux's policies.</p> <pre><code># capture grin AVC denials in a file\n(sudo audit2allow -w -a | ausearch -c grin) &gt; denials.log\n# create a policy module out of the captured denials\n# avoid piping audit2allow to itself due to https://bugs.centos.org/view.php?id=14220\ncat denials.log | audit2allow -M grin\n# set the module in SELinux's policies\nsudo semodule -i grin.pp\n</code></pre> <p>There is an additional thread in grin named <code>peer_connect</code> that also gets denied certain access so it's more likely that you will need to repeat the above process for it as well.</p>"},{"location":"wiki/extra-documents/build-run-automation/#create-an-update-script","title":"Create an update script","text":"<p>Copy this text into a <code>nightly-update.sh</code> script in the same directory as the above:</p> <pre><code>#!/bin/sh\n\ncd /home/alice/mimblewimble/grin\ngit pull\ngit checkout master\ngit fetch --tags\nlatestTag=$(git describe --tags `git rev-list --tags --max-count=1`)\ngit checkout $latestTag\ncargo build --release\nsudo systemctl restart grin\n</code></pre> <p>If you want to be pedantic and build from scratch every time, you can also insert <code>cargo clean</code> before <code>cargo build --release</code>.</p>"},{"location":"wiki/extra-documents/build-run-automation/#set-up-a-cron-job","title":"Set up a cron job","text":"<p>You can set up cron jobs for you the current user by executing:</p> <pre><code>crontab -e\n</code></pre> <p>This will open an editor and let you edit the cron file of the current user. Paste this onto the bottom of the file:</p> <pre><code>0 2 * * * /home/alice/mimblewimble/nightly-update.sh 1&gt; /home/alice/mimblewimble/nightly-update.log 2&gt; /home/alice/mimblewimble/nightly-update.log\n</code></pre> <p>The above puts either success or fail debug output into a file in your main directory. Alternatively, if mail is enabled on your host, you can also have the results emailed to you:</p> <pre><code>0 2 * * * /home/alice/mimblewimble/nightly-update.sh 2&gt;&amp;1 | mail -s \"grin update FAIL\" you@yourdomain.com\n</code></pre> <p>This runs the script from the previous step at 2 am UTC. Please adjust this time with some randomness so your node does not restart at the same time as everyone else.</p>"},{"location":"wiki/extra-documents/build-run-automation/#check-that-it-worked","title":"Check that it worked","text":"<p>Later, after your chosen time of day has passed, you can check that all is working as expected. If you run <code>ps aux | grep grin</code>, you should get one output line that is something like:</p> <pre><code>alice   13065  0.5  1.0 206492 85232 ?        Ssl  02:00   5:30 /home/alice/mimblewimble/grin/target/release/grin\n</code></pre> <p>That means the server is running. Now also check that the latest version was built by running:</p> <pre><code>ls -l ~/mimblewimble/grin/target/release/grin\n</code></pre> <p>That should make it all set to compile and restart every night. Enjoy!</p>"},{"location":"wiki/extra-documents/google-cloud-node/","title":"Grin node on Google Cloud (for free)","text":"<p>Thanks to Google Cloud's Always Free  program, it's possible to create an instance on Cloud Compute that runs a full Grin node, 24/7, without it costing you anything. This is a cheap (free!) and fool-proof way to get a node up and running since it:</p> <ul> <li>Is not dependent on the compatibility of your computer or OS;</li> <li>Does not require you to open up ports on your network;</li> <li>Starts you off from a clean instance; and</li> <li>Allows you to follow instructions that are replicable.</li> </ul> <p>The only requirement is that you are willing to sign up for a Google Cloud account and that you have a valid credit or debit card (which will not be charged).</p> <p>NOTE: This is for testing purposes only. The node is free to run, but if you make mistakes in the configuration you may incur charges. Make sure you monitor your account and billing status regularly whilst running your instance to avoid any unpleasant surprises.</p>"},{"location":"wiki/extra-documents/google-cloud-node/#google-cloud-set-up","title":"Google Cloud Set up","text":"<ol> <li>Visit http://cloud.google.com and set up an account as an individual. This will require a debit or credit card, they do a $1 reserve charge on your card to ensure it's valid. As part of signing up you also get $300 in free trial credit to spend within 12 months.</li> <li>In order to qualify for Always Free you need to have an upgraded account. So ensure you upgrade. Note that this means that you will start to be charged automatically if your spend beyond the $300 in free trial credit. As you will not exceed the Always Free limits here, this point is moot, but keep it in mind for any other projects you use this account for.</li> <li>Launch a Cloud Shell console from your browser, or install the Google Cloud SDK to run Cloud Shell from your local terminal.</li> </ol>"},{"location":"wiki/extra-documents/google-cloud-node/#provisioning-an-instance","title":"Provisioning an instance","text":"<p>From the cloud shell, run the following command to create <code>grin-node1</code>, an always free-compatible instance running Linux Debian 10:</p> <pre><code>gcloud beta compute instances create grin-node1 --zone=us-east1-b --machine-type=f1-micro --tags=grin-node --image=debian-10-buster-v20191210 --image-project=debian-cloud --boot-disk-size=30GB --boot-disk-type=pd-standard --boot-disk-device-name=grin-disk1\n</code></pre>"},{"location":"wiki/extra-documents/google-cloud-node/#building","title":"Building","text":"<p>Your newly created <code>grin-node1</code> should now be visible in your list of Cloud Compute Instances. From there, open an SSH session in your browser by clicking the <code>SSH</code> button, or SSH to the instance through your own terminal.</p> <p>As always, first update your system:</p> <pre><code>sudo apt-get update\n</code></pre> <p>Install some tools:</p> <ul> <li>git</li> <li>pkg-config</li> <li>nano, a simple text editor</li> <li>tmux, which will allow you to run multiple terminal sessions and keep your node running on your instance once you disconnect remotely. See gentle intro  and cheatsheet.</li> </ul> <pre><code> sudo apt-get install git nano tmux pkg-config\n</code></pre> <p>You can now enter a tmux session by <code>tmux</code> and at any time you can close down your connection by <code>CTRL+b</code> and then <code>d</code> as in detach, and then return to it later by <code>tmux a</code> as in attach.</p> <p>Next install all dependencies:</p> <pre><code>sudo apt-get install clang cmake libncurses5-dev libncursesw5-dev zlib1g-dev libssl-dev tor\n</code></pre> <p>Install rust:</p> <pre><code>curl https://sh.rustup.rs -sSf | sh; source $HOME/.cargo/env\n</code></pre> <p>Clone grin and build a release version using the commands below.  First check for the latest release version here.  If v5.2.1 is not the latest release, replace the version number below (\"v5.2.1\") with the latest release version before entering the command.</p> <pre><code>git clone https://github.com/mimblewimble/grin.git\ncd grin\ngit checkout v5.2.1\ncargo build --release\n</code></pre> <p>Building takes ~90 minutes on the <code>grin-node1</code> instance. Slow, but it's free. Good time for a coffee break. Alternatively, you can skip the build process by downloading the latest Grin binary from here.</p> <p>Clone grin-wallet and build a release version</p> <pre><code>cd ~\ngit clone https://github.com/mimblewimble/grin-wallet.git\ncd grin-wallet\ncargo build --release\n</code></pre> <p>Building takes ~60 minutes on the <code>grin-node1</code> instance. Slow, but it's free. Good time for a coffee break. Alternatively, you can skip the build process by downloading the latest Grin binary from here.</p>"},{"location":"wiki/extra-documents/google-cloud-node/#syncing-a-grin-node","title":"Syncing a Grin node","text":"<p>When the build has completed, create a new <code>tmux</code> session and launch your Grin node in it:</p> <pre><code>tmux new -s main\ncd target/release\n./grin\n</code></pre> <p>The node should automatically connect to peers and begin syncing. This might also take a while, so you might want to go for another break.</p> <p>Once completed, the node should be at the same block height as https://grinexplorer.net. We can now detach from the tmux session running the node by pressing <code>ctrl+b</code>, then <code>d</code>. This will allow us to continue interfacing with the gcloud instance command line, with the node running in the background. If you want to check in on the node at a later time, you can attach back into it's tmux session with <code>tmux a -t main</code></p> <p>Optionally, from the cloud shell, open up your node's p2p port so it can receive inbound connections:</p> <pre><code>gcloud compute firewall-rules create main-p2p-port --direction=INGRESS --action=ALLOW --rules=tcp:3414 --target-tags=grin-node1\n</code></pre>"},{"location":"wiki/extra-documents/google-cloud-node/#connecting-to-google-grin-node-from-local-wallet","title":"Connecting to Google Grin node from local wallet","text":"<p>This will allow you to use your wallet quickly and easily without the need to wait for your local node to sync! Follow instructions for setting up a Grin node as above. Once built and synched continue below.</p> <p>To enable external api calls to your Grin node, edit your <code>~/.grin/main/grin-server.toml</code> configuration file on your Google instance:</p> <pre><code>nano grin-server.toml\n</code></pre> <ul> <li>set api_http_addr to <code>0.0.0.0:3413</code> and host to <code>0.0.0.0</code>:</li> </ul> <pre><code>api_http_addr = \"0.0.0.0:3413\"\n</code></pre> <pre><code>host = \"0.0.0.0\"\n</code></pre> <ul> <li>open up your node's api port so it can receive inbound connections</li> </ul> <pre><code>gcloud compute firewall-rules create main-api-port --direction=INGRESS --action=ALLOW --rules=tcp:3413 --target-tags=grin-node1\n</code></pre> <ul> <li>your <code>~/.grin/main/grin-server.toml</code> file on your Google instance will have an api_secret_path field (ex: <code>~/.grin/main/.api_secret</code> unless changed.) Copy the value in the file and save this for later as you will need to provide this to your local wallet.</li> <li>on your local machine, create a new file for storing the api secret from the previous step (ex: <code>~/.grin/main/.remote_api_secret</code>, but can be any location). Save file with key value copied in previous step.</li> <li>now update your local wallet configuration file: set node_api_secret_path to the path of the file created in the previous step (ex: <code>~/.grin/main/.remote_api_secret</code>) and update check_node_api_http_addr with IP address of your Google instance:</li> </ul> <pre><code>api_secret_path = \"~/.grin/main/.remote_api_secret\"\n</code></pre> <pre><code>check_node_api_http_addr = \"http://{YourGoogleCloudIP}:3413\"\n</code></pre> <ul> <li>Restart your node to update configuration changes. Once started, you can run wallet commands which will use your new external node. No need to start your local node and wait for synchronization on each start!</li> </ul> <pre><code>./grin-wallet info\nPassword:\n\n____ Wallet Summary Info - Account 'default' as of height 235438 ____\n\n Confirmed Total                  | 0.000000000\n Awaiting Confirmation (&lt; 10)     | 0.000000000\n Awaiting Finalization            | 0.000000000\n Locked by previous transaction   | 0.000000000\n -------------------------------- | -------------\n Currently Spendable              | 0.000000000\n\nCommand 'info' completed successfully\n</code></pre>"},{"location":"wiki/extra-documents/google-cloud-node/#future-work","title":"Future work","text":"<ul> <li>Updating your node</li> <li>Connecting to Grin-Pool</li> </ul>"},{"location":"wiki/extra-documents/how-to-mine-with-G1-mini-ASIC/","title":"Grin G1 Mini Setup Introductions","text":""},{"location":"wiki/extra-documents/how-to-mine-with-G1-mini-ASIC/#server-connection","title":"Server connection","text":"<ul> <li>Please connect with the Ethernet and power supply as the following shows.</li> </ul> <p>Caution: The server and PC must be in the same network segment, otherwise the IP information returned by the server cannot be received.</p> <p></p>"},{"location":"wiki/extra-documents/how-to-mine-with-G1-mini-ASIC/#find-the-server-ip-address","title":"Find the server IP address.","text":"<p>Download the file Showip.exe.</p> <p>Right click the \u201cShow IP.exe\u201d and run it as Administrator.</p> <p>Press the \u201cIP Report\u201d button on the server for 3-5 seconds and release it.</p> <p></p> <p>The server IP address will be shown as can be seen below:</p> <p></p> <p></p>"},{"location":"wiki/extra-documents/how-to-mine-with-G1-mini-ASIC/#user-login","title":"User Login","text":"<p>Enter the obtained IP address in the browser (Google Chrome is recommended) then enter the administrator account and password: admin in the server login page.</p> <p></p> <p></p>"},{"location":"wiki/extra-documents/how-to-mine-with-G1-mini-ASIC/#network-setting","title":"Network setting","text":"<p>Click Miners-Network Configuration on the left side list, switch the server IP address to DHCP or Static. (Default IP address state is DHCP)</p> <p></p> <p></p>"},{"location":"wiki/extra-documents/how-to-mine-with-G1-mini-ASIC/#pool-setting","title":"Pool Setting","text":"<p>Click Miners-Pool Configuration on the left side list, select coin\uff1aGrin32</p> <p>Available Pool for Grin32 (optional)\uff1a</p> <p>Pool1\uff1astratum+tcp://asia-east-stratum.grinmint.com:3416</p> <p>Pool2\uff1astratum+tcp://us-east-stratum.grinmint.com:3416</p> <p>Pool3\uff1astratum+tcp://grin.always.vip:3344</p> <p>Pool4\uff1astratum+tcp://grin.us.always.vip:3344</p> <p>*For Decentralization and healthy Network, choose other pools please.</p> <p>Pool Worker\uff1aAccording to the\u201csub-accounts\u201dset in the corresponding mining pool account, if the sub-account is ipollo123, the worker should be ipollo123.xxx, the number suffixed used to distinguish the server.</p> <p>The default pool password is 123.</p> <p>After finishing 3 pools setting, click Save&amp;Apply.</p> <p></p>"},{"location":"wiki/extra-documents/how-to-mine-with-G1-mini-ASIC/#check-the-operating-status-of-server","title":"Check the operating status of server","text":"<p>Click Miners-Dashboard to check current server operating status.</p> <p></p> <p>Done!</p> <p>**Instructed by ipollo official</p>"},{"location":"wiki/extra-documents/how-to-mine/","title":"How to mine with grin-miner","text":""},{"location":"wiki/extra-documents/how-to-mine/#prerequisites","title":"Prerequisites","text":"<ul> <li>Linux or MacOS (Windows is not currently supported by grin-miner, though there are some possible alternatives.</li> <li>A relatively recent CPU</li> <li>For mainnet mining, a Recent GPU with 6GB minimum for Cuckaroo29. Nvidia 1080/2080/ti series are known to work well. Support for AMD cards via OpenCL exists but is a recent development.</li> </ul> <p>These instructions also assume you've downloaded and installed the Grin software, are running a synced node, and have initialized and are comfortable with running a wallet.</p>"},{"location":"wiki/extra-documents/how-to-mine/#grin-pow-basics","title":"Grin POW Basics","text":"<p>Grin accepts 2 Proofs-of-Work. Both are variants of a concept called 'Cuckoo Cycle'.</p> <ul> <li>CuckARoo (or ASIC Resistant) is intended to be mined by GPUs. It can be mined using a 6GB+ GPU.</li> <li>CuckAToo (or ASIC Targeted) is intended to be mined by ASICs in the future. It can also be mined using 11GB+ GPUs.</li> </ul> <p>Cuckoo family solvers use something called Graph Size as a parameter. This determines how much memory is needed to mine. CuckARoo uses graphs with 2^29 edges, while CuckAToo uses graphs with 2^31+ edges, hence the different memory requirements.</p> <p>Cuckoo uses number of graphs searched per second, or GPS, to determine how fast someone is mining. You will generally see the term GPS as opposed to Hashrate when using Grin. The terms are used somewhat interchangeably, but GPS is more correct.</p> <p>At launch, Grin will adjust to target 90% of blocks be GPU mined, and 10% ASIC mined. Under current plans, this will gradually change to 0% GPU and 100% ASIC over 2 years.</p>"},{"location":"wiki/extra-documents/how-to-mine/#downloading-the-grin-miner-software","title":"Downloading the grin-miner Software","text":"<p>The latest Grin-miner release can be found on the project Release Page. Binaries are currently provided for Linux and OSX.</p> <p>Distribution-specific releases will likely appear over time, and will be listed here.</p>"},{"location":"wiki/extra-documents/how-to-mine/#installation","title":"Installation","text":""},{"location":"wiki/extra-documents/how-to-mine/#linux-all-distributions","title":"Linux (all distributions)","text":"<p>Download the zipped binary to your machine, and unzip it using the terminal. This will unzip into a directory called <code>grin-miner</code> which contains the <code>grin-miner</code> binary, GPU and CPU mining plugins, and the main configuration file, <code>grin-miner.toml</code>.</p> <p>For now, we'd recommend placing this somewhere relative to your home directory, and editing your path environment variable to ensure the <code>grin-miner</code> executable is available from wherever you run it. All of this can be done by running the following commands in the directory to which you downloaded grin-miner (substituting the grin-miner version number where necessary).</p> <pre><code>tar -C ~/ xzf grin-miner-v1.0.2-480780316-linux-amd64.tgz\necho 'export PATH=~/grin-miner-v1.0.2:$PATH' &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n</code></pre>"},{"location":"wiki/extra-documents/how-to-mine/#running-grin-in-mining-mode","title":"Running Grin in Mining Mode","text":""},{"location":"wiki/extra-documents/how-to-mine/#configure-grins-stratum-mining-server","title":"Configure Grin's stratum (mining) server","text":"<p>In the file <code>~/.grin/main/grin-server.toml</code>, change:</p> <pre><code>enable_stratum_server = false\n</code></pre> <p>to</p> <pre><code>enable_stratum_server = true\n</code></pre>"},{"location":"wiki/extra-documents/how-to-mine/#run-grin-wallet-listener-and-node","title":"Run Grin wallet listener and Node","text":"<p>In one terminal window, run the wallet listener (entering your wallet password when prompted)</p> <pre><code>grin-wallet listen\n</code></pre> <p>In another, run your Grin node:</p> <pre><code>grin\n</code></pre>"},{"location":"wiki/extra-documents/how-to-mine/#configure-grin-miner","title":"Configure grin-miner","text":"<p>All configuration options for the mining plugins can be found, fully documented, in <code>grin-miner.toml</code>. The following steps should work to get most people up and running:</p>"},{"location":"wiki/extra-documents/how-to-mine/#setting-up-grin-miner-for-cpu-mining","title":"Setting up grin-miner for CPU mining","text":"<p>CPU Mining is Enabled by default in the configuration file. You may wish to use the <code>cuckaroo_cpu_avx2_29</code> plugin rather than the default if you have a relatively recent CPU.</p>"},{"location":"wiki/extra-documents/how-to-mine/#setting-up-grin-miner-for-gpu-mining-nvidia","title":"Setting up grin-miner for GPU Mining (Nvidia)","text":"<p>ALWAYS ensure your nvidia drivers are up to date</p> <p>In this section, we will edit the grin-miner settings to mine with your Nvidia GPU.</p> <p>First go to the CUCKAROO (i.e. GPU-Friendly) MINER PLUGIN CONFIGURATION part.</p> <p>Comment out the CPU plugin configuration as follows (by adding # in front of each line):</p> <pre><code>#[[mining.miner_plugin_config]]\n#plugin_name = \"cuckaroo_cpu_compat_29\"\n#[mining.miner_plugin_config.parameters]\n#nthreads = 1\n</code></pre> <p>Then, uncomment the following lines (remove the #in front of each line):</p> <pre><code>[[mining.miner_plugin_config]]\nplugin_name = \"cuckaroo_cuda_29\"\n[mining.miner_plugin_config.parameters]\ndevice = 0\n</code></pre> <p>If you have multiple GPUs you\u2019ll need to copy those four lines for each device and change the device number. You may want to use device numbers in the same PCI Bus ID enumeration order as used by non-CUDA programs like nvidia-smi. To do this set the CUDA_\u200bDEVICE_\u200bORDER environment variable to PCI_BUS_ID in your shell. The default value of this variable is FASTEST_FIRST. More info on this can be found here. Note that this is available only in CUDA 7 and later.</p>"},{"location":"wiki/extra-documents/how-to-mine/#setting-up-grin-miner-for-gpu-mining-amd","title":"Setting up grin-miner for GPU Mining (AMD)","text":"<p>In this section, we will edit the grin-miner settings to mine with your AMD GPU.</p> <p>First go to the CUCKAROO (i.e. GPU-Friendly) MINER PLUGIN CONFIGURATION part and comment the following lines (by adding # in front of each line):</p> <pre><code>#[[mining.miner_plugin_config]]\n#plugin_name = \"cuckaroo_cpu_compat_29\"\n#[mining.miner_plugin_config.parameters]\n#nthreads = 1\n</code></pre> <p>Then go to the CUCKAROO (i.e. ASIC-Resistent) MINER PLUGIN CONFIGURATION part and uncomment the following lines (remove the #in front of each line):</p> <pre><code>[[mining.miner_plugin_config]]\nplugin_name = \"ocl_cuckaroo\"\n[mining.miner_plugin_config.parameters]\nplatform = 0\ndevice = 0\n</code></pre> <p>If you have multiple GPUs you\u2019ll need to copy these 5 lines for each device and change the device number.</p>"},{"location":"wiki/extra-documents/how-to-mine/#running-grin-miner","title":"Running grin-miner","text":"<p>Ensure that your Grin node and wallet are running, then, from your <code>grin-miner-vx.x.x</code> installation directory:</p> <pre><code>./grin-miner\n</code></pre> <p>grin-miner's Test User Interface should appear and display stats for all configured cards.</p>"},{"location":"wiki/extra-documents/how-to-mine/#grin-miner-stats","title":"grin-miner Stats","text":"<ul> <li> <p>Solutions Found is the number of valid cuckoo solutions you have found. Note that this is not the same as finding a block. Only solutions that pass a further difficulty check, (as tested by the Grin stratum server) can be used to solve a block.</p> </li> <li> <p>Accepted is the number of solutions your miners found that were accepted by the stratum server as valid shares (or contributions to the pool,). Again, this does not correspond to number of solved blocks or mining rewards.</p> </li> <li> <p>Rejected is the number of rejected shares. This should be 0, otherwise there is something wrong with your mining plugin or in server communication.</p> </li> <li> <p>Stale is the number of solutions that were found to late (someone else on the network solved the block before the solution was submit).</p> </li> <li> <p>Blocks found is the actual number of blocks that you've solved, that is to say valid cuckoo solutions that passed the difficulty check and were also accepted by the network. If you're mining solo (which you are if you're following this guide,) the rewards in your wallet should be 60 Grins for each block solved.</p> </li> </ul>"},{"location":"wiki/extra-documents/how-to-mine/#mining-cuckatoo","title":"Mining CuckAToo","text":"<p>If you have an 11GB+ GPU. It should be possible to configure your plugins to solve CuckAToo (ASIC-Friendly) blocks at graph size 2^31. As an example:</p> <pre><code>[[mining.miner_plugin_config]]\nplugin_name = \"cuckatoo_mean_cuda_rtx_31\"\n[mining.miner_plugin_config.parameters]\ndevice = 0\nexpand = 2\ncpuload = 1\n</code></pre> <p>You will need to set <code>expand = 2</code> to allow the solutions to be performed with the available GPU memory.</p> <p>Refer to the documentation in <code>grin-miner.toml</code> for further information on how to mine using Cuckatoo31. This Forum Topic discusses chosing between the two PoWs.</p>"},{"location":"wiki/extra-documents/how-to-mine/#cpuload-parameter","title":"<code>cpuload</code> parameter","text":"<p>The <code>cpuload</code> parameter configurable in each CUDA GPU solver reduces the amount of work your CPU has to do during a solve at the expense of solve times.</p> <ul> <li><code>cpuload = 0</code> (default) will solve more slowly but free up more of your CPU</li> <li><code>cpuload = 1</code> will generally solve faster at the expense of CPU load</li> </ul> <p>It's recommended to manually set <code>cpuload = 1</code> for each CUDA solver, unless your encounter specific slowdown issues with your solve times.</p>"},{"location":"wiki/extra-documents/how-to-mine/#mining-pools","title":"Mining Pools","text":"<p>Once you're comfortable with mining grin, you may want to try a mining pool, of which there are several. Note that the Grin Project doesn't run or endorse any of these pools. Please refer to the individual pool's instructions to set up grin-miner.</p>"},{"location":"wiki/extra-documents/monetary-policy/","title":"Monetary Policy","text":"<p>Currently, a new grin is emitted every second, and it's likely to stay that way forever, meaning that the supply inflation rate stays constant. Why? Consider the following points.</p>"},{"location":"wiki/extra-documents/monetary-policy/#its-very-close-to-bitcoin-in-the-first-decade","title":"It's very close to Bitcoin in the first decade","text":"<p>The first four years of Bitcoin emission rate are identical to the first four of Grin. Bitcoin had a full reward for 4 years, followed by half that for the following 4 years. So compared to a constant supply, after 8 years, the total amount of coins emitted is only 25% less. Compare that to daily price fluctuations.</p>"},{"location":"wiki/extra-documents/monetary-policy/#its-more-similar-to-ethereum","title":"It's more similar to Ethereum","text":"<p>Ethereum's reward stayed at 5 ether per block until late 2017. It then changed to 3 ether per block, with plan to 2 ether per block after Constantinople upgrade.</p>"},{"location":"wiki/extra-documents/monetary-policy/#its-even-more-similar-to-gold","title":"It's even more similar to gold","text":"<p>Gold has historically had a linear emission, like Grin. See this graph comparing Bitcoin, Grin, and gold emissions.</p>"},{"location":"wiki/extra-documents/monetary-policy/#new-supply-falls-below-10-after-10-years","title":"New supply falls below 10% after 10 years","text":"<p>Every year that passes makes the overall dilution smaller. After 10 years, this falls below 10%. After 20, below 5%. After 25 years Grin will have 4% supply inflation, the same as Bitcoin 10 years after its genesis (2018).</p>"},{"location":"wiki/extra-documents/monetary-policy/#its-highly-likely-that-at-least-2-of-coins-get-lost-per-year","title":"It's highly likely that at least 2% of coins get lost per year","text":"<p>Multiple studies have shown that a considerable amount of coins get lost, burnt and generally disappear from circulation with no chance to get them back. The rate at which coins get lost has been conservatively estimated at 2%, but is likely slightly higher.</p>"},{"location":"wiki/extra-documents/monetary-policy/#tail-emission-may-be-required-for-long-term-stability","title":"Tail emission may be required for long term stability","text":"<p>Currencies with set supply are extremely experimental. Miners likely need incentives to secure the chain beyond only fees.</p>"},{"location":"wiki/extra-documents/monetary-policy/#sound-money-has-more-to-do-with-transparent-emission-than-a-capped-supply","title":"Sound money has more to do with transparent emission than a capped supply","text":"<p>One of the pitfalls of monetary inflation in fiat currencies is governments can inflate the monetary supply on a whim. This has been used to disastrous effect throughout history. A non-sovereign, open source, consensus based currency solves this issue by making the emission policy well known ahead of time, and makes it difficult if not impossible to change. Based on this definition of soundness, Grin is just as much \"sound money\" as Bitcoin. Removing central authorities with arbitrary control is much more what makes Bitcoin important than the arbitrary amount of its capped supply.</p> <p>Nick Szabo commented on Bitcoin's fixed supply:</p> <p>a wide variety of supply algos would have worked, as long as they are predictable. [\u2026] Security/trust minimization is responsible for more of the value.</p> <p>There are plenty of cryptocurrencies identical to Bitcoin but with smaller capped supplies, how many of them can you name?</p>"},{"location":"wiki/extra-documents/monetary-policy/#inflation-may-make-price-more-stable","title":"Inflation may make price more stable","text":"<p>As an experimental hypothesis, Grin's inflation rate may discourage hoarding early on, improving its distribution. Inflation disincentivizes \"whales,\" who have an inordinate amount of control over the price of an asset, and should act to downplay speculative bubbles and price swings. Early adopters get just as much out of grin as those who adopt later. This argument is discussed at length in Bitcoins are not digital greenbacks, in which Wei Dai himself considers \"Bitcoin to have failed with regard to its monetary policy\". Grin is aiming for as equal access and utility as possible for all users, now and in the future.</p> <p>Constant emission could provide enhanced supply/demand certainty for all types of users, and allow transparent and natural pricing. Note: Bitcoin becoming widely usable as a method of exchange versus a strict store of value depends on the concept of \"Keynesian beauty contests.\" The experiment is ongoing.</p>"},{"location":"wiki/extra-documents/monetary-policy/#there-are-already-better-store-of-values-or-get-rich-quick-coins","title":"There are already better store of values or \"get rich quick\" coins","text":"<p>Grin is focused on privacy, scalability and fairness. If groups or individuals \"get rich quick,\" they will have power to influence the entire grin economy more than others. Grin is not for creating technocrats, but for providing private digital cash to as many people as possible. Hoarding is a huge centralization pressure, and grin emission policy hopes to mitigate this.</p> <p>The idea is to use grin like you use your bicycle, to get you around and make you more efficient, not to store in your garage hoping its value goes up.</p>"},{"location":"wiki/extra-documents/monetary-policy/#it-will-get-forked-into-a-get-rich-quick-coin","title":"It will get forked into a \"get rich quick\" coin","text":"<p>Fine. But the keyword in \"get rich quick\" is quick. Moderate yearly variations in supply are fairly slow in comparison. Grin isn't for getting rich quick.</p>"},{"location":"wiki/extra-documents/monetary-policy/#confidential-assets-allow-parallel-monetary-policies-to-be-soft-forked-in-later","title":"Confidential Assets allow parallel monetary policies to be soft-forked in later","text":"<p>If the current monetary policy is keeping you from contributing to Grin, you should still stick around. Confidential Assets, an invention by early Mimblewimble contributor Andrew Poelstra, allow alternative assets (with differing cryptography, emission rates, and more; including coins pegged to other assets/blockchains) to be added to Grin later on via soft fork. These assets add very little to the chain size, make all other assets (like the native grin token) more private, and can be embraced or ignored as one wishes without compromising any other asset (grin or otherwise) on the chain. Grin is a minimal Mimblewimble implementation, but it will grow and evolve. Mimblewimble is nimble.</p>"},{"location":"wiki/extra-documents/monetary-policy/#we-are-in-the-early-days-of-cryptoeconomics","title":"We are in the early days of cryptoeconomics","text":"<p>Experiments in transparent, collaborative monetary policies are very immature. Bitcoin is only ten years old and the experiment is still going strong. The time is ripe not for copycat experiments, but novel variations. Only time will tell, but the sooner we start running alternative monetary policy experiments the sooner we get useful data.</p> <p>There are only ~28 million Bitcoin wallets today (many of them not in active use, or secondary wallets for single users). That means less than one-half of one percent of the global population has their own wallet. Because you are here means you care about the entire premise of cryptocurrencies, it is important to be open minded when things are so new and uncertain.</p> <p>Onward.</p>"},{"location":"wiki/extra-documents/monetary-policy/#further-discussion","title":"Further discussion","text":"<p>There is a long discussion regarding Grin's monetary policy in the community forum.</p> <p>Igno's thoughts on soliciting productive feedback:</p> <p>With respect to this whole thread and future ones, if you want to provide constructive criticisms on the emission curve, at least give it some decent thoughts. Repeating what you read on Reddit doesn\u2019t count.</p> <p>To be more specific:</p> <ul> <li>At a minimum consider the loss rate when building supply curve. Ever wondered at which point 50% of those 21M bitcoins will have disappeared, for example?</li> <li>Compare with other slow emission coins. After 8 years, grin only has 25% more supply than bitcoin or, to pick something more recent, zcash. Argue why this matters (or not).</li> <li>Compare with fast emissions coins. Monero had over half emitted in 17 months. How does that affect long term adoption? How about use?</li> <li>Rich lists and coin decentralization. What affects them.</li> <li>Analyze average crypto user and investor behavior. How does multi-year emission curves, fast or slow, influence them? What are the real adoption drivers, both long and short term?</li> <li>Do not use econ101 in your arguments. That can be used to argue anything and its opposite equally well. And before telling us we don\u2019t understand economics, convince Nouriel. Then maybe I\u2019ll listen.</li> <li>Consider different strategies and how they can play the strengths or weaknesses of various blockchains. What is the effect on Ethereum when daily supply is hard forked for example?</li> <li>Facts and real research. Unsubstantiated opinions are a nanogrin a dozen.</li> </ul> <p>The grin team is earnest, if you can provide well substantiated real research that shows a different supply curve would be be better for grin, we will most definitely listen. But don\u2019t think you can flyby post your knee-jerk reaction 5 min after having heard of grin, which we\u2019ve spent the last 2 years building, and expect us to listen to you.</p> <p>Informed ideas are more than welcome!</p>"},{"location":"wiki/extra-documents/nomenclature-bs/","title":"Nomenclature BS","text":"<p>By 0xb100d, Oct 8 2018</p> <p> \"It's like a finger pointing away to the moon. Do not concentrate on the finger or you will miss all of the heavenly glory!\" Bruce Lee.</p> <p>The technology is cool, and that's what this project is about, THE WAY is nameless, as they say. Words obfuscate and obstruct, so why not embrace that reality by maintaining a nomenclature of quirky wizard/witch vibes, shrouded in a light and funky aloofness? I think packaging up what aims to be a key to international freedom in a somewhat silly package is like a spoonful of sugar to help the medicine go down. Funny names are an invisibility cloak.</p> <p>If it weren't explicitly useful (in my opinion) to name things unconventionally, and if there was not already a magical-theme happening within the project, it would not be worth pursuing. But as we have already stepped in it, so to speak, there are many things we can do to \"unBrand\" the project in an effective way.</p> <p>We obviously don't want to cross the line into copyright infringement. There are plenty of historical and wizardly themes to chose from that are not strictly inspired by modern novels.</p> <p>Some discussion:</p> <ul> <li>https://forum.grin.mw/t/meeting-notes-governance-aug-15-2018/644</li> <li>https://forum.grin.mw/t/technomity-new-members/635</li> </ul> <p>GRIN (GOBLINS' Righteous Intergalactic Network)</p>"},{"location":"wiki/extra-documents/nomenclature-bs/#council-name","title":"Council Name","text":"<p>What do we call the \"technomity\" aka the Council of Grin, given it certainly doesn't matter, and there are so many fun witchy things to choose from? This group will be cited by name when future upgrades, discussions, and decisions arise. Some ideas:</p> <ul> <li>The GAMUT (GOBLINs Adhocratic Magical Undertakings Thing) (Who runs the GAMUT? https://en.wiktionary.org/wiki/run_the_gamut) https://en.wikipedia.org/wiki/Thing_(assembly) also referencet to supreme wizard court in harry potter, the Wizengamot. https://en.wikipedia.org/wiki/Adhocracy</li> <li>Prefects or pr\u00e6fectus/praefectus/praefectii- leadership, appear in harry potter books as upperclassmen.</li> <li>Spontaneous Order of GOBLINS</li> <li>GOBLINS (GRIN's Own Beaurocracy of Laborers, Improvers, Nurturers and Scientists or GRIN's Own Beurocracy of Learned Integrators Negotiators and Scientists)</li> <li>Ministry of Mages</li> <li>Coven of Alchemical Liason Maintainance (CALM... keep CALM and carry wands).</li> <li>The Spontaneous Order of Unknown Leaders (SOUL, https://en.wikipedia.org/wiki/Spontaneous_order#Markets )</li> <li>The Stygmergic Syzygy</li> <li>Institute of Broom and Wand Design</li> <li>Magical Undertakings of Money (MUMs the word!)</li> <li>P.O.W.O.W. (which could stand for The POWOW Order of Wizards Ongoing Work\u2026 which has that nice nested GNU thing\u2026 and actually we\u2019ve already been calling it the powow\u2026 plus the connotations for proof of work, POW, and pain, OW\u2026 but is probably insensitive to native americans)</li> <li>Sobornost (\u201cthe combination of freedom and unity of many persons on the basis of their common love for the same absolute values.\u201d, https://en.wikipedia.org/wiki/Sobornost)</li> <li>Synod (church council)https://commons.wikimedia.org/wiki/Category:Alchemical_symbols</li> <li>Conventicle (https://en.wikipedia.org/wiki/Conventicle)</li> <li>Conciliabulum (https://en.wikipedia.org/wiki/Conciliabulum)</li> <li>navem civitatis - ship of state (Platos coinage of philosopher king)</li> <li>technicorum magorum\u2122 - technocracy of magi</li> <li>Ministry of Magi (MOM said!)</li> <li>Convention of Wizards (COW goes MU (Mimblewimble Undertakings))</li> <li>Chamber of Intermagical Affairs, aka the CIA?</li> <li>Assembly of Seers? Seer Association? Seers, Robust &amp; Company?</li> </ul>"},{"location":"wiki/extra-documents/nomenclature-bs/#walletminer-names","title":"Wallet/Miner Names","text":"<p>These are all totally free to use for any efforts.</p> <ul> <li>Wink</li> <li>Nod</li> <li>Smirk</li> </ul>"},{"location":"wiki/extra-documents/nomenclature-bs/#mascot-names","title":"Mascot Names","text":"<ul> <li>Cuthru</li> <li>Langlock</li> <li>Alice</li> <li>Chesire Cat (immensely cool and in public domain: https://upload.wikimedia.org/wikipedia/commons/8/8a/Arthur_Rackham_Cheshire_Cat.jpeg)</li> </ul>"},{"location":"wiki/extra-documents/nomenclature-bs/#currency-name-solved","title":"Currency name [Solved]","text":"<p>In what units do we measure the grin currency?</p> <ul> <li>grins (milli, micro, etc).</li> <li>Winks and Nods?</li> </ul>"},{"location":"wiki/extra-documents/nomenclature-bs/#currency-symbol","title":"Currency Symbol","text":"<p>Discussion: https://forum.grin.mw/t/currency-symbol-other-bs/484</p> <ul> <li>we could do something absolutely evil and commandeer the symbol for generic currency... \u00a4 ... \u00a4333 .... https://en.wikipedia.org/wiki/Currency_sign_(typography) it is the universal ISO symbol for money............................... i feel like i've peekend inside pandora's box. GOODNESS I like this one. It's like a glitch in the matrix.... and very philosophicala symbolic.</li> </ul> <p>Roman Czyborra writes in his Good ole' ASCII that \"the socialist countries managed to substitute the international currency sign \u00a4 for ASCII's capitalist dollar sign $ in the the first international reference version ISO-646-IRV\". However, the international currency symbol \u00a4 was proposed for inclusion in the international standard character code in place of the dollar or pound sign by the Italian delegation to the CCITT, not by the socialist countries. In a later vote, Italy, Portugal, Switzerland, and the USSR favored the use of the \u00a4 character; Canada, France, Germany, the Netherlands, Sweden, and the United Kingdom preferred to standardize the $ and \u00a3 signs. Sources: CCITT Working Group on Alphabets, October 6-9, 1964, CBI 67, box 3, folder 3; ISO TC 97/SC 2 and CCITT/GM ALP joint meeting, April 26-28, 1966, NMAH 310, box 5.</p> <p>and now some other resources I've found... and some symbols that stand out. There are lots of options and I am 100% of the belief that the perfect one can jump out at us like a mystical epiphany, and that bikeshedding isn't as arduous and arbitrary as it always seems to be.</p> <p>From this document: https://folk.uib.no/hnooh/mufi/specs/MUFI-Alphabetic-4-0.pdf</p> <ul> <li>\uead0 &amp;grlig; EAD0 PUA-1 LATIN SMALL LIGATURE GR doesnt show</li> </ul> <p>These are very good old English... very in the style of. http://www.wikiwand.com/en/Insular_G</p> <ul> <li>\u1d79 &amp;gins; 1D79 PhonExt LATIN SMALL LETTER INSULAR G</li> <li>\ua77d &amp;Gins; A77D LatExtD LATIN CAPITAL LETTER INSULAR G</li> <li>\ua77f &amp;ginsturn; A77F LatExtD LATIN SMALL LETTER TURNED INSULAR G</li> <li> <p>\ua77e &amp;Ginsturn; A77E LatExtD LATIN CAPITAL LETTER TURNED INSULAR G</p> </li> <li> <p>\ua7ff &amp;M5leg; A7FF LatExtD LATIN EPIGRAPHIC LETTER ARCHAIC M 199\ua7ff  aka \ua7ff  aka mimblewimble. that one is confusing and cool</p> </li> <li> <p>\u00f8 \u00f8 00F8 Lat1Suppl LATIN SMALL LETTER O WITH STROKE</p> </li> <li> <p>\u00d8 \u00d8 00D8 Lat1Suppl LATIN CAPITAL LETTER O WITH STROKE 243\u00d8 for a piece of bread a symbolic cut-through... the $ sign is pretty abstract, ours needn't be a G at all. looks like a zero though, not great.</p> </li> <li> <p>\u0289 &amp;ubar; 0289 IPAExt LATIN SMALL LETTER U BAR 777\u0289 its like the S with a line through it $, but its a u, kind of like a little smile with a cuthru</p> </li> <li> <p>\u1efd &amp;vwelsh; 1EFD LatExtAdd LATIN SMALL LETTER MIDDLE-WELSH V looks kind of like a G when rendered differently</p> </li> <li> <p>\u02e3 &amp;xmod; 02E3 SpModLet MODIFIER LETTER SMALL X 420\u02e3  to pay the bills</p> </li> <li> <p>\u25cc\u035c\u25cc &amp;combdblbrevebl; 035C CombDiaMk COMBINING DOUBLE BREVE BELOW this one not sure if it shows but its like a fallen over right parenthesis... looks like a grin... pretty awesome! literally you write the number of grin syou have and underline it with a little grin, ha!</p> </li> <li> <p>\u221e \u221e 221E MathOp INFINITY 42\u221e  worth of wine please!</p> </li> <li> <p>\u23d1 &amp;metrshort; 23D1 MiscTech METRICAL BREVE its the cutest little grin 55\u23d1</p> </li> <li> <p>\uf717 &amp;metrbrevedblac; F717 PUA-10 METRICAL SYMBOL BREVE WITH DOUBLE doesnt show but its a smiley</p> </li> <li> <p>The spesmilo character, called  spesmilsigno  in Esperanto (like monero's use of esperanto) https://en.wikipedia.org/wiki/Spesmilo looks like an S with a little m in it.</p> </li> <li> <p>The  mill  or ( \u20a5 ) an m with a cuthru https://en.wikipedia.org/wiki/Mill_(currency)</p> </li> </ul> <ul> <li> <p>of course unicode alchemical symbols would be appropriate too https://en.wikipedia.org/wiki/Alchemical_symbol https://www.unicode.org/charts/PDF/U1F700.pdf 500\ud83d\udf50 looks like a magic wand</p> </li> <li> <p>\u263a its just a little unicode smiley face, this would be perfect</p> </li> <li> <p>\u267e its like an infinity symbol in a circle.. looks kind of like a smiley... and is the symbol for acid free paper I need 699\u267e! Grin, that acid free paper currency!!! also means PERMANENT PAPER... which is a good symbol for a cashlike currency probably.</p> </li> <li> <p>\u2639 this one is hilarious, its like a big  sad face</p> </li> <li> <p>\u2604 looks like a harry potter golden snitch 900\u2604 please!</p> </li> </ul> <p>now from https://www.unicode.org/charts/PDF/U2600.pdf</p> <ul> <li>\u26a1like harry potters lightning bolt</li> <li>\u26c0 i think that's supposed to be a coin</li> <li>\u2652 mw looking</li> <li>\u2687 a partial smiley</li> <li>\u2639\u263a.. first is a sad face second is a smiley... for some reason the sad one is bigger</li> <li>\ud83d\ude42... slightly smiling face... that one renders really well \ue231* \ud83d\ude41  slightly frowning</li> <li>\u263b ooh this one is good... its the dark version of the smiley</li> <li> <p>\u262f yin yang... mimble wimble</p> </li> <li> <p>\u231a a little watch... time is money 1\u231a /second</p> </li> <li>\u231b  hourglass... time is still money... 9,000\u231b   please!</li> <li>\ud83c\udf1e *wow!* sun with face... that one is pretty good.</li> </ul> <p>feeling more and more like picking something simple like the letter G is the wrong choice. what fun to have so much creative freedom...and people may  be writing it on checks and the tip line of receipts!</p> <ul> <li>\u2620 skull and cross bones... theres a grin in there somewhere</li> <li>\ud83d\udd71  another render, supposed to be b lack</li> <li> <p>\u0fca  a Tibetan symbol</p> </li> <li> <p>\ud83d\ude36 *WOW symbol for face without a mouth!!!!!!</p> </li> <li> <p>\u269d a little bit wizardly.. the pentagram... \u26e5 \u26e4 just a white rectangle \u25ad 900\u25ad</p> </li> <li>\u29de infinity negated with a vertical bar</li> <li>\u26b2 neuter symbol</li> <li> <p>\u26bf squared key</p> </li> <li> <p>\u26d1 helmet</p> </li> <li> <p>\u26d3 those are supposed to be chains... that's kind of cool you know, blockchain.</p> </li> <li> <p>\u26b5 looks like a magic wand</p> </li> </ul> <p>some more here: https://commons.wikimedia.org/wiki/Category:Alchemical_symbols though they are not easily accessible unicode</p> <p>https://commons.wikimedia.org/wiki/Category:Mercury_symbols mercury is a communication symbol... money is a very pure form of communication</p> <p>some good ones in there. almost entirely sure that using something as ancient as a Latin letter would be a missed opportunity. Why wouldnt the currency of the future have an emoji as a symbol????? I mean of course it would. We are designing the ultimate cash for the digital age, it should look like a product of the internet in every way right?</p> <p>someone on reddit said the MW-Eyed smiley logo looks too much like a meme... but that is what we are making right, an infectious meme. currency itself is a meme!</p> <p>will never forgive myself now if we don't pick something great.</p>"},{"location":"wiki/extra-documents/regarding-foundations/","title":"Regarding Foundations","text":""},{"location":"wiki/extra-documents/regarding-foundations/#introduction","title":"Introduction","text":"<p>Official Foundations are sometimes seen as an obvious 'must-have' requirement for any serious cryptocurrency project. The purpose of this document is to evaluate whether there's just cause for such a foundation in the context of the Grin project. Experiences from other crypto projects are considered, followed by identifying the potential use cases a foundation is supposed to solve for. Each of these are then discussed in the context of a foundation, and what the alternative to that could be.</p> <p>It should be pointed out that it's not possible or intended to prevent foundations from being set up. Any individual, group, or other entity may freely decide to set up a foundation, as is it within their right. What's being evaluated is rather whether a foundation in \"official\" capacity can be mandated or not.</p>"},{"location":"wiki/extra-documents/regarding-foundations/#current-status","title":"Current status","text":"<p>September 13, 2018: There are no current or future plans to create an official Grin Foundation. Other entities wishing to set up foundations or other organisations with intentions to support the project are welcomed.</p>"},{"location":"wiki/extra-documents/regarding-foundations/#selected-experiences-of-other-projects","title":"Selected experiences of other projects","text":"<ul> <li>Bitcoin Foundation has been mired in controversies regarding its leadership and received cease and desist letters from US institutions.</li> <li>The Tezos Foundation ended up in a vicious legal dispute with the project founders whilst some $400m in funds at the time were locked.</li> <li>The Monero community opted not to create a foundation in the first place, this post sums up some of the thinking behind this.</li> <li>Aragon has announced that they seek to work towards decentralising their foundation and reducing its responsibilities.</li> <li>Zcash Foundation has published results from their Governance process, which sheds light into some of their activities, challenges, and feedback from their community. Their mission statement identify Community, Protocol/Governance, and Science as the three key pillars of the foundation. A recently expressed goal by the Foundation board was to \"exist long enough to become irrelevant / unnecessary\".</li> <li>MakerDAO have announced a a foundation proposal as part of their Maker Governance Framework. As part of their proposal, 'gradual decentralisation' is to be realised through the work of the foundation.</li> <li>Cardano Foundation representative's issue.</li> </ul>"},{"location":"wiki/extra-documents/regarding-foundations/#possible-foundation-use-cases","title":"Possible Foundation Use Cases","text":"<ul> <li>To own/manage assets. Owning assets that are valuable to the community, such as domain names, trademarks, IP, Login info, account privileges, art  &amp; media assets etc.</li> <li>To act as official representative. A spokesperson of sorts for the project. For PR &amp; media related enquiries. Issuing \"official\" statements.</li> <li>To offer legal protection. Assume legal liability for the project in order to deflect and protect developers and others in the community from being sued or targeted for legal prosecution.</li> <li>To offer legal advice. Legal counsel used to offer advice to community members and support in the event of legal conflicts.</li> <li>To accept charitable donations. A destination for community members to send donations to that can then be used to promote the project's interests.</li> <li>To fund development projects and research. Using donations and foundation resources to fund development efforts that are important for the project. Fund research efforts.</li> <li>To educate, lobby, network. To educate authorities about what the protocol does and doesn't do, to make arguments to politicians about why they should not try to ban privacy coins, to demonstrate how the project is compliant with a local regulation, to participate in  alliances with other charitable organisations that value privacy, etc.</li> <li>To nurture and grow the community. Community building exercises, conferences, symposiums, supporting meet ups, hosting speakers, etc.</li> <li>To make protocol/governance related decisions. Contentious topic. Some foundations explicitly avoid taking an active role in governance. Others seem more active and responsible in \"steering\" the community and offering advice in times of hard forks and protocol conflicts.</li> </ul>"},{"location":"wiki/extra-documents/regarding-foundations/#weighing-different-approaches","title":"Weighing different approaches","text":"Using a foundation Not using a foundation To own/manage assets <ul><li>Straight forward.<li>Does not ensure assets are managed the right way.<li>Can act as a deterrent for abuse/infringement. <ul><li>What are the assets that have to be owned by a central entity? Are there alternatives?<li>Trademarks and IP will be difficult to protect and enforce and requires active defending. Does the project need to own trademarks?<li>Redundancy for account access, privileges, etc. might possible to be handled in the community.<li>How can domains be owned without a central entity? Do they need to be? To act as official representative <ul><li>Might make marketing/pr easier.<li>Does it make sense to have a central entity speaking for the entire project?<li>Does a central, official representative make an easy target for harassment by law enforcement? <ul><li>Opting not to have an official representative can be a deliberate design decision.<li>If the community really feel that a spokesperson is important, this can be appointed without the need for a foundation.<li>Similarly, statements can also be drafted and issued through a community effort. To offer legal protection <ul><li>Will require significant legal effort to draft air-tight defence.<li>To what extent would a foundation then need to have authority over the project? Is that in conflict with governance models? Does it make the project centralised? <ul><li>What is the real risk for developers and community members?<li>Can a foundation prevent individuals from being targeted? To offer legal advice <ul><li>How likely is there that the foundation will employ permanent counsel? <ul><li>By not avoiding a central organisation, can legal risk be reduced?<li>Fundraising by the community could support developers who get into legal trouble.<li>This would allow legal advice to be better tailored to the needs of the individual and the circumstance. To accept charitable donations <ul><li>Does it make sense to raise funds without stating explicitly how they are to be spent?<li>Can the overhead of a foundation be justified?<li>There may be tax benefits by registering as a charitable foundation.<li>There is real risk for misappropriation of funds. <ul><li>Community 'slush funds' can still be organised.<li>Setting this up as a decentralised entity can be a challenge.<li>Who decides how funds are spent? To fund development projects and research <ul><li>Who decides what projects to fund?<li>Can the overhead of a foundation be justified for this?<li>What does it mean in terms of centralisation? <ul><li>Monero's FFS model is an example of community funding without a centralised foundation structure.<li>There are also other alternatives for funding open source projects. To educate, lobby, network <ul><li>There's a logic for why a central, official, organisation will have greater chance of success in these efforts.<li>Community efforts will be harder to get focused and organised around specific causes. <ul><li>Nothing is preventing interest organisations from forming around specific causes and missions, including the Grin project itself. These can lobby and influence as required. But would not do so in any official capacity of the foundation. To nurture and grow the community <ul><li>A foundation can designate resources to be responsible for this on a continuous basis.<li>Paying for professionals to work on this might lead to more professional activities and increase performance.<li>It may also centralise decision making around the direction the community should grow in and introduce bias. <ul><li>It seems intuitive to expect the community to take care of itself in a decentralised project.<li>This however also assumes the community is engaged and committed to put in the effort required.<li>On the other hand, if the community is not, then a centralised community management function will have little impact either way. To make protocol/governance related decisions <ul><li>A foundation can be the \"last resort\", ready to step in to take responsibility in times of crisis or extra-ordinary events.<li>Can ensure that there is proper planning, and that the project is progressing.<li>Can suffer from legitimacy issues. Might struggle to make decisions that are in line with the will of the community, and therefore lead to friction or forks. <ul><li>The community can make these decisions, assuming a governance model is in place that functions and is seen as legitimate by the community.<li>Easier said than done correctly, though."},{"location":"wiki/extra-documents/regarding-foundations/#concluding-remarks","title":"Concluding remarks","text":"<p>There are many use cases where foundations may be useful. In general, it seems however that a foundation is not a prerequisite to solve for these, and that they also can be solved on a per case basis via an engaged and committed community. It's not clear that a foundation will do a better job. Having a foundation creates overhead and centralises power and authority into a physical legal entity.  For a project that strives to be decentralised, this seems contradictory. On the other hand, there are efficiency and accountability benefits that can be realised with a professionally run foundation compared to community efforts carried out ad-hoc, which may or may not be done properly. There's a real trade-off there and the community should decide what is valued most.</p>"},{"location":"wiki/extra-documents/story-of-distribution/","title":"Story of Distribution","text":"<p>Stories are important; We often commemorate them, and they broadly impact our perception.</p> <p>Bitcoin's story of inception cannot be matched in its perfection. Its story of distribution however, will remain flawed, gradually turning into a bigger stain with each passing year. Aside from its clear financial implications, it presents an unwelcoming &amp; discouraging narrative to new adopters, as if they are valued less than the previous ones.</p> <p>Grin's decision to set itself apart in its story of distribution is controversial, but nevertheless an invaluable distinguishing factor in forming a more positive and welcoming narrative for Grin in its future.</p> <p>Stories never die. A story of fairness &amp; moderation contrasted with that of quick enrichment for early users will remain rewarding for Grin, as it seeks to claim relevance for years to come.</p>"},{"location":"wiki/extra-documents/user-stories-use-cases/","title":"User Stories Use Cases","text":"<p>By sesam, Jun 29 2018</p> <p>Or, how non-developers are expected to use and abuse the grin software.</p> <p>In #750 we're calling for help with a user guide.</p> <p>Users often want to get started trying things out, instead of reading instructions.</p> <p>The now modern on-boarding screens/animations that just take seconds to click through are often ignored or furiously clicked at to make them go away.</p> <p>For users, the nicest option is to just pick out the software and start using it.</p> <p>Then, the best guide is perhaps one that follows the user and suggests what the user can do next, without forcing the user to do anything special.</p> <p><code>git</code> is an example of a hard-to-understand blockchain-ish transaction-ish application that gives its users small hints on correcting user mistakes and getting good configuration settings where good defaults are not an option.</p>"},{"location":"wiki/extra-documents/user-stories-use-cases/#how-will-the-first-non-crypto-fans-be-able-to-use-grin","title":"How will the first non-crypto fans be able to use grin?","text":""},{"location":"wiki/extra-documents/user-stories-use-cases/#sym-the-gym-coach","title":"Sym the gym coach","text":"<p>Background story: As a coach, things not on the mobile phone are not usable. Sym only uses the web wallet to spend and earn grins with some friends who are also testing this out. One of them installed grin on the gym hall's reception computer, so it's mining some grins and helps heating the space during the winter months.</p> <p>Use cases:</p> <ul> <li>Open the web wallet on mobile.</li> <li>Look at the wallet balance.</li> <li>Send some of the mined coins to Roe (who in turn brings bottled drinks that the gym then can sell to its customers)</li> <li>Accept payments for drinks in grin, with the web wallet emitting different sounds for different incoming transactions (Example: \"cheers!\" for each incoming drink payment, or \"eet smakelijk\" for sandwich payments), making it possible for Sym to both work with customers and keep an eye and ear on the almost automated snacks bar side-business.</li> </ul>"},{"location":"wiki/extra-documents/user-stories-use-cases/#pat-the-internet-cafe-attendant-somewhere-in-asia","title":"Pat the internet caf\u00e9 attendant somewhere in Asia","text":"<ul> <li>The cafe's computers, when idle, run a \"screen saver\" that activates the grin-goldminer, ensuring the investment in good gaming computers is never cooling down too much. The caf\u00e9 customers like it warm and toasty.</li> <li>Whether not trusting its multiple ISP uplinks or wanting to save on bandwidth, the caf\u00e9 maintains its own local mining pool. That pool connects to 4 full grin nodes on different continents, making sure that even the worst possible internet weather and cut under-sea cables can't interrupt the continuous flow of grin blocks.</li> </ul>"},{"location":"wiki/extra-documents/user-stories-use-cases/#misty-the-museum-owner","title":"Misty the museum owner","text":"<ul> <li>As a somewhat idealistic person, Misty accepts entrance fee payments in just about any Mimblewimble coin and most testnet coins.</li> <li>On a glass shell in the corner stands a great though aged open computer case with a name tag \"The Yeastmonster\" subtexted \"The First Great Grin Miner\". Most visitors feel its importance and snap a photo before moving along to the graphical user interfaces exhibition hall, but only those with testnet grins can pay to the monster directly to get it to start up its text UI and mine for one minute.</li> </ul>"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/","title":"Technical Introduction to Mimblewimble","text":""},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#tongue-tying-for-everyone","title":"Tongue Tying for Everyone","text":"<p>This document is targeted at readers with a good understanding of blockchains and basic cryptography. With that in mind, we attempt to explain the technical buildup of Mimblewimble and how it's applied in Grin. We hope this document is understandable to most technically-minded readers. Our objective is to encourage you to get interested in Grin and contribute in any way possible.</p> <p>To achieve this objective, we will introduce the main concepts required for a good understanding of Grin as a Mimblewimble implementation. We will start with a brief description of some relevant properties of Elliptic Curve Cryptography (ECC) to lay the foundation on which Grin is based and then describe all the key elements of a Mimblewimble blockchain's transactions and blocks.</p>"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#tiny-bits-of-elliptic-curves","title":"Tiny Bits of Elliptic Curves","text":"<p>We start with a brief primer on Elliptic Curve Cryptography, reviewing just the properties necessary to understand how Mimblewimble works and without delving too much into the intricacies of ECC. For readers who would want to dive deeper into those assumptions, there are other opportunities to learn more.</p> <p>An Elliptic Curve for the purpose of cryptography is simply a large set of points that we will call C. These points can be added, subtracted, or multiplied by integers (also called scalars). Given such a point H, an integer k and using the scalar multiplication operation we can compute <code>k*H</code>, which is also a point on curve C. Given another integer j we can also calculate <code>(k+j)*H</code>, which equals <code>k*H + j*H</code>. The addition and scalar multiplication operations on an elliptic curve maintain the commutative and associative properties of addition and multiplication:</p> <pre><code>(k+j)*H = k*H + j*H\n</code></pre> <p>In ECC, if we pick a very large number k as a private key, <code>k*H</code> is considered the corresponding public key. Even if one knows the value of the public key <code>k*H</code>, deducing k is close to impossible (or said differently, while multiplication is trivial, \"division\" by curve points is extremely difficult).</p> <p>The previous formula <code>(k+j)*H = k*H + j*H</code>, with k and j both private keys, demonstrates that a public key obtained from the addition of two private keys (<code>(k+j)*H</code>) is identical to the addition of the public keys for each of those two private keys (<code>k*H + j*H</code>). In the Bitcoin blockchain, Hierarchical Deterministic wallets heavily rely on this principle. Mimblewimble and the Grin implementation do as well.</p>"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#transacting-with-mimblewimble","title":"Transacting with Mimblewimble","text":"<p>The structure of transactions demonstrates a crucial tenet of Mimblewimble: strong privacy and confidentiality guarantees.</p> <p>The validation of Mimblewimble transactions relies on two basic properties:</p> <ul> <li>Verification of zero sums. The sum of outputs minus inputs always equals zero,   proving that the transaction did not create new funds, without revealing the actual amounts.</li> <li>Possession of private keys. Like with most other cryptocurrencies, ownership of   transaction outputs is guaranteed by the possession of ECC private keys. However,   the proof that an entity owns those private keys is not achieved by directly signing   the transaction.</li> </ul> <p>The next sections on balance, ownership, change and proofs details how those two fundamental properties are achieved.</p>"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#balance","title":"Balance","text":"<p>Building upon the properties of ECC we described above, one can obscure the values in a transaction.</p> <p>If v is the value of a transaction input or output and H a point on the elliptic curve C, we can simply  embed <code>v*H</code> instead of v in a transaction. This works because using the ECC operations, we can still validate that the sum of the outputs of a transaction equals the sum of inputs:</p> <pre><code>v1 + v2 = v3  =&gt;  v1*H + v2*H = v3*H\n</code></pre> <p>Verifying this property on every transaction allows the protocol to verify that a transaction doesn't create money out of thin air, without knowing what the actual values are. However, there are a finite number of usable values (transaction amounts) and one  could try every single  one of them to guess the value of the transaction. In addition, knowing v1 (from a previous transaction for example) and the resulting <code>v1*H</code> reveals all outputs with value v1 across the blockchain. For these reasons, we introduce a second point G on the same elliptic curve (practically G is just another generator point on the same curve group as H) and a private key r used as a blinding factor.</p> <p>An input or output value in a transaction can then be expressed as:</p> <pre><code>r*G + v*H\n</code></pre> <p>Where:</p> <ul> <li>r is a private key used as a blinding factor, G is a point on the elliptic curve C and   their product <code>r*G</code> is the public key for r (using G as generator point).</li> <li>v is the value of an input or output and H is another point on the elliptic curve C,   together producing another public key <code>v*H</code> (using H as generator point).</li> </ul> <p>Neither v nor r can be deduced, leveraging the fundamental properties of Elliptic Curve Cryptography. <code>r*G + v*H</code> is called a Pedersen Commitment.</p> <p>As an example, let's assume we want to build a transaction with two inputs and one output. We have (ignoring fees):</p> <ul> <li>vi1 and vi2 as input values.</li> <li>vo3 as output value.</li> </ul> <p>Such that:</p> <pre><code>vi1 + vi2 = vo3\n</code></pre> <p>Generating a private key as a blinding factor for each input value and replacing each value with their respective Pedersen Commitments in the previous equation, we obtain:</p> <pre><code>(ri1*G + vi1*H) + (ri2*G + vi2*H) = (ro3*G + vo3*H)\n</code></pre> <p>Which as a consequence requires that:</p> <pre><code>ri1 + ri2 = ro3\n</code></pre> <p>This is the first pillar of Mimblewimble: the arithmetic required to validate a transaction can be done without knowing any of the values.</p> <p>As a final note, this idea is actually derived from Greg Maxwell's Confidential Transactions, which is itself derived from an  Adam Back proposal for homomorphic values  applied to Bitcoin.</p>"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#ownership","title":"Ownership","text":"<p>In the previous section we introduced a private key as a blinding factor to obscure the transaction's values. The second insight of Mimblewimble is that this private key can be leveraged to prove ownership of the value.</p> <p>Alice sends you 3 coins and to obscure that amount, you chose 28 as your blinding factor (note that in practice, the blinding factor being a private key, it's an extremely large number). Somewhere on the blockchain, the following output appears and should only be spendable by you:</p> <pre><code>X = 28*G + 3*H\n</code></pre> <p>X, the result of the addition, is visible by everyone. The value 3 is only known to you and Alice, and 28 is only known to you.</p> <p>To transfer those 3 coins again, the protocol requires 28 to be known somehow. To demonstrate how this works, let's say you want to transfer those 3 same coins to Carol. You need to build a simple transaction such that:</p> <pre><code>Xi =&gt; Y\n</code></pre> <p>Where Xi is an input that spends your X output and Y is Carol's output. There is no way to build such a transaction and balance it without knowing your private key of 28. Indeed, if Carol is to balance this transaction, she needs to know both the value sent and your private key so that:</p> <pre><code>Y - Xi = (28*G + 3*H) - (28*G + 3*H) = 0*G + 0*H\n</code></pre> <p>By checking that everything has been zeroed out, we can again make sure that no new money has been created.</p> <p>Wait! Stop! Now you know the private key in Carol's output (which, in this case, must be the same as yours to balance out) and so you could steal the money back from Carol!</p> <p>To solve this, Carol uses a private key of her choosing. She picks 113 say, and what ends up on the blockchain is:</p> <pre><code>Y - Xi = (113*G + 3*H) - (28*G + 3*H) = 85*G + 0*H\n</code></pre> <p>Now the transaction no longer sums to zero and we have an excess value (85), which is the result of the summation of all blinding factors. Because <code>85*G</code> is a valid public key for the generator point G the input and output values must sum to zero and the transaction is thus valid, since <code>x*G + y*H</code> is a valid public key for generator point G if and only if <code>y = 0</code>.</p> <p>So all the protocol needs to verify is that (<code>Y - Xi</code>) is a valid public key for generator point G  and that the transacting parties collectively can produce its private key (85 in the above example). The simplest way to do so is to require a signature built with the excess value (85), which then ensures that:</p> <ul> <li>The transacting parties collectively can produce the private key (the excess value)</li> <li>The sum of the outputs minus the inputs are zero (because only a valid public key will check against the signature).</li> </ul> <p>This signature, attached to every transaction, together with some additional data (like mining fees), is called a transaction kernel and is checked by all validators.</p>"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#some-finer-points","title":"Some Finer Points","text":"<p>This section elaborates on the building of transactions by discussing how change is introduced and the requirement for range proofs so all values are proven to be non-negative. Neither of these are absolutely required to understand Mimblewimble and Grin, so if you're in a hurry, feel free to jump straight to Putting It All Together.</p>"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#change","title":"Change","text":"<p>Let's say you only want to send 2 coins to Carol from the 3 you received from Alice. To do this you would send the remaining 1 coin back to yourself as change. You generate another private key (say 12) as a blinding factor to protect your change output. Carol uses her own private key as before.</p> <pre><code>Change output:     12*G + 1*H\nCarol's output:    113*G + 2*H\n</code></pre> <p>What ends up on the blockchain is something very similar to before. And the signature is again built with the excess value, 97 in this example.</p> <pre><code>(12*G + 1*H) + (113*G + 2*H) - (28*G + 3*H) = 97*G + 0*H\n</code></pre>"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#range-proofs","title":"Range Proofs","text":"<p>In all the above calculations, we rely on the transaction values to always be positive. The introduction of negative amounts would be extremely problematic as one could create new funds in every transaction.</p> <p>For example, one could create a transaction with an input of 2 and outputs of 5 and -3 and still obtain a well-balanced transaction. This can't be easily detected because even if x is negative, the corresponding point <code>x*H</code> on the curve looks like any other.</p> <p>To solve this problem, Mimblewimble leverages another cryptographic concept (also coming from Confidential Transactions) called range proofs: a proof that a number falls within a given range, without revealing the number. We won't elaborate on the range proof, but you just need to know that for any <code>r*G + v*H</code> we can build a proof that will show that v is greater than zero and does not overflow.</p> <p>It's also important to note that range proofs for both the blinding factor and the values are needed. The reason for this is that it prevents a censoring attack where a third party would be able to lock UTXOs without knowing their private keys by creating a transaction such as the following:</p> <pre><code>Carol's UTXO:      113*G + 2*H\nAttacker's output: (113 + 99)*G + 2*H\n</code></pre> <p>which can be signed by the attacker because Carol's blinding factor cancels out in the equation <code>Y - Xi</code>:</p> <pre><code>Y - Xi = ((113 + 99)*G + 2*H) - (113*G + 2*H) =  99*G\n</code></pre> <p>This output (<code>(113 + 99)*G + 2*H</code>) requires that both the numbers 113 and 99 are known in order to be spent; the attacker would thus have successfully locked Carol's UTXO. The requirement for a range proof for the blinding factor prevents this because the attacker doesn't know the number 113 and thus neither (113 + 99). A more detailed description of range proofs is further detailed in the range proof paper.</p>"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#putting-it-all-together","title":"Putting It All Together","text":"<p>A Mimblewimble transaction includes the following:</p> <ul> <li>A set of inputs, that reference and spend a set of previous outputs.</li> <li>A set of new outputs that include:</li> <li>A value and a blinding factor (which is just a new private key) multiplied on   a curve and summed to be <code>r*G + v*H</code>.</li> <li>A range proof that among other things shows that v is non-negative.</li> <li>An transaction fee in cleartext.</li> <li>A signature whose private key is computed by taking the excess value (the sum of all   output values plus the fee, minus the input values).</li> </ul>"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#blocks-and-chain-state","title":"Blocks and Chain State","text":"<p>We explained above how Mimblewimble transactions can provide strong anonymity guarantees while maintaining the properties required for a valid blockchain, i.e., a transaction does not create money and proof of ownership is established through private keys.</p> <p>The Mimblewimble block format builds on this by introducing one additional concept: cut-through. With this addition, a Mimblewimble chain gains:</p> <ul> <li>Extremely good scalability, as the great majority of transaction data can be   eliminated over time, without compromising security.</li> <li>Further anonymity by mixing and removing transaction data.</li> </ul>"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#transaction-aggregation","title":"Transaction Aggregation","text":"<p>Recall that a transaction consists of the following:</p> <ul> <li>a set of inputs that reference and spent a set of previous outputs</li> <li>a set of new outputs</li> <li>a transaction kernel consisting of:</li> <li>kernel excess (the public key of the excess value)</li> <li>transaction signature whose public key is the kernel excess</li> </ul> <p>A transaction is validated by determining that the kernel excess is a valid public key:</p> <pre><code>(42*G + 1*H) + (99*G + 2*H) - (113*G + 3*H) = 28*G + 0*H\n</code></pre> <p>The public key in this example is <code>28*G</code>.</p> <p>We can say the following is true for any valid transaction (ignoring fees for simplicity):</p> <pre><code>sum(outputs) - sum(inputs) = kernel_excess\n</code></pre> <p>The same holds true for blocks themselves once we realize a block is simply a set of aggregated inputs, outputs and transaction kernels. We can sum the outputs, subtract the inputs from it and equating the resulting Pedersen commitment to the sum of the kernel excesses:</p> <pre><code>sum(outputs) - sum(inputs) = sum(kernel_excess)\n</code></pre> <p>Simplifying slightly, (again ignoring transaction fees) we can say that Mimblewimble blocks can be treated exactly as Mimblewimble transactions.</p>"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#kernel-offsets","title":"Kernel Offsets","text":"<p>There is a subtle problem with Mimblewimble blocks and transactions as described above. It is possible (and in some cases trivial) to reconstruct the constituent transactions in a block. This is clearly bad for privacy. This is the \"subset\" problem: given a set of inputs, outputs, and transaction kernels a subset of these will recombine to reconstruct a valid transaction.</p> <p>Consider the following two transactions:</p> <pre><code>(in1, in2) -&gt; (out1), (kern1)\n(in3) -&gt; (out2), (kern2)\n</code></pre> <p>We can aggregate them into the following block (or aggregate transaction):</p> <pre><code>(in1, in2, in3) -&gt; (out1, out2), (kern1, kern2)\n</code></pre> <p>It is trivially easy to try all possible permutations to recover one of the transactions (where it successfully sums to zero):</p> <pre><code>(in1, in2) -&gt; (out1), (kern1)\n</code></pre> <p>We also know that everything remaining can be used to reconstruct the other valid transaction:</p> <pre><code>(in3) -&gt; (out2), (kern2)\n</code></pre> <p>Remember that the kernel excess <code>r*G</code> simply is the public key of the excess value r. To mitigate this we redefine the kernel excess from <code>r*G</code> to <code>(r-kernel_offset)*G</code> and distribute the kernel offset to be included with every transaction kernel. The kernel offset is thus a blinding factor that needs to be added to the excess value to ensure the commitments sum to zero:</p> <pre><code>sum(outputs) - sum(inputs) = r*G = (r-kernel_offset)*G + kernel_offset*G\n</code></pre> <p>or alternatively</p> <pre><code>sum(outputs) - sum(inputs) = kernel_excess + kernel_offset*G\n</code></pre> <p>For a commitment <code>r*G + 0*H</code> with the offset <code>a</code>, the transaction is signed with <code>(r-a)</code> and a is published so that <code>r*G</code> can be calculated in order to verify the validity of the transaction. During block construction all kernel offsets are summed to generate a single aggregate kernel offset to cover the whole block. The kernel offset for any individual transaction is then unrecoverable and the subset problem is solved.</p> <pre><code>sum(outputs) - sum(inputs) = sum(kernel_excess) + kernel_offset*G\n</code></pre>"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#cut-through","title":"Cut-through","text":"<p>Blocks let miners assemble multiple transactions into a single set that's added to the chain. In the following block representations, containing 3 transactions, we only show inputs and outputs of transactions. Inputs reference outputs they spend. An output included in a previous block is marked with a lower-case x.</p> <pre><code>I1(x1) --- O1\n        |- O2\n\nI2(x2) --- O3\nI3(O2) -|\n\nI4(O3) --- O4\n        |- O5\n</code></pre> <p>We notice the two following properties:</p> <ul> <li>Within this block, some outputs are directly spent by following inputs (I3   spends O2 and I4 spends O3).</li> <li>The structure of each transaction does not actually matter. Since all transactions   individually sum to zero, the sum of all transaction inputs and outputs must be zero.</li> </ul> <p>Similarly to a transaction, all that needs to be checked in a block is that ownership has been proven (which comes from the transaction kernels) and that the whole block did not create any coins (other than what's allowed as the mining reward). Therefore, matching inputs and outputs can be eliminated, as their contribution to the overall sum cancels out. Which leads to the following, much more compact block:</p> <pre><code>I1(x1) | O1\nI2(x2) | O4\n       | O5\n</code></pre> <p>Note that all transaction structure has been eliminated and the order of inputs and outputs does not matter anymore. However, the sum of all inputs and outputs is still guaranteed to be zero.</p> <p>A block is simply built from:</p> <ul> <li>A block header.</li> <li>The list of inputs remaining after cut-through.</li> <li>The list of outputs remaining after cut-through.</li> <li>A single kernel offset to cover the full block.</li> <li>The transaction kernels containing, for each transaction:</li> <li>The public key <code>r*G</code> obtained from the summation of all inputs and outputs.</li> <li>The signatures generated using the excess value.</li> <li>The mining fee.</li> </ul> <p>When structured this way, a Mimblewimble block offers extremely good privacy guarantees:</p> <ul> <li>Intermediate (cut-through) transactions will be represented only by their transaction kernels.</li> <li>All outputs look the same: very large numbers that are impossible to   meaningfully differentiate from one another. If someone wants to exclude a specific output, they'd have   to exclude all.</li> <li>All transaction structure has been removed, making it impossible to tell which inputs and outputs match.</li> </ul> <p>And yet, it all still validates!</p>"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#cut-through-all-the-way","title":"Cut-through All The Way","text":"<p>Going back to the previous example block, outputs x1 and x2, spent by I1 and I2, must have appeared previously in the blockchain. So after the addition of this block, those outputs as well as I1 and I2 can also be removed from the blockchain as they now are intermediate transactions.</p> <p>We conclude that the chain state (excluding headers) at any point in time can be summarized by just these pieces of information:</p> <ol> <li>The total amount of coins created by mining in the chain.</li> <li>The complete set of unspent outputs.</li> <li>The transactions kernels for each transaction.</li> </ol> <p>The first piece of information can be deduced just using the block height. </p> <p>Both the UTXOs and the transaction kernels are extremely compact. This has two important consequences:</p> <ul> <li>The blockchain a node needs to maintain is very small (on the  order of a few gigabytes for a bitcoin-sized blockchain, and   potentially optimizable to a few hundreds of megabytes).</li> <li>When a new node joins the network the amount of   information that needs to be transferred is very small.</li> </ul> <p>In addition, the UTXO set cannot be tampered with. Adding or removing even one input or output would change the sum of the transactions to be something other than zero.</p>"},{"location":"wiki/introduction/%28og%29introduction-to-mimblewimble/#conclusion","title":"Conclusion","text":"<p>In this document we covered the basic principles that underlie a Mimblewimble blockchain. By using the addition properties of Elliptic Curve Cryptography, we're able to build transactions that are completely opaque but can still be properly validated. And by generalizing those properties to blocks, we can eliminate a large amount of blockchain data, allowing for great scaling and fast sync of new peers.</p>"},{"location":"wiki/introduction/grin-for-bitcoiners/","title":"Grin for Bitcoiners","text":"<p>Read this in other languages: Korean, \u7b80\u4f53\u4e2d\u6587.</p>"},{"location":"wiki/introduction/grin-for-bitcoiners/#privacy-and-fungibility","title":"Privacy and Fungibility","text":"<p>There are 3 main properties of Grin transactions that make them private:</p> <ol> <li>There are no addresses.</li> <li>There are no amounts.</li> <li>2 transactions, one spending the other, can be merged in a block to form only one, removing all intermediary information.</li> </ol> <p>The 2 first properties mean that all transactions are indistinguishable from one another. Unless you directly participated in the transaction, all inputs and outputs look like random pieces of data (in lingo, they're all random curve points).</p> <p>Moreover, there are no more transactions in a block. A Grin block looks just like one giant transaction and all original association between inputs and outputs is lost.</p>"},{"location":"wiki/introduction/grin-for-bitcoiners/#scalability","title":"Scalability","text":"<p>As explained in the previous section, thanks to the Mimblewimble transaction and block format we can merge transactions when an output is directly spent by the input of another. It's as if when Alice gives money to Bob, and then Bob gives it all to Carol, Bob was never involved and his transaction is actually never even seen on the blockchain.</p> <p>Pushing that further, between blocks, most outputs end up being spent sooner or later as a transaction input. So all spent outputs can be safely removed. That leaves only the kernel of a transaction as having a lasting impact (at around 100 bytes) on the size of the blockchain.</p> <p>Asymptotically, a Mimblewimble blockchain grows at roughly one quarter the rate of a bitcoin blockchain, while offering much better privacy.</p>"},{"location":"wiki/introduction/grin-for-bitcoiners/#scripting","title":"Scripting","text":"<p>Maybe you've heard that Mimblewimble doesn't support scripts. And in some way, that's true. But thanks to cryptographic trickery, many contracts that in Bitcoin would require a script can be achieved with Grin using properties of Elliptic Curve Cryptography. So far, we know how to do:</p> <ul> <li>Multi-signature transactions.</li> <li>Atomic swaps.</li> <li>Time-locked transactions and outputs.</li> <li>Lightning Network</li> </ul>"},{"location":"wiki/introduction/grin-for-bitcoiners/#emission-rate","title":"Emission Rate","text":"<p>Bitcoin's 10 minute block time has its initial 50 btc reward cut in half every 4 years until there are 21 million bitcoin in circulation. Grin's emission rate is linear, meaning it never drops. The block reward is currently set at 60 grin with a block goal of 60 seconds. This still works because 1) dilution trends toward zero and 2) a non-negligible amount of coins gets lost or destroyed every year.</p>"},{"location":"wiki/introduction/grin-for-bitcoiners/#faq","title":"FAQ","text":""},{"location":"wiki/introduction/grin-for-bitcoiners/#wait-what-no-address","title":"Wait, what!? No address?","text":"<p>Nope, no address. All outputs in Grin are unique and have no common data with any previous output. Instead of relying on a known address to send money, transactions have to be built interactively, with two (or more) wallets exchanging data with one another. This interaction does not require both parties to be online at the same time. Practically speaking, there are many ways for two programs to interact privately and securely. This interaction could even take place over email or Signal (or carrier pigeons).</p>"},{"location":"wiki/introduction/grin-for-bitcoiners/#if-transaction-information-gets-removed-can-i-just-cheat-and-create-money","title":"If transaction information gets removed, can I just cheat and create money?","text":"<p>No, and this is where Mimblewimble and Grin shine. Confidential transactions are a form of homomorphic encryption. Without revealing any amount, Grin can verify that the sum of all transaction inputs equal the sum of transaction outputs, plus the fee. Going even further, comparing the sum of all money created by mining with the total sum of money that's being held, Grin nodes can check the correctness of the total money supply.</p>"},{"location":"wiki/introduction/grin-for-bitcoiners/#if-i-listen-to-transaction-relay-cant-i-just-figure-out-who-they-belong-to-before-being-cut-through","title":"If I listen to transaction relay, can't I just figure out who they belong to before being cut-through?","text":"<p>You can figure out which outputs are being spent by which transaction, but the trail of data stops here. All inputs and outputs look like random pieces of data, so you can't tell if the money was transferred, still belongs to the same person, which output is the actual transfer and which is the change, etc. Grin transactions are built with no identifiable piece of information.</p> <p>In addition, Grin leverages Dandelion relay, which provides additional anonymity as to which IP or client the transaction originated from, and allows for transactions to be aggregated.</p>"},{"location":"wiki/introduction/grin-for-bitcoiners/#what-about-the-quantum-computaggedon","title":"What about the quantum computaggedon?","text":"<p>In every Grin output, we also include a bit of hashed data, which is quantum safe. If quantum computing was to become a reality, we can safely introduce additional verification that would protect existing coins from being hacked.</p>"},{"location":"wiki/introduction/grin-for-bitcoiners/#how-does-all-this-magic-work","title":"How does all this magic work?","text":"<p>Click Next down below.</p>"},{"location":"wiki/introduction/mimblewimble/commitments/","title":"Commitments","text":"<p>In cryptography a Commitment (or commitment scheme) refers to a concept which can be imagined like a box with a lock. You can put something into the box (for example a piece of a paper with a secret number written on it), lock it and give it to another person (or the public).</p> <p>The other person doesn't know yet what's the secret number in the box, but if you decide to publish your secret number later in time and want to prove that this really is the secret which you came up with in the first place (and not a different one) you can prove this simply by giving the key of the box to the other person.</p> <p>They can unlock the box, compare the secret within the box with the secret you just published and can be sure that you didn't change your secret since you locked it. You \"committed\" to the secret number beforehand, meaning you cannot change it between the time of commitment and the time of revealing.</p> <p>They have two important properties:</p> <ul> <li>Hiding - Nobody but the committer can see or infer the actual value behind the commitment.</li> <li>Binding - The committer can't change the value after the commitment is published.</li> </ul> <p>ECC can be used to create a commitment. Let\u2019s say we want to commit to the value <code>8</code>.</p> <pre><code>commit (8)  -&gt;  8*G\n</code></pre> <p>To everybody else, our commitment <code>8*G</code> just looks like a random point, and we publish it. Some time later we reveal our value.</p> <pre><code>reveal 8\n</code></pre> <p>And now any observer could multiply our stated value 8, by the public point G and verify that their result is equal to the commitment we published earlier.</p> <pre><code>verify (8, commitment) == 8*G  ? --&gt; True/False\n</code></pre> <p>However, there\u2019s a major issue. If our value is within a small range, which is typically the case, it\u2019s simple for anybody to find out what value we committed to, even if we don\u2019t reveal it; by trying out (brute-forcing) different values, they can find the one value that, when multiplied by <code>G</code>, matches the original commitment.</p> <p>Example</p> <p>Say we're betting on how many goals a team would score by the end of the year. Our guess is 23, and we commit to it by publishing the commitment <code>23*G</code>. Problem is, it would be trivial for anybody to uncover our guess simply by trying to commit to 1, 2, 3, 4 etc. and checking each result if it's equal to our commitment. In this case, our value will be revealed after only 23 simple steps.</p> <p>What\u2019s the solution?</p>"},{"location":"wiki/introduction/mimblewimble/commitments/#blinding-factor","title":"Blinding Factor","text":"<p>The issue is solved by adding a blinding factor r, which is a random 256-bit integer (range 0 to 2^256, same as a typical private key) used to blind the value so that it can\u2019t be guessed and uncovered.</p> <p>We could try adding the blinding factor by committing <code>(8+r)*G</code> and then revealing <code>8</code> and <code>r</code>. But, doing so breaks the binding property of the commitment, because instead of revealing value <code>8</code> and blinding factor <code>r</code>, we could reveal <code>7</code> and <code>r+1</code> or any other value.</p> <p>Therefore, we require a different method to include <code>r</code>.</p>"},{"location":"wiki/introduction/mimblewimble/commitments/#pedersen-commitments","title":"Pedersen Commitments","text":"<p>Introducing G\u2019s twin, H.</p> <p>H is another generator point, distinct from G (note how it\u2019s the next letter in the alphabet). Both are nothing-up-my-sleeve-points, meaning nobody knows <code>n</code> such that <code>n*G = H</code>. Using H we can blind the value while keeping the commitment binding.</p> <pre><code>r*G + v*H\n</code></pre> <p>This specific form of commitement is called a Pedersen Commitment.</p> <p>A Mimblewimble output is just a Pedersen Commitment, as we\u2019ll soon see. Its values are as follows:</p> <ul> <li> <p><code>r</code> is the blinding factor, and <code>r*G</code> is the public key point for <code>r</code>   (using G as generator point).</p> </li> <li> <p><code>v</code> is the value committed, and <code>v*H</code> is the public key point for <code>v</code> (using H as generator point).</p> </li> </ul>"},{"location":"wiki/introduction/mimblewimble/commitments/#homomorphic-commitments","title":"Homomorphic Commitments","text":"<p>Commitments with homomorphic properties means you can perform calculations on encrypted values without decrypting them first. The result of the computation is a commitment which is identical to the result if the operations had been performed on the unencrypted values.</p> They allow us to do as follows: <p>commit (x)  \u21d2  C<sub>1</sub>  commit (y)  \u21d2 C<sub>2</sub>  commit (x+y) \u21d2 Z = C<sub>1</sub> + C<sub>2</sub></p> <p>If we add two commitments to each other, the result would be an entirely new, valid commitment, which actually commits to the value <code>x + y</code>. So we\u2019re able to perform a math operation (addition) unto encrypted data (commitments) while keeping the underlying values \u201cintact\u201d.</p> <p>Elliptic curve commitments indeed have these homomorphic properties. We can do the following:</p> <pre><code>x*G + y*G =&gt; (x + y)*G\n</code></pre> <p>Notice how we add two different curve points and the result is a different point, which is a commitment to the sum of the values we\u2019re hiding.</p> <p>Similarly, we can add up two Pedersen Commitments. First let's create two of them:</p> <ul> <li>C<sub>1</sub> = r<sub>1</sub>G + v<sub>1</sub>H</li> <li>C<sub>2</sub> = r<sub>2</sub>G + v<sub>2</sub>H</li> </ul> <p>The point Z (remember a commitment is simply a point on the curve) is the result of addition between points C<sub>1</sub> and C<sub>2</sub>.</p> <pre><code>Z = C1 + C2\n</code></pre> <pre><code>Z = r1*G + r2*G + v1*H + v2*H\n</code></pre> <p>So we can calculate what Z is:</p> <pre><code>Z = (r1 + r2)*G + (v1 + v2)*H\n</code></pre> <p>Hence point Z is a Pedersen commitment that is the sum of commitments C<sub>1</sub> and C<sub>2</sub>.</p> <p>This is the foundation for the Elliptic-curve algebra used in Mimblewimble to prove both ownership of outputs (coins) and non-inflation.</p> <ol> <li> <p>Finessing commitments \u21a9</p> </li> </ol>"},{"location":"wiki/introduction/mimblewimble/ecc/","title":"Elliptic Curves","text":"<p>Preface</p> <p>The following three-part series is intended for those who wish to understand what goes on inside Mimblewimble and Grin. We try to make this objective more accessible by going through the cryptographic primitives required to know first, without diving into proofs and specifics. Once those are in order, we connect everything and explain how Mimblewimble works.</p> <ol> <li>Elliptic Curves</li> <li>Commitments</li> <li>Mimblewimble</li> </ol> <p>For the original introduction (along with many translations), refer to here.</p>"},{"location":"wiki/introduction/mimblewimble/ecc/#elliptic-curve-cryptography","title":"Elliptic Curve Cryptography","text":"<p>Mimblewimble relies entirely on Elliptic-curve cryptography (ECC), an approach to public-key cryptography. Put simply, given an algebraic curve of the form <code>y^2 = x^3 + ax + b</code>, pairs of private and public keys can be derived. Picking a private key and computing its corresponding public key is trivial, but the reverse operation <code>public key -&gt; private key</code> is called the discrete logarithm problem, and is considered to be computationally infeasible.</p> <p>Let's review the basics.</p>"},{"location":"wiki/introduction/mimblewimble/ecc/#operations","title":"Operations","text":"<p>These are the relevant mathematical operations we can do on Elliptic-curve points.</p> <ul> <li>Addition - Given two points, we can add them to one another (or subtract) and the result would be a new point on the curve.</li> <li>Multiplication - Given a point, we can multiply it any number of times.</li> </ul>"},{"location":"wiki/introduction/mimblewimble/ecc/#addition","title":"Addition","text":"<p>Given three aligned points P, Q and R, their sum is always 0. We treat this as an inherent property of elliptic curves.</p> <p><pre><code>P + Q + R = 0\n</code></pre> We can then write it as:</p> <pre><code>P + Q = -R\n</code></pre> <p>So that adding the two points P and Q results in -R, the inverse of R.</p> <p>If we draw a line passing through P and Q, this line will cross a third point on the curve, R (so that P, Q and R are aligned). If we take the inverse of this point, which is simply the one symmetric to it about the x-axis, we have found the result of adding two curve points, P + Q. Let\u2019s illustrate:</p>  ![ecc1](../../../assets/images/ecc1.png){ width=200 }  <p>In other words, addition of points is basically hopping around on the curve to a different, seemingly random point; It looks random unless you know the exact operation performed to reach it.</p>"},{"location":"wiki/introduction/mimblewimble/ecc/#multiplication","title":"Multiplication","text":"<p>We can\u2019t multiply a point by another point, but we can multiply a point by a number (scalar). Multiplying point P by scalar <code>k</code> would simply require adding point P onto it self <code>k</code> times. This operation is easily demonstrated by assigning <code>k=2</code> so that <code>k*P = P+P</code>. To illustrate how it would look like on the curve, we draw a tangent line. You can imagine that the line intersects three points, whereas two of them are P, such that:</p> <pre><code>P + P = -R\n</code></pre>  ![ecc2](../../../assets/images/ecc2.png){ width=200 }  <p>To calculate <code>8*P</code> for e.g. wouldn\u2019t take 8 operations, but only 3; you can find <code>2*P</code>, then add it onto itself, and then add <code>4*P</code> onto itself, for the final result of <code>8*P</code>.</p>"},{"location":"wiki/introduction/mimblewimble/ecc/#key-pairs","title":"Key Pairs","text":"<p>An ECC system defines a publicly known constant curve point called the generator point, G. The generator point is used to compute any public key. A key pair consists of:</p> <ul> <li>Private key k \u2013 A randomly chosen 256-bit integer (scalar).</li> <li>Public key P \u2013 An Elliptic-curve point derived by multiplying generator point G by the private key.</li> </ul> <p>And more clearly, a public key (of private key <code>k</code>) is as follows:</p> <pre><code>P = k*G\n</code></pre> <p>This is easy to compute.</p> <p>But, if everybody knows points P and G, can they find out what <code>k</code> is? The answer is no; The difficulty of getting from one point to another is precisely the definition of the Elliptic curve discrete logarithm problem.</p> <p>Secp256k1</p> <p>The specific Elliptic curve that Grin employs is rust-secp256k1 (y<sup>2</sup> = x<sup>3</sup> + 7) using Schnorr signature scheme.</p> <ol> <li> <p>Elliptic Curve Cryptography: a gentle introduction \u21a9</p> </li> <li> <p>A (Relatively Easy To Understand) Primer on Elliptic Curve Cryptography \u21a9</p> </li> <li> <p>Cryptography: From Mathematical Magic to Secure Communication \u21a9</p> </li> </ol>"},{"location":"wiki/introduction/mimblewimble/mimblewimble/","title":"Mimblewimble","text":"<p>For the original introduction (along with many translations), refer to here.</p> <p>Earlier we demonstrated how a public key obtained from the addition of two private keys <code>r</code> and <code>v</code>, resulting in public key <code>(v+r)*G</code>, is identical to the addition of the public keys of each individual private key, <code>r*G + v*G</code>. Mimblewimble and Grin heavily rely on this principle.</p>"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#transactions","title":"Transactions","text":"<p>Every transaction has to prove two basic things:</p> <ul> <li> <p>Zero sum - The sum of outputs minus inputs should always equal zero, proving that a transaction did not create new coins, without revealing the actual amounts.</p> </li> <li> <p>Possession of private keys - ownership of outputs is guaranteed by the possession of ECC private keys. However, the proof that an entity owns those private keys is not achieved by directly signing the transaction, as with most other cryptocurrencies.</p> </li> </ul> <p>Going next, we'll examine how those two fundamental properties are achieved.</p>"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#amounts","title":"Amounts","text":"<p>Building upon the ECC principle described above, we can obscure the values in a transaction.</p> If <code>v</code> is the amount value of an input or output and H is a generator point on the elliptic curve, we can simply embed <code>v*H</code> instead of <code>v</code> in a transaction. This works because using the ECC operations, we can validate that the sum of values in outputs, equals to the sum of values in inputs. If we subtract those sums (outputs minus inputs), the result would be 0. <p>transaction</p> Hidden Inputs Outputs v<sub>1</sub>H v<sub>2</sub>H v<sub>3</sub>H Transparent Inputs Outputs v<sub>1</sub> v<sub>2</sub> v<sub>3</sub> <pre><code>v3*H + v2*H - v1*H = (v3 + v2 - v1)*H = 0*H = 0\n</code></pre> <p>Recall that an input is just a reference to a past output being spent, so each input is practically an output.</p> <p>Verifying this property on every transaction allows the protocol to confirm that a transaction doesn't create money out of thin air, without knowing what the actual values are.</p> <p>However, we encounter a familiar issue; There are a finite number of usable values (amounts) and one could try every single one of them to guess the value of the transaction.</p>"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#blinding-factor","title":"Blinding Factor","text":"<p>We introduce a blinding factor <code>r</code>, also used as a private key (explained later). Along with it we use a second generator point, G, on the same elliptic curve.</p> <p>Then, an output is expressed as:</p> <pre><code>r*G + v*H\n</code></pre> <ul> <li><code>r</code> is both a blinding factor and a private key, and its public key is r*G (using G as a generator point).</li> <li><code>v</code> is the value of an output, and its public key is v*H (using H as a generator point).</li> </ul> <p>The form of a Mimblewimble output is a Pedersen Commitment. Neither <code>v</code> nor <code>r</code> can be deduced, but the committer can prove knowledge of them.</p> We include <code>r</code> to obtain the following transaction. <p>transaction</p> Inputs Outputs r<sub>1</sub>G + v<sub>1</sub>H r<sub>2</sub>G + v<sub>2</sub>H r<sub>3</sub>G + v<sub>3</sub>H <pre><code>(r2*G + v2*H) + (r3*G + v3*H) - (r1*G + v1*H) = (r2 + r3 - r1)*G + 0*H\n</code></pre>"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#ownership","title":"Ownership","text":"<p>In the previous section we introduced a blinding factor to obscure the transaction's values. Another insight of Mimblewimble is that this blinding factor can be leveraged to prove ownership of the value, serving also as a private key to an output.</p> <p>Let's illustrate this using an example:</p> <p>Alice sends 3 coins to Bob, and to obscure the amount, Bob chooses 28 as his blinding factor (in practice it's an extremely large number). The following output appears on the blockchain and is only spendable by Bob.</p> <p><pre><code>X = 28*G + 3*H\n</code></pre> X is a commitment visible by everyone. The value <code>3</code> is only known to Bob and Alice, while <code>28</code> is only known to Bob.</p> <p>To transfer those 3 coins again, the protocol requires <code>28</code> to be known. Let's say Bob wants to send the 3 coins to Carol. He needs to build a simple transaction where <code>Xi</code> is his input, and <code>Y</code> is Carol's new output. For the transaction to be valid, proving no new coins were created, subtracting the input from the output should result in 0.</p> <pre><code>Y - Xi = 0*G + 0*H = 0\n</code></pre> If we want this transaction to sum to 0, it would look like this: Inputs Outputs 28*G + 3*H 28*G + 3*H <p>Remember that a blinding factor also acts as a private key.</p> <p>But wait. We just introduced a major problem. Bob knows Carol's new blinding factor, so he can spend her output and steal it.</p> To solve this, Carol chooses her own blinding factor, <code>114</code>. The transaction on the blockchain would then look like this: <p>transaction</p> Inputs Outputs 28*G + 3*H 114*G + 3*H <pre><code>Y - Xi = (114*G + 3*H) - (28*G + 3*H) = 86*G + 0*H\n</code></pre> <p>Now the transaction no longer sums to zero and we have an excess value <code>86</code>. The excess value of a transaction is the sum of all outputs blinding factors, minus the sum of all inputs blinding factors, r<sub>o</sub> - r<sub>i</sub>. In this case, simply <code>114-28 = 86</code>.</p> <p>Then how does the protocol verify that values equal to 0? The transaction is only legitimate if <code>Y - Xi</code> is a valid public key for generator point G; which is the case only if <code>Y - Xi = r*G + 0*H</code>. In other words, if the values don't sum to 0, the result is recognized as an invalid public key for G.</p> <p>This can be verified by requiring the transactors to build a (schnorr) signature together, signing excess value <code>86</code>. This ensures that:</p> <ul> <li>The transacting parties can collectively produce the excess value (it is the private key of their joint signature).</li> <li>The sum of the outputs minus the inputs is 0, because only a valid public key for G will check out against the signature.</li> </ul> <p>This signature, along with a commitment to the excess value (86*G, which serves as a public key to verify the signature), is called a transaction kernel.</p>"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#change","title":"Change","text":"Let's say Bob wants to send only 2 of his coins to Carol. To do this he would send the remaining 1 coin back to back to himself, by creating an output he controls. Bob generates a private key <code>13</code> as a blinding factor for his change output. Carol uses the same private key as before. <p>transaction with change</p> Inputs Outputs 28*G + 3*H 114*G + 2*H 13*G + 1*H <pre><code>(114*G + 2*H) + (13*G + 1*H) - (28*G + 3*H) = 99*G + 0*H\n</code></pre> <p>The joint signature is again built with the excess value, <code>99</code> in this example.</p>"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#rangeproofs","title":"Rangeproofs","text":"<p>Previously, we assumed output values to always be positive. However, by introducing negative amounts, a transaction could be balanced out, for example, with an input of <code>2</code> and outputs of <code>5</code> and <code>-3</code>. This can't be detected as the values would still equal to zero.</p> <p>A rangeproof is therefore attached to every output and proves that its value isn't negative and that its size is restricted so it doesn't overflow. We won't elaborate on this here.</p>"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#putting-it-all-together","title":"Putting it all together","text":"A Mimblewimble transaction includes the following: <p>full transaction</p> Inputs Outputs 28*G + 3*H  Rangeproof 114*G + 2*H  Rangeproof 13*G + 1*H  Rangeproof Kernel: TX fee  Kernel excess  Signature <ul> <li>Set of inputs, that reference and spend a set of previous outputs.</li> <li>Set of new outputs where each includes:<ol> <li>Value and a blinding factor (a new private key), both multiplied on a curve and summed up to <code>r*G + v*H</code>.</li> <li>Rangeproof that, among other things, shows that <code>v</code> is non-negative.</li> </ol> </li> <li>Kernel consisting of:<ol> <li>Transaction fee in plain text.</li> <li>Kernel excess, which is the public key corresponding to the excess value (computed by <code>sum of outputs + fee - sum of inputs</code>)</li> <li>Transaction signature signed by the excess value as private key (and verifies with the kernel excess).</li> </ol> </li> </ul>"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#blocks-and-chain","title":"Blocks and chain","text":"<p>We explained above how Mimblewimble transactions can provide strong anonymity guarantees while maintaining the properties required for a valid blockchain, i.e., a transaction does not create new money and proof of ownership is established through private keys.</p> <p>The Mimblewimble block format builds on this by introducing two additional concepts: Aggregation and cut-through. With these additions, a Mimblewimble chain gains:</p> <ul> <li>Further anonymity by mixing and removing transaction data.</li> <li>Extremely good scalability, as the great majority of transaction data can be eliminated over time, without compromising security.</li> </ul>"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#transaction-aggregation","title":"Transaction aggregation","text":"<p>While the kernel excess of a transaction can be computed by anyone, there's major benefit in including it in every transaction's kernel, as it allows for aggregation within blocks.</p> <p>The following is true for any valid transaction (ignoring fees):</p> <pre><code>transaction:\nsum(outputs) - sum(inputs) = kernel_excess\n</code></pre> <p>Note that we refer here to the complete Pedersen commitments, not just their blinding factors (which would result in <code>excess_value</code> instead of <code>kernel_excess</code>).</p> <p>The same holds true for entire blocks of transactions, if we realize a block is simply an extended set of inputs, outputs and transaction kernels. We can sum the outputs, subtract the inputs, and the result would be a commitment equal to the sum of the kernel excesses.</p> <pre><code>block:\nsum(outputs) - sum(inputs) = sum(kernel_excess)\n</code></pre> <p>Simplifying slightly (ignoring transaction fees), we can see how a Mimblewimble block can be treated exactly as single transaction.</p> <p>Similarly, transactions could be aggregated before block construction and thus enter the mempool at an already aggregated state. The Dandelion stem phase does so automatically when possible, and it could also be done manually and potentially through different aggregation services.</p>"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#kernel-offsets","title":"Kernel offsets","text":"<p>There is a subtle problem with Mimblewimble blocks and transactions as described above, that needs to be addressed. Given a set of inputs, outputs and transaction kernels, a subset of these will combine to reconstruct a valid transaction.</p> <p>Consider the two following transactions:</p> <pre><code>(in1, in2) -&gt; (out1)        |  (kern1)\n     (in3) -&gt; (out2, out3)  |  (kern2)\n</code></pre> We can aggregate them into a block (simply another transaction): <p>aggregated block/transaction</p> Inputs Outputs Kernels in1 out1 kern1 in2 out2 kern2 in3 out3 <p>Initially it seems that the two original transactions are indistinguishable from one another within the new transaction. However, it is trivial to try all possible combinations of inputs/outputs, and find the way in which they succesfully sum to one of the kernel excesses, such that in our example:</p> <pre><code>(in1, in2) - (out1) = (excess_kern1)\n(in3) - (out2 + out3) = (excess_kern2)\n</code></pre> <p>We're able to easily uncover the original form of both transactions.  Then how do we solve this?</p> <p>Remember that the kernel excess <code>r*G</code> is simply the public key of the excess value <code>r</code>.</p> <p>To address this issue we introduce a kernel offset and redefine a transaction's kernel excess from <code>r*G</code> to <code>(r-kernel_offset)*G</code>. The kernel offset is thus a blinding factor that needs to be added to the excess value to ensure the sum of the commitments is valid:</p> <pre><code>sum(outputs) - sum(inputs) + (kernel_offset)*G = (r + kernel_offset)*G\n</code></pre> <p>If the sum of a transaction's inputs and outputs is the commitment <code>r*G + 0*H</code>, the transactors generate offset <code>a</code> and the transaction is signed with <code>(r-a)</code> instead of <code>r</code>. But, <code>r*G</code> could still be computed to verify the validity of the transaction because given the new form of kernel excess <code>(r-a)*G</code> and the offset <code>a</code>.</p> <p>The verifier computes a*G and calculates:</p> <pre><code>`kernel_excess + kernel_offset*G = sum(blinding_factors)\n</code></pre> <p>Translated to:</p> <pre><code>(r-a)*G + a*G = r*G\n</code></pre> <p>Given <code>r*G</code> the transaction can then be validated.</p> <p>During aggregation, all kernel offsets are summed to generate a single aggregate kernel offset to cover the whole block (or aggregated transaction). The kernel offset for any individual transaction is then unrecoverable and the subset problem is solved.</p>"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#cut-through","title":"Cut-through","text":"Blocks let miners assemble multiple transactions into a single set that's added to the chain. Inputs reference outputs they spend, which are shown as <code>in(output_spent)</code> in the following example. <p>non-cut-through block</p> Inputs Outputs in1(prev_out) out1 out2 in2(prev_out) out3 in3(out2) in4(out3) out4 out5 <p>We notice the two following properties:</p> <ul> <li>Within this block, some outputs are immediately spent by following inputs (e.g. in3 spends out2).</li> <li>The structure of each transaction does not actually matter. Since all transaction values individually sum to zero, then the collective sum of all inputs and outputs must be zero.</li> </ul> Similarly to a transaction, all that needs to be checked in a block is that ownership has been proven (which comes from the transaction kernels) and that the whole block did not create any coins, other than what's allowed as the mining reward. Therefore, matching inputs and outputs can be eliminated, as their contribution to the overall sum cancels out. Which leads to the following, much more compact block: <p>cut-through block</p> Inputs Outputs in1(prev_out) out1 in2(prev_out) out4 out5 <p>All transaction structure has been eliminated and the order of inputs and outputs does not matter anymore, while the sum of all inputs and outputs values is still guaranteed to be zero.</p> <p>A block is simply built from:</p> <ul> <li>Block header.</li> <li>Set of inputs remaining after cut-through.</li> <li>Set of outputs remaining after cut-through.</li> <li>A single kernel offset (sum of all kernel offsets) to cover the full block.</li> <li>The transaction kernels containing, for each transaction:<ol> <li>The public key <code>(r-a)*G</code>, which is the (modified) kernel excess.</li> <li>The signatures generated using the (modified) excess value <code>(r-a)</code> as the signing private key.</li> <li>Mining fee.</li> </ol> </li> </ul> <p>The block contents satisfy:</p> <pre><code>sum(outputs) - sum(inputs) = sum(kernel_excess) + sum(kernel_offset)*G\n                           = (r-a)*G + a*G\n</code></pre> <p>And it all still validates.</p>"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#cut-through-everything","title":"Cut-through everything","text":"<p>Going back to the previous example block, outputs <code>prev_out1, prev_out2</code>, which were spent by <code>in01, in02</code> respectively, must have appeared previously in the blockchain. After the addition of this new block, those past outputs as well as <code>in01, in02</code> can also be removed from the blockchain as they now are intermediate transactions. The blocks they were originally included in would still remain valid after their removal.</p> <p>All that needs to remain is the set of currently unspent outputs <code>out01, out02, out05</code>. We conclude that the chain state (excluding headers) at any point in time can be summarized by just these pieces of information:</p> <ol> <li>The total amount of coins created by mining in the chain.</li> <li>The complete set of unspent outputs.</li> <li>The transactions kernels for each transaction.</li> </ol> <p>The extension of this idea is that all the way from the genesis block to the latest block, every input is deleted along with its referenced output.</p> <p>Both the set of unspent outputs (UTXO) and transaction kernels are extremely compact. This has important consequences; The blockchain a node needs to maintain is very small, as well as the amount of information transferred when a new node joins the network.</p>"},{"location":"wiki/introduction/mimblewimble/mimblewimble/#conclusion","title":"Conclusion","text":"<p>We covered the basic principles that underlie Mimblewimble. By using addition of elliptic curve points, we're able to build transactions that are completely opaque but can still be properly validated. And by generalizing those properties to blocks, we can eliminate a large amount of blockchain data, allowing for great scaling and fast sync of new peers.</p> <p>Further reading on how transactions are constructed:</p> <ul> <li>Grin Transactions Explained, Step-by-Step</li> <li>What\u2019s inside a Grin Transaction File?</li> </ul>"},{"location":"wiki/miscellaneous/coinbase-maturity-rule/","title":"Coinbase Maturity Rule (aka Output Lock Heights)","text":"<p>Read this in other languages: Korean, \u7b80\u4f53\u4e2d\u6587.</p>"},{"location":"wiki/miscellaneous/coinbase-maturity-rule/#overview","title":"Overview","text":"<p>Coinbase outputs (block rewards &amp; fees) are \"locked\" and require 1,440 confirmations (i.e 24 hours worth of blocks added to the chain) before they mature sufficiently to be spendable. This is to reduce the risk of later txs being reversed if a chain reorganization occurs.</p> <p>Bitcoin does something very similar, requiring 100 confirmations (Bitcoin blocks are every 10 minutes, Grin blocks are every 60 seconds) before mining rewards can be spent.</p> <p>Grin enforces coinbase maturity in both the transaction pool and the block validation pipeline. A transaction containing an input spending a coinbase output cannot be added to the transaction pool until it has sufficiently matured. Similarly a block is invalid if it contains an input spending a coinbase output before it has sufficiently matured.</p> <p>The maturity rule only applies to coinbase outputs, regular transaction outputs have an effective lock height of zero.</p>"},{"location":"wiki/miscellaneous/coinbase-maturity-rule/#mimblewimble-output-lock-height","title":"Mimblewimble Output Lock Height","text":"<p>An output consists of:</p> <ul> <li>Features (currently coinbase vs. non-coinbase)</li> <li>Commitment <code>rG+vH</code></li> <li>Rangeproof</li> </ul> <p>To spend a regular transaction output two conditions must be met. We need to show the output has not been previously spent and we need to prove ownership of the output.</p> <p>A Grin transaction consists of the following:</p> <ul> <li>A set of inputs, each referencing a previous output being spent.</li> <li>A set of new outputs that include -<ul> <li>A value <code>v</code> and a blinding factor (private key) <code>r</code> multiplied on a curve and summed to be <code>rG+vH</code></li> <li>A range proof that shows that v is non-negative.</li> </ul> </li> <li>An explicit transaction fee in the clear.</li> <li>A signature, computed by taking the excess blinding value (the sum of all outputs plus the fee, minus the inputs) and using it as the private key.</li> </ul> <p>We can show the output is unspent by looking for the commitment in the current Output set. The Output set is authoritative; if the output exists in the Output set we know it has not yet been spent. If an output does not exist in the Output set we know it has either never existed, or that it previously existed and has been spent (we will not necessarily know which).</p> <p>To prove ownership we can verify the transaction signature. We can only have signed the transaction if the transaction sums to zero and we know both <code>v</code> and <code>r</code>.</p> <p>Knowing <code>v</code> and <code>r</code> we can uniquely identify the output (via its commitment) and we can prove ownership of the output by validating the signature on the original coinbase transaction.</p> <p>Grin does not permit duplicate commitments to exist in the Output set at the same time. But once an output is spent it is removed from the Output set and a duplicate commitment can be added back into the Output set. This is not necessarily recommended but Grin must handle this situation in a way that does not break consensus across the network.</p> <p>Several things complicate this situation -</p> <ol> <li>It is possible for two blocks to have identical rewards, particularly for the case of empty blocks, but also possible for non-empty blocks with transaction fees.</li> <li>It is possible for a non-coinbase output to have the same value as a coinbase output.</li> <li>It is possible (but not recommended) for a miner to reuse private keys.</li> </ol> <p>Grin does not allow duplicate commitments to exist in the Output set simultaneously. But the Output set is specific to the state of a particular chain fork. It is possible for duplicate identical commitments to exist simultaneously on different concurrent forks. And these duplicate commitments may have different \"lock heights\" at which they mature and become spendable on the different forks.</p> <ul> <li>Output O<sub>1</sub> from block B<sub>1</sub> spendable at height h<sub>1</sub> (on fork f<sub>1</sub>)</li> <li>Output O<sub>1</sub>' from block B<sub>2</sub> spendable at height h<sub>2</sub> (on fork f<sub>2</sub>)</li> </ul> <p>The complication here is that input I<sub>1</sub> will spend either O<sub>1</sub> or O<sub>1</sub>' depending on which fork the block containing I<sub>1</sub> exists on. And crucially I<sub>1</sub> may be valid at a particular block height on one fork but not the other.</p> <p>Said another way - a commitment may refer to multiple outputs, all of which may have different lock heights. And we must ensure we correctly identify which output is actually being spent and that the coinbase maturity rules are correctly enforced based on the current chain state.</p> <p>A coinbase output, locked with the coinbase maturity rule at a specific lock height, cannot be uniquely identified, and cannot be safely spent by their commitment alone. To spend a coinbase output we need to know one additional piece of information -</p> <ul> <li>The block the coinbase output originated from</li> </ul> <p>Given this, we can verify the height of the block and derive the \"lock height\" of the output (+ 1,000 blocks).</p>"},{"location":"wiki/miscellaneous/cuckoo-cycle/","title":"Cuckoo Cycle","text":"<p>Read this document in other languages: Korean.</p> <p>This document is meant to outline, at a level suitable for someone without prior knowledge, the algorithms and processes currently involved in Grin's Proof-of-Work system. We'll start with a general overview of cycles in a graph and the Cuckoo Cycle algorithm which forms the basis of Grin's proof-of-work. We'll then move on to Grin-specific details, which will outline the other systems that combine with Cuckoo Cycle to form the entirety of mining in Grin.</p>"},{"location":"wiki/miscellaneous/cuckoo-cycle/#graphs-and-cuckoo-cycle","title":"Graphs and Cuckoo Cycle","text":"<p>Grin's basic Proof-of-Work algorithm is called Cuckoo Cycle, which is specifically designed to differ from Bitcoin's Hashcash that's purely computational. It is primarily a memory bound algorithm, which (at least in theory) means that solving performance is bound by memory bandwidth rather than raw computational speed. As such, eventual ASICs should run much cooler than hashing chips, and optimization will remain more digital than analog in nature (as they are for Bitcoin).</p> <p>The Cuckoo Cycle POW is the work of John Tromp, and the most up-to-date documentation and implementations can be found in his github repository. The white paper is the best source of further technical details.</p>"},{"location":"wiki/miscellaneous/cuckoo-cycle/#cycles-in-a-graph","title":"Cycles in a Graph","text":"<p>Cuckoo Cycle is an algorithm meant to detect cycles in a bipartite graph of M edges on N+N nodes In plain terms, a bipartite graph is one in which edges (i.e. lines connecting nodes) travel only between 2 separate groups of nodes. We can number the nodes so that one group consist of even numbered nodes, while the other group consists of odd numbered nodes. Each edge will then connect an even node with an odd node. The simple graph below denotes just such a graph, with 4 nodes on the 'even' side (top), 4 nodes on the odd side (bottom) and zero Edges (i.e. no lines connecting any nodes.)</p> <p></p> <p>A graph of 8 Nodes with Zero Edges</p> <p>Let's throw a few Edges into the graph now, randomly:</p> <p></p> <p>8 Nodes with 4 Edges, no solution</p> <p>We now have a randomly-generated graph with N+N=4+4 nodes and M=4 edges. Our basic Proof-of-Work is now concerned with finding 'cycles' of a certain length within this graph, or, put simply, a path of connected nodes starting and ending at the same node. So, if we were looking for a cycle of length 4, one cannot be detected in this graph.</p> <p>Adjusting the number of Edges M relative to the number of Nodes N changes the probability that a cycle exists in the graph. For instance, if our POW problem were concerned with finding a cycle of length 4 in the graph, having M=4 means that all 4 edges would need to be randomly generated in a perfect cycle (from 0-5-4-1-0) in order for there to be a solution.</p> <p>Let's add a few more edges, again at random:</p> <p></p> <p>8 Nodes with 7 Edges</p> <p>Where we can find a cycle:</p> <p></p> <p>Cycle Found from 0-5-4-1-0</p> <p>If you increase the number of edges relative to the number of nodes, you increase the probability that a solution exists. With a few more edges added to the graph above, a cycle of length 4 has appeared from 0-5-4-1-0, and the graph has a solution.</p> <p>Thus, modifying the ratio M/N changes the number of expected occurrences of a cycle for a graph with randomly generated edges.</p> <p>For a small graph such as the one above, determining whether a cycle of a certain length exists is trivial. But as the graphs get larger, detecting such cycles becomes more difficult. For instance, does this graph have a cycle of length 8, i.e. 8 connected nodes starting and ending on the same node?</p> <p></p> <p>Meat-space Cycle Detection exercise</p> <p>The answer is left as an exercise to the reader, but the overall takeaways are:</p> <ul> <li>Detecting cycles in a graph becomes more difficult exercise as the size of a graph grows.</li> <li>The probability of a cycle of a given length in a graph increases as the average degree of M/N becomes larger.</li> </ul>"},{"location":"wiki/miscellaneous/cuckoo-cycle/#cuckoo-cycle_1","title":"Cuckoo Cycle","text":"<p>The basic Cuckoo Cycle algorithm is a specialized algorithm designed to solve exactly this problem for the case M=N. This document won't go into detail on the base algorithm, as it's outlined plainly enough in section 5 of the white paper. There are also several variants on the algorithm that make various speed/memory tradeoffs, again beyond the scope of this document. However, there are a few details following from the above that we need to keep in mind before going on to more technical aspects of Grin's proof-of-work.</p> <ul> <li>The 'random' edges in the graph demonstrated above are not actually random but are generated by   putting edge indices (0..N-1) through a keyed hash function, SIPHASH. Each edge index is put through the   SIPHASH function twice to create two edge endpoints, with the first input value being 2 * edge_index,   and the second 2 * edge_index+1. The key for this function is based on a hash of a block header,   outlined further below.</li> <li>The 'Proof' created by this algorithm is a set of edge indices that generate a cycle of length 42 (sorted by edge index)   which can be trivially validated by other peers.</li> <li>Two main parameters, as explained above, are passed into the Cuckoo Cycle algorithm that affect the probability of a solution, and the   time it takes to search the graph for a solution:</li> <li>The M/N ratio outlined above, which controls the average node degree.     Cuckoo Cycle fixes M=N, which limits the number of cycles to a small number.</li> <li>The size of the graph itself</li> </ul> <p>How these parameters interact in practice is looked at in more detail below.</p> <p>Now, (hopefully) armed with a basic understanding of what the Cuckoo Cycle algorithm is intended to do, as well as the parameters that affect how difficult it is to find a solution, we move on to the other portions of Grin's POW system.</p>"},{"location":"wiki/miscellaneous/cuckoo-cycle/#mining-in-grin","title":"Mining in Grin","text":"<p>The Cuckoo Cycle outlined above forms the basis of Grin's mining process, however Grin uses two variations of Cuckoo Cycle in tandem with several other systems to create a Proof-of-Work.</p> <ol> <li>for GPUs: Cuckaroo on 2^29 edges<ul> <li>Tweaked every 6 months to maintain ASIC resistance.</li> <li>90% of rewards at launch, linearly decreasing to 0% in 2 years.</li> <li>Variant of Cuckoo that enforces so-called ``mean'' mining.</li> <li>Takes 5.5GB of memory (perhaps 4GB with slowdown).</li> </ul> </li> <li>for ASICs: Cuckatoo on 2^31 or more edges<ul> <li>Variant of Cuckoo that simplifies ASIC design.</li> <li>10% of rewards at launch, linearly increasing to 100% in 2 years.</li> <li>Mean mineable in high memory GPUs.</li> <li>Takes 512 MB of SRAM memory for so-called ``lean'' mining.</li> <li>Smoothly transitions to 2^32 or more by July 2020, called Cuckatoo32+ (explained why here)</li> </ul> </li> </ol>"},{"location":"wiki/miscellaneous/cuckoo-cycle/#additional-difficulty-control","title":"Additional Difficulty Control","text":"<p>In order to provide additional difficulty control in a manner that meets the needs of a network with constantly evolving hashpower availability, a further Hashcash-based difficulty check is applied to potential solution sets as follows:</p> <p>If the Blake2b hash of a solution (a sorted array of 42 packed edge indices representing the edges in a 42-cycle) is less than an evolving difficulty target T, then the solution is considered valid. More precisely, the solution difficulty is calculated as the maximum target hash (2^256) divided by the solution hash, rounded to a 64-bit integer. If this integer is at least the evolving network difficulty, the POW is considered valid and the block is submitted to the chain for validation.</p> <p>In other words, a potential proof, as well as containing a valid Cuckoo Cycle, also needs to exceed the network difficulty. This difficulty is derived from:</p>"},{"location":"wiki/miscellaneous/cuckoo-cycle/#evolving-network-difficulty","title":"Evolving Network Difficulty","text":"<p>The difficulty target is intended to evolve according to the available network hashpower, with the goal of keeping the average block solution time within range of a target of exactly 60 seconds.</p> <p>The difficulty calculation is based on a simple moving average computation, somewhat similar to ZCash. The reference difficulty is an average of the difficulty over a window of 60 blocks (nominally one hour). The corresponding time span is calculated by using the difference between the timestamps at the beginning and the end of the window. If the time span is higher or lower than a certain range, (adjusted with a dampening factor to allow for normal variation,) then the difficulty is raised or lowered to a value aiming for the target block solve time.</p>"},{"location":"wiki/miscellaneous/cuckoo-cycle/#the-mining-loop","title":"The Mining Loop","text":"<p>All of these systems are put together in the mining loop, which attempts to create valid Proofs-of-Work to create the latest block in the chain. The following is an outline of what the main mining loop does during a single iteration:</p> <ol> <li>Get the latest chain state and build a block on top of it, which includes a Block Header with new values particular to this mining attempt:<ul> <li>The latest target difficulty as selected by the evolving network difficulty algorithm</li> <li>A set of transactions available for validation selected from the transaction pool</li> <li>A coinbase transaction (which we're hoping to give to ourselves)</li> <li>The current timestamp</li> <li>Roots of Merkle Mountain Ranges for headers, outputs, and kernels</li> <li>A randomly generated nonce to add further randomness to the header's hash</li> </ul> </li> <li> <p>Then, a sub-loop runs for a set amount of time, where the following happens:</p> <ol> <li>The new block header is hashed to create a hash value</li> <li> <p>The cuckoo graph generator is initialized, which accepts as parameters:</p> <ul> <li>The hash of the potential block header, which is to be used as</li> <li>the key to a SIPHASH function that will generate pairs of locations for each element in a set of nonces 0..N in the graph.</li> <li>The size of the graph (chosen by the miner).</li> </ul> </li> </ol> </li> <li> <p>The Cuckoo Cycle detection algorithm tries to find a solution (i.e. a cycle of length 42) within the generated graph.</p> </li> <li>If a cycle is found, a Blake2b hash of the proof is created, a solution difficulty computed, and compared to the current target difficulty, as outlined in Additional Difficulty Control above.</li> <li>If the solution difficulty is greater than or equal to the target difficulty, the block is sent to the transaction pool, propagated amongst peers for validation, and work begins on the next block.</li> <li>If the solution difficulty is less than the target difficulty, the proof is thrown out and the timed loop continues.</li> <li>If no solution is found, increment the nonce in the header by 1, and update the header's timestamp so the next iteration hashes a different value for seeding the next loop's graph generation step.</li> <li>If the loop times out with no solution found, start over again from the top, collecting new transactions and creating a new block altogether.</li> </ol>"},{"location":"wiki/miscellaneous/cuckoo-cycle/#pooling-capability","title":"Pooling Capability","text":"<p>Contrary to some existing concerns about Cuckoo Cycle's poolability, the POW implementation in Grin as described above is perfectly suited to a mining pool. While it may be difficult to prove efforts to solve a single graph in isolation, the combination of factors within Grin's proof-of-work combine to enforce a notion called 'progress-freeness', which enables 'poolability' as well as a level of fairness among all miners.</p>"},{"location":"wiki/miscellaneous/cuckoo-cycle/#progress-freeness","title":"Progress Freeness","text":"<p>Progress-freeness is central to the 'poolability' of a proof-of-work, and is simply based on the idea that a single solution attempt takes a relatively small amount of time. For instance, if a blockchain has a one minute block time and a slow miner needs 10 seconds per solution attempt, then it will have wasted on average 5 seconds per minute when its current attempt is aborted due to arrival of a new block. Faster miners will have less waste, giving an extra advantage on top of their higher attempt throughput. So in order to keep mining relatively progress-free, a POW that requires many solution attempts with each attempt taking a relatively small amount of time is desirable.</p> <p>Following from this, Grin's progress-freeness is due to the fact that a solution to a Cuckoo with Grin's default parameters can typically be found in under a second on most GPUs. Members of a pool are thus able to prove they're working on a solution to a block by submitting valid Cuckoo solutions (or a small bundle of them) that simply fall under the current network target difficulty.</p>"},{"location":"wiki/miscellaneous/dandelion/","title":"Dandelion++ in Grin: Privacy-Preserving Transaction Aggregation and Propagation","text":"<p>Read this document in other languages: Korean[out of date].</p>"},{"location":"wiki/miscellaneous/dandelion/#introduction","title":"Introduction","text":"<p>The Dandelion++ protocol for broadcasting transactions, proposed by Fanti et al. (Sigmetrics 2018)<sup>1</sup>, intends to defend against deanonymization attacks during transaction propagation. In Grin, it also provides an opportunity to aggregate transactions before they are broadcast to the entire network. This document describes the protocol and the simplified version of it that is implemented in Grin.</p> <p>In the following section, past research on the protocol is summarized. This is then followed by describing details of the Grin implementation; the objectives behind its inclusion, how the current implementation differs from the original paper, what some of the known limitations are, and outlining some areas of improvement for future work.</p>"},{"location":"wiki/miscellaneous/dandelion/#research","title":"Research","text":"<p>The original version of Dandelion was introduced by Fanti et al. and presented at ACM Sigmetrics 2017<sup>2</sup>. On June 2017, a BIP<sup>3</sup> was proposed introducing a more practical and robust variant of Dandelion called Dandelion++, which was formalized into a paper in 2018<sup>1</sup>.</p> <p>The protocols are outlined at a high level here. For a more in-depth presentation with extensive literature references, please refer to the original papers.</p>"},{"location":"wiki/miscellaneous/dandelion/#motivation","title":"Motivation","text":"<p>Dandelion was conceived as a way to mitigate large scale deanonymization attacks on the network layer of Bitcoin, made possible by the diffusion method for propagating transactions on the network. By deploying \"super-nodes\" that connect to a large number of honest nodes on the network, adversaries can listen to the transactions relayed by the honest nodes as they get diffused symmetrically on the network using epidemic flooding or diffusion. By observing the spreading dynamic of a transaction, it has been proven possible to link it (and therefore also the sender's Bitcoin address) to the originating IP address with a high degree of accuracy, and as a result de-anonymize users.</p>"},{"location":"wiki/miscellaneous/dandelion/#dandelion","title":"Dandelion","text":"<p>In the original paper <sup>2</sup>, a dandelion spreading protocol is introduced. Dandelion spreading propagation consists of two phases: first the anonymity phase, or the \u201cstem\u201d phase, and second the spreading phase, or the \u201cfluff\u201d phase, as illustrated in Figure 1.</p> <p>Figure 1. Dandelion phase illustration.</p> <pre><code>                                                   \u250c-&gt; F ...\n                                           \u250c-&gt; D --\u2524\n                                           |       \u2514-&gt; G ...\n  A --[stem]--&gt; B --[stem]--&gt; C --[fluff]--\u2524\n                                           |       \u250c-&gt; H ...\n                                           \u2514-&gt; E --\u2524\n                                                   \u2514-&gt; I ...\n</code></pre> <p>In the initial stem-phase, each node relays the transaction to a single randomly selected peer, constructing a line graph. Users then forward transactions along the same path on the graph. After a random number of hops along the stem, the transaction enters the fluff-phase, which behaves like ordinary diffusion. This means that even when an attacker can identify the originator of the fluff phase, it becomes more difficult to identify the source of the stem (and thus the original broadcaster of the transaction).</p> <p>Each individual node pseudorandomly selects if he is a stem or a fluff node at regular intervals, called epoch periods. Epochs are asynchronous, with each individual node keeping its own internal clock and starting a new epoch once a certain threshold has been reached. Thus, the constructed line graph is periodically re-generated randomly, at the expiry of each epoch, limiting an adversary's possibility to build knowledge of the graph.</p> <p>The 'Dandelion' name is derived from how the protocol resembles the spreading of the seeds of a dandelion.</p>"},{"location":"wiki/miscellaneous/dandelion/#dandelion_1","title":"Dandelion++","text":"<p>In the Dandelion++ paper<sup>1</sup>, the authors build on the original concept further by defending against stronger adversaries that are allowed to disobey protocol.</p> <p>The original paper makes three ideal assumptions:</p> <ol> <li>All nodes obey protocol.</li> <li>Each node generates exactly one transaction.</li> <li>All nodes on the network run Dandelion.</li> </ol> <p>An adversary can violate these rules, and by doing so, break some of the anonymity properties.</p> <p>The modified Dandelion++ protocol makes small changes to many of the Dandelion choices, resulting in an exponentially more complex information space. This in turn makes it harder for an adversary to de-anonymize the network.</p> The paper describes five types of attacks, and proposes specific updates to the original Dandelion protocol to mitigate against these, presented in Table A (here in summarized form). <p>Table A. Summary of Dandelion++ changes</p> Attack Solution Graph-learning 4-regular anonymity graph Intersection Pseudorandom forwarding Graph-construction Non-interactive construction Black-hole Random stem timers Partial deployment Blind stem selection"},{"location":"wiki/miscellaneous/dandelion/#dandelion-algorithm","title":"Dandelion++ Algorithm","text":"<p>As with the original Dandelion protocol, epochs are asynchronous, each node keeping track of its own epoch, which the suggested duration being in the order of 10 minutes.</p>"},{"location":"wiki/miscellaneous/dandelion/#anonymity-graph","title":"Anonymity Graph","text":"<p>Rather than a line graph as per the original paper (which is 2-regular), a quasi-4-regular graph is constructed by a node at the beginning of each epoch: the node chooses (up to) two of its outbound peers uniformly at random as its dandelion++ relays. As a node enters into a new epoch, new dandelion++ relays are chosen.</p> <p>Figure 2. representation of a 4-regular graph. <pre><code>in1        out1\n  \\       /\n   \\     /\n    NodeX\n   /     \\\n  /       \\\nin2        out2\n</code></pre> <code>NodeX</code> has four connections to other nodes, input nodes <code>in1</code> and <code>in2</code>, and output nodes <code>out1</code> and <code>out2</code>.</p> <p>4-regular vs 2-regular graphs</p> <p>The choice between using 4-regular or 2-regular (line) graphs is not obvious. The authors note that it is difficult to construct an exact 4-regular graph within a fully-distributed network in practice. They outline a method to construct an approximate 4-regular graph in the paper.</p> <p>They also write:</p> <p>... We recommend making the design decision between 4-regular graphs and line graphs based on the priorities of the system builders. If linkability of transactions is a first-order concern, then line graphs may be a better choice. Otherwise, we find that 4-regular graphs can give constant- order privacy benefits against adversaries with knowledge of the graph.</p>"},{"location":"wiki/miscellaneous/dandelion/#transaction-forwarding-own","title":"Transaction forwarding (own)","text":"<p>At the beginning of each epoch, <code>NodeX</code> picks one of <code>out1</code> and <code>out2</code> to use as a route to broadcast its own transactions through as a stem-phase transaction. The same route is used throughout the duration epoch, and <code>NodeX</code> always forwards (stems) its own transaction.</p>"},{"location":"wiki/miscellaneous/dandelion/#transaction-forwarding-relay","title":"Transaction forwarding (relay)","text":"<p>At the start of each epoch, <code>NodeX</code> makes a choice to be either in fluff-mode or in stem-mode. This choice is made in pseudorandom fashion, with the paper suggesting it being computed from a hash of the node's own identity and epoch number. The probability of choosing to be in fluff-mode (or as the paper calls it, the path length parameter <code>q</code>) is recommended to be q \u2264 0.2.</p> <p>Once the choice has been made whether to stem or to fluff, it applies to all relayed transactions passing through it during the epoch.</p> <ul> <li> <p>in fluff-mode, <code>NodeX</code> is will broadcast any received transactions to the network using diffusion.</p> </li> <li> <p>in stem-mode, at the beginning of each epoch <code>NodeX</code> will map <code>in1</code> to either <code>out1</code> or <code>out2</code> pseudorandomly, and similarly map <code>in2</code> to either <code>out1</code> or <code>out2</code> in the same fashion. Based on this mapping, it will then forward all txs from <code>in1</code> along the chosen route, and similarly forward all transactions from <code>in2</code> along that route. The mapping persists throughout the duration of the epoch.</p> </li> </ul>"},{"location":"wiki/miscellaneous/dandelion/#fail-safe-mechanism","title":"Fail-safe mechanism","text":"<p>For each stem-phase transaction that was sent or relayed, <code>NodeX</code> tracks whether it is seen again as a fluff-phase transaction within some random amount of time. If not, the node fluffs the transaction itself.</p> This expiration timer is set by each stem-node upon receiving a transaction to forward, and is chosen randomly. Nodes are initialized with a timeout parameter T<sub>base</sub>. As per equation (7) in the paper, when a stem-node <code>v</code> receives a transaction, it sets an expiration time T<sub>out</sub>(v): <p>T<sub>out</sub>(v) ~ current_time + exp(1/T<sub>base</sub>)</p> <p>If the transaction is not received again by relay <code>v</code> before the expiry of T<sub>out</sub>(v), then it broadcasts the message using diffusion. This approach means that the if the transaction gets does not enter fluff-phase in time, the first stem-node to broadcast is approximately uniformly selected among all stem-nodes who have seen the transaction, rather than the originating node who created it.</p> <p>The paper also proceeds to specify the size of the initiating time out parameter T<sub>base</sub> as part of <code>Proposition 3</code> in the paper:</p> <p>Proposition3. For a timeout parameter</p> <p>T<sub>base</sub> \u2265 (\u2212k(k\u22121)\u03b4<sub>hop</sub>) / 2 log(1\u2212\u03b5 ),</p> <p>where <code>k</code>, <code>\u03b5</code> are parameters and \u03b4<sub>hop</sub> is the time between each hop (e.g., network and/or internal node latency), transactions travel for <code>k</code> hops without any peer initiating diffusion with a probability of at least <code>1 \u2212 \u03b5</code>.</p>"},{"location":"wiki/miscellaneous/dandelion/#dandelion-in-grin","title":"Dandelion in Grin","text":""},{"location":"wiki/miscellaneous/dandelion/#objectives","title":"Objectives","text":"<p>The choice to include Dandelion in Grin has two main motives behind it:</p> <ol> <li>Act as a countermeasure against mass de-anonymization attacks. Similar to Bitcoin, the Grin P2P network would be vulnerable to attackers deploying malicious \"super-nodes\" connecting to most peers on the network and monitoring transactions as they become diffused by their honest peers. This would allow a motivated actor to infer with a high degree of probability from which peer (IP address) transactions originate from, having negative privacy consequences.</li> <li>Aggregate transactions before they are being broadcast to the entire network. This is a benefit to blockchains that enable non-interactive CoinJoins on the protocol level, such as Mimblewimble. Despite its good privacy features, some input and output linking is still possible in Mimblewimble and Grin.<sup>4</sup> If you know which input spends to which output, it is possible to construct a transaction graph and follow a chain of transaction outputs (TXOs) as they are being spent. Aggregating transactions make this more difficult to carry out, as it becomes less clear which input spends to which output (Figure 3). In order for this to be effective, there needs to be a large anonymity set, i.e. many transactions to aggregate with one another. Dandelion enables this aggregation to occur before transactions are fluffed and diffused to the entire network. This adds obfuscation to the transaction graph, as a malicious observer who is not participating in the stemming or fluffing would not only need to figure out from where a transaction originated, but also which outputs and inputs out of a larger group should be attributed to the originating transaction.</li> </ol> <p>Figure 3. (switch between tabs)</p> Not Aggregated Inputs Outputs Kernels t r a n s a c t i o n A X Kernel 1 Y t r a n s a c t i o n B Z Kernel 2 C Aggregated Inputs Outputs Kernels A X Kernel 1 B Y Kernel 2 C Z"},{"location":"wiki/miscellaneous/dandelion/#current-implementation","title":"Current implementation","text":"<p>Grin implements a simplified version of the Dandelion++ protocol. It's been improved several times, most recently in version 1.1.0<sup>5</sup>.</p> Dandelion configuration options in grin-server.toml (default) <pre><code>#dandelion epoch duration\nepoch_secs = 600\n\n#fluff and broadcast after embargo expires if tx not seen on network\nembargo_secs = 180\n\n#dandelion aggregation period in secs\naggregation_secs = 30\n\n#dandelion stem probability (stem 90% of the time, fluff 10% of the time)\nstem_probability = 90\n\n#always stem our (pushed via api) txs regardless of stem/fluff epoch (as per Dandelion++ paper)\nalways_stem_our_txs = true\n</code></pre> <ol> <li><code>DandelionEpoch</code> tracks a node's current epoch. This is configurable via <code>epoch_secs</code> with default epoch set to last for 10 minutes. Epochs are set and tracked by nodes individually.</li> <li>At the beginning of an epoch, the node chooses a single connected peer at random to use as their outbound relay.</li> <li>At the beginning of an epoch, the node makes a decision whether to be in stem mode or in fluff mode. This decision lasts for the duration of the epoch. By default, this is a random choice, with the probability to be in stem mode set to 90%, which implies a fluff mode probability, <code>q</code> of 10%. The probability is configurable via <code>DANDELION_STEM_PROBABILITY</code>.  The number of expected stem hops a transaction does before arriving to a fluff node is <code>1/q = 1/0.1 = 10</code>.</li> <li> <p>Any transactions received from inbound peers or transactions originated from the node itself are first added to the node's <code>stempool</code>, which is a list of stem transactions, that each node keeps track of individually. Transactions are  removed from the stempool if:</p> <ul> <li>The node fluffs the transaction itself.</li> <li>The node sees the transaction in question propagated through regular diffusion, i.e. from a different peer having \"fluffed\" it.</li> <li>The node receives a block containing this transaction, meaning that the transaction was propagated and included in a block.</li> </ul> </li> <li> <p>For each transaction added to the stempool, the node sets an embargo timer. This is set by default to 180 seconds, and is configurable via <code>embargo_secs</code>.</p> </li> <li>A <code>dandelion_monitor</code> runs every 10 seconds and handles tasks.</li> <li>If the node is in stem mode, then:<ol> <li>After being added to the stempool, received stem transactions are forwarded onto the their relay node as a stem transaction.</li> <li>As peers connect at random, it is possible they create a circular loop of connected stem mode nodes (i.e. <code>A -&gt; B -&gt; C -&gt; A</code>). Therefore, if a node receives a stem transaction from an inbound node that already exists in its own stempool, it will fluff it, broadcasting it using regular diffusion.</li> <li><code>dandelion_monitor</code> checks for transactions in the node's stempool with an expired embargo timer, and broadcast those individually.</li> </ol> </li> <li>If the node is in fluff mode, then:<ol> <li>Transactions received from inbound nodes are kept in the stempool.</li> <li><code>dandelion_monitor</code> checks in the stempool whether any  transactions are older than 30 seconds (configurable as <code>DANDELION_AGGREGATION_SECS</code>). If so, these are aggregated and then fluffed. Otherwise no action is taken, allowing for more stem transactions to aggregate in the stempool in time for the next triggering of <code>dandelion_monitor</code>.</li> <li>At the expiry of an epoch, all stem transactions remaining in the stem pool are aggregated and fluffed.</li> </ol> </li> </ol> <p>Nodes stem their own transactions</p> <p>Regardless of whether the node is in fluff or stem mode, any transactions generated from the node itself are forwarded onwards to their relay node as a stem transaction.<sup>6</sup></p>"},{"location":"wiki/miscellaneous/dandelion/#known-limitations","title":"Known limitations","text":"<p>2-regular graphs are used rather than 4-regular graphs as proposed by the paper. It's not clear what impact this has, the paper suggests a trade-off between general linkability of transactions and protection against adversaries who know the entire network graph.</p> <p>Additionally, unlike the Dandelion++ paper, the embargo timer is by default identical across all nodes. This means that during a black-hole attack where a malicious node withholds transactions, the node most likely to have its embargo timer expire and fluff the transaction will be the originating node, therefore exposing itself.</p>"},{"location":"wiki/miscellaneous/dandelion/#future-work","title":"Future work","text":"<ul> <li>Randomized embargo timer according to the recommendations of the paper to make it more random which node fluffs an expired transaction.</li> <li>Evaluation of whether 4-regular graphs are preferred over 2-regular line graphs.</li> <li>Simulation of the current implementation to understand performance.</li> </ul>"},{"location":"wiki/miscellaneous/dandelion/#references","title":"References","text":"<ol> <li> <p>Dandelion++: Lightweight Cryptocurrency Networking with Formal Anonymity Guarantees (Sigmetrics'18) \u21a9\u21a9\u21a9</p> </li> <li> <p>Dandelion: Redesigning the Bitcoin Network for Anonymity (Sigmetrics'17) \u21a9\u21a9</p> </li> <li> <p>Dandelion BIP \u21a9</p> </li> <li> <p>Grin Privacy Primer \u21a9</p> </li> <li> <p>#2628: Dandelion++ Rewrite \u21a9</p> </li> <li> <p>#2876: Always stem local txs if configured that way (unless explicitly fluffed) \u21a9</p> </li> </ol>"},{"location":"wiki/miscellaneous/nrd-kernels/","title":"NRD Kernels","text":"<ul> <li>Title: <code>nrd-kernels</code></li> <li>Authors: Antioch Peverell</li> <li>Start date: Mar 24, 2020</li> <li>RFC PR: mimblewimble/grin-rfcs#47</li> <li>Tracking issue: mimblewimble/grin#3288</li> </ul>"},{"location":"wiki/miscellaneous/nrd-kernels/#summary","title":"Summary","text":"<p>Grin supports a limited implementation of \"relative timelocks\" with \"No Recent Duplicate\" (NRD) transaction kernels. Transactions can be constructed such that they share duplicate kernels. An NRD kernel instance is not valid within a specified number of blocks relative to a prior duplicate instance of the kernel. A minimum height difference must therefore exist between two instances of an NRD kernel. This provides the relative height lock between transactions.</p>"},{"location":"wiki/miscellaneous/nrd-kernels/#motivation","title":"Motivation","text":"<p>Relative timelocks are a prerequisite for robust payment channels. NRD kernels can be used to implement a revocable channel close mechanism. A mandatory revocation period can be introduced through a relative timelock between two transactions. Any attempt to close an old invalid channel state can be safely revoked during the revocation period.</p> <p>Recently, Ruben Somsen announced a design for [Succinct Atomic Swaps (SAS)]<sup>10</sup> reducing the number of on-chain transactions required to implement the swap. This design uses a combination of relative locks and [adaptor signatures]<sup>11</sup>. SAS would appear to be compatible with Grin/MW but with some caveats, namely the need for an additional transaction kernel as the NRD lock and the adaptor signature cannot co-exist on the same kernel. This is discussed in Unresolved questions below.</p>"},{"location":"wiki/miscellaneous/nrd-kernels/#community-level-explanation","title":"Community-level explanation","text":"<p>A minimum distance in block height is enforced between successive duplicate instances of a given NRD kernel. This can be used to enforce a relative lock height between two transactions. A transaction containing an NRD kernel will not be accepted as valid within the specified block height relative to any prior instance of the NRD kernel.</p> <p>Transactions can be constructed around an existing transaction kernel by introducing either an additional kernel or in some cases by simply adjusting the kernel offset. This allows NRD kernels to be used across any pair of transactions.</p> <p>The NRD kernel implementation aims for simplicity and a minimal approach to solving the problem of \"relative locks\". Grin does not support a general solution for arbitrary length locks between arbitrary kernels. The implementation is limited in scope to avoid adversely impacting performance and scalability. References between duplicate kernels are implicit, avoiding the need to store kernel references. Locks are limited in length to recent history, avoiding the need to inspect the full historical kernel set during verification.</p>"},{"location":"wiki/miscellaneous/nrd-kernels/#reference-level-explanation","title":"Reference-level explanation","text":"<p>An NRD kernel is not valid within a specified number of blocks of a previous duplicate instance of the same NRD kernel. We define duplicate here as two NRD kernels sharing the same public excess commitment. NRD kernels with different excess commitments are not treated as duplicates. An NRD kernel and a non-NRD kernel (plain kernel, coinbase kernel etc.) sharing the same excess commitment are not treated as duplicates.</p> <p>An NRD kernel has an associated relative lock height. For a block B containing this kernel to be valid, no duplicate instance of the kernel can exist in the last RH blocks (up to and including B), where RH is the relative lock height. For example, a transaction containing an NRD kernel with relative lock height 1440 (24 hours) is included in a block at height 1000000. This block is only valid if no duplicate instance of this kernel exists in any block from height 998561 (h-1439) to height 1000000 (h-0) inclusive. A duplicate instance is permitted at height 998560 (h-1440), with the transaction seen as valid. If no duplicate instance of the kernel exists within this range then the lock criteria is met.</p> <p>A kernel can be delayed by the existence of a previous kernel. The non-existence of a previous kernel has no impact on the lock criteria. Note that this implies the first singular occurrence of any NRD kernel meets the lock criteria trivially as it cannot, by definition, be locked by a previous kernel. Thus, the relative lock defaults to \"fail open\" semantics.</p> <p>Each node maintains an index of recent NRD kernels to enable efficient checking of NRD relative lock heights. Note we only need to index NRD locks and we only need to index those within recent history. Relative locks longer than 7 days are not valid. This is believed to be sufficient to cover all proposed use cases.</p> <p>The minimum value for a relative lock height is 1 meaning a prior instance of the kernel can exist in the previous block for the lock criteria to be met. An instance of the NRD kernel in the same block will invalidate the block as the lock criteria will not be met.</p> <p>NRD lock heights of 0 are invalid and it is never valid for two duplicate instances of the same NRD kernel to exist in the same block.</p> <p>It follows that two transactions containing duplicate instances of the same NRD kernel cannot be accepted as valid in the transaction pool concurrently. Current txpool behavior is \"first one wins\" semantics when receiving transactions and this will also apply to transactions containing NRD kernels. We plan to revisit this in a future \"fee\" RFC and plan to investigate the feasibility of introducing \"replace by fee\" semantics at that time.</p> <p>Grin supports \"rewind\" back through recent history to handle fork and chain reorg scenarios. 1 week of full blocks are maintained on each node and up to 10080 blocks can be rewound. To support relative lock heights each node must maintain an index over sufficient kernel history for an additional 10080 blocks beyond this rewind horizon. Each node should maintain 2 weeks of kernel history in the local NRD kernel index. This will cover the pathological case of a 1 week rewind and the validation of a 1 week long relative lock beyond that. The primary use case is for revocable payment channel close operations. We believe a 7 day period is more than sufficient for this. We do not require long, extended revocation periods and limiting this to a few days is preferable to keep the cost of verification low. The need for these revocable transactions to be included on chain should be low as these are only required in a non-cooperative situation but where required we want to minimize the cost of verification which must be performed across all nodes.</p> <p>The following kernel variants are supported in Grin -</p> <ul> <li>Plain</li> <li>Coinbase</li> <li>HeightLocked</li> <li>NoRecentDuplicate</li> </ul> <p>These are implemented as kernel \"feature\" variants -</p> <pre><code>pub enum KernelFeatures {\n    /// Plain kernel (default for Grin txs).\n    Plain = 0,\n    /// A coinbase kernel.\n    Coinbase = 1,\n    /// A kernel with an explicit absolute lock height.\n    HeightLocked = 2,\n    /// A relative height locked NRD kernel.\n    NoRecentDuplicate = 3,\n}\n</code></pre> <p>Each kernel variant includes feature specific data -</p> <pre><code># Plain\n{\n  \"fee\": 8\n}\n# Coinbase\n{\n  # empty\n}\n# Height Locked\n{\n  \"fee\": 8,\n  \"lock_height\": 295800\n}\n# No Recent Duplicate (NRD)\n{\n  \"fee\": 8,\n  \"relative_height\": 1440,\n}\n</code></pre> <p>Note that NRD kernels require no additional data beyond that required for absolute height locked kernels. The reference to the previous kernel is implicit and based on a duplicate NRD kernel excess commitment.</p> <p>The maximum supported NRD relative_height is 10080 (7 days) and the relative height can be safely and conveniently represented as a <code>u16</code> (2 bytes). This differs from absolute lock heights where <code>u64</code> (8 bytes) is necessary to specify the lock height.</p> <p>The minimum supported NRD relative_height is 1 and a value of 0 is not valid. Two duplicate instances of a given NRD kernel cannot exist simultaneously in the same block. There must be a relative height of at least 1 block between them.</p> <p>Nodes on the Grin network currently support two serialization versions for transaction kernels -</p> <p>V1 \"fixed size kernels\"</p> <p>In V1 all kernels are serialized to the same \"fixed\" number of bytes:</p> <pre><code>feature (1 byte) | fee (8 bytes) | additional_data (8 bytes) | excess commitment (33 bytes) | signature (64 bytes)\n\n03 | 00 00 00 00 01 f7 8a 40 | 00 00 00 00 00 00 05 A0 | 08 b1 ... 22 d8 | 33 11 ... b9 69\n</code></pre> <p>NRD kernels use the last 2 bytes of feature specific data for the relative lock height as big-endian u16. The first 6 bytes of feature specific data must be all zero:</p> <pre><code>00 00 00 00 00 00 05 A0\n</code></pre> <p>Note: absolute lock height (u64) and relative lock height (u16) have identical serialization in practice.</p> <p>V1 is supported for backward compatibility with nodes that do not support V2 \"variable size kernels\".</p> <p>V2 \"variable size kernels\"</p> <p>V2 kernels have been supported since Grin <code>v2.1.0</code> and V2 supports the notion of \"variable size\" kernels. See [RFC-0005 \"Variable Size Kernels\"]<sup>12</sup> for details of this.</p> <p>NRD kernels include 8 bytes for the fee as big-endian u64 and 2 bytes for the relative lock height:</p> <pre><code>feature (1 byte) | fee (8 bytes) | relative_height (2 bytes) | excess commitment (33 bytes) | signature (64 bytes)\n\n03 | 00 00 00 00 00 6a cf c0 | 05 A0 | 09 4d ... bb 9a | 09 c7 ... bd 54\n</code></pre> <p>In V2 relative lock height is 2 bytes as big-endian u16:</p> <pre><code>05 A0\n</code></pre> <p>Note: the serialization strategy is used for both network \"on the wire\" serialization of both transactions and full blocks, and local storage, both the database for full blocks and the kernel MMR backend files. Version negotiation occurs during the initial peer connection setup process and determines which version is used for p2p message serialization. If a node uses V2 serialization for the kernel MMR backend file then it will provide a V2 txhashset based on these underlying files.</p> <p>Kernel Signature Message</p> <p>Every kernel contains a signature proving the excess commitment is a commitment to zero. The message being signed includes the features, fee and other associated data to prevent malleability of the transaction kernel and the overall transaction. The transaction fee cannot be modified after signing, for example.</p> <p>For NRD kernels the message being signed is constructed as follows with the relative lock height serialized as 2 bytes.</p> <pre><code>Hash(feature | fee | relative_height)\n\nHash(03 | 00 00 00 00 01 f7 8a 40 | 05 A0)\n</code></pre> <p>No additional data is introduced with NRD kernels beyond the 2 bytes representing the relative lock height. There is no opportunity to include arbitrary data. Any additional kernel included in a transaction is itself still a fully valid kernel. There is no explicit reference necessary that could be misused to include arbitrary data.</p> <p>An additional NRD kernel in a transaction will increase the \"weight\" of the transaction by this single additional kernel and allows for a simple way to deal with additional fees. A transaction with an additional kernel must provide additional fees to cover the additional \"weight\". NRD kernels cannot be added for free. Note that in some limited situations it is possible to replace a kernel with an NRD kernel. If the NRD lock can be introduced without adding an additional kernel then the fee does not have to be increased and the lock is effectively added for free.</p> <p>A transaction kernel consists of an excess commitment and an associated signature showing this excess is indeed a commitment to 0.</p> <p>A transaction with a single kernel can always be represented as a transaction with multiple kernels, provided the kernels excess commitments sum to the correct total excess.</p> <p>Given an existing NRD kernel with excess commitment -</p> <ul> <li>r'G + 0H</li> </ul> <p>And a transaction with single excess commitment -</p> <ul> <li>rG + 0H</li> </ul> <p>This transaction can be represented as a pair of kernels with excess commitments -</p> <ul> <li>rG + 0H =     (r'G + 0H) + (r-r'G + 0H)</li> </ul> <p>We take advantage of this to allow an arbitrary NRD kernel to be included in any transaction at construction time.</p> <p>Additionally the kernel offset included in each transaction can be used in certain situations to allow the replacement of a single transaction kernel with an NRD kernel without needing to introduce an additional kernel.</p> <p>Given an existing NRD kernel with excess commitment -</p> <ul> <li>r'G + 0H</li> </ul> <p>And a transaction with single excess commitment and kernel offset -</p> <ul> <li>rG + 0H, o</li> </ul> <p>This transaction can be rewritten to use the NRD kernel -</p> <ul> <li>r'G + 0H, (o+r-r')</li> </ul> <p>These two \"degrees of freedom\", introducing multiple kernels and adjusting the kernel offset, allowing for flexibility to introduce an NRD kernel in a variety of ways.</p> <ul> <li>Introduce NRD kernel to transaction, compensate with additional kernel.</li> <li>Introduce NRD kernel to transaction, compensate with kernel offset.</li> </ul>"},{"location":"wiki/miscellaneous/nrd-kernels/#payment-channel-implementation","title":"Payment Channel Implementation","text":"<p>NRD kernels can be used to delay alternate \"branches\" of conflicting transactions, enabling a payment channel implementation.</p> <p>A payment channel is represented as a single multi-party output. Each channel state transition is represented as a pair of \"close\" and \"settle\" transactions with an NRD kernel enforcing a delay between them. Funds are held in an intermediate multi-party output while delayed. The NRD kernel is reused across both transactions by adjusting kernel offsets.</p> <p>X -&gt; Y, K<sub>nrd_a</sub> \\ Y -&gt; [Z<sub>a</sub>, Z<sub>b</sub>], K<sub>nrd_a</sub></p> <p>Alice closes the channel X with their \"close\" transaction. After a delay Alice can \"settle\" the funds out to Alice and Bob.</p> <p>Attribution of \"close\" and \"settle\" transactions for each channel state is provided through endpoint specific NRD kernels. This allows the other party to \"revoke\" old invalid state without the NRD delay.</p> <p>Each channel state transition involves a new pair of \"close\" and \"settle\" transactions for each participant along with a shared \"revoke\" transaction. The \"revoke\" transaction simply spends funds back to the channel output and a plain kernel suffices.</p> <p>[Z<sub>a</sub>, Z<sub>b</sub>] -&gt; X, K<sub>rev</sub></p> <p>Alice attempts to close old invalid state (Y<sub>1</sub>):</p> <p>X -&gt; Y<sub>1</sub>, K<sub>nrd_a1</sub></p> <p>Bob can immediately revoke and close current state (Y<sub>1</sub> -&gt; Y<sub>2</sub>):</p> <p>Y<sub>1</sub> -&gt; ~[Z<sub>a</sub>, Z<sub>b</sub>]~, K<sub>nrd_b1</sub> \\ ~[Z<sub>a</sub>, Z<sub>b</sub>]~ -&gt; <sub>X</sub>, K<sub>rev_1</sub> \\ <sub>X</sub> -&gt; Y<sub>2</sub>, K<sub>nrd_b2</sub> \\ =&gt; Y<sub>1</sub> -&gt; Y<sub>2</sub>, [K<sub>nrd_b1</sub>, K<sub>rev_1</sub>, K<sub>nrd_b2</sub>]</p> <p>Bob publishes only the final cut-through multi-kernel transaction (Y<sub>1</sub> -&gt; Y<sub>2</sub>). Bob's individual settle transaction is not revealed.</p> <p>Neither party can self-revoke without introducing the NRD delay. The other party always has the opportunity to revoke first. Self-revocation cannot be used to lock funds up indefinitely.</p> HF3 (July 2020) Rollout/Deployment <p>The following rules will be enforced during rollout as part of HF3 -</p> <p>Assumptions:</p> <ol> <li>HF3 will occur at height 786,240.</li> <li>Blocks at height &gt;= 786,240 will have block version &gt;= 4.</li> </ol> <p>Block Specific Rules:</p> <ol> <li>A block containing NRD kernel(s) is only be valid if block version &gt;= 4.</li> <li>A block containing NRD kernel(s) is only valid if all defined relative lock height rules are met.</li> <li>Two duplicate NRD kernel instances cannot exist in the same block.</li> </ol> <p>Transaction Specific Rules:</p> <ol> <li>A transaction containing NRD kernel(s) will not be accepted by the local txpool/stempool unless chain head version &gt;= 4.</li> <li>A transaction containing NRD kernel(s) will not be relayed or broadcast to other nodes unless chain head version &gt;= 4.</li> <li>A transaction containing NRD kernel(s) will not be accepted by the local txpool/stempool unless it meets the defined relative lock height rule in the next block.</li> <li>A transaction containing NRD kernel(s) will not be relayed or broadcast to other nodes unless it meets the defined relative lock height rule in the next block.</li> <li>Two duplicate NRD kernel instances cannot exist in the txpool/stempool concurrently.</li> </ol>"},{"location":"wiki/miscellaneous/nrd-kernels/#weights-fees","title":"Weights &amp; Fees","text":"<p>For the purpose of block weight calculations, each kernel is treated as 3 \"weight units\" where each unit is approximately 32 bytes. This covers the excess commitment and the associated signature common across all kernel variants. The additional 2 bytes of \"relative height\" on NRD kernels are ignored for the purposes of calculating block weight.</p> <p>For the purpose of minimum transaction relay fees all kernels are treated as 1 \"fee unit\" with each unit being 1 milligrin. We plan to revisit the entire transaction fee structure in a future RFC. Kernel variants may affect the transaction fee calculations differently in the future.</p>"},{"location":"wiki/miscellaneous/nrd-kernels/#drawbacks","title":"Drawbacks","text":"<p>NRD kernels are a limited and restricted form of \"relative locks\" between kernels. These locks are limited to a period of 7 days and \"fail open\" beyond that window. This approach meets the requirements for limited revocable payment channel operations but there are likely to be use cases where this approach is not sufficient or unsuitable.</p> <p>While it would be nice to provide a fully general purpose solution that would allow arbitrary locks to be implemented, it does appear to be hard, if not impossible, to do this in Grin/MW.</p>"},{"location":"wiki/miscellaneous/nrd-kernels/#rationale-and-alternatives","title":"Rationale and alternatives","text":"<p>Referencing historical data in Grin and in Mimblewimble in general is difficult due to the possibility of pruning historical data. It is not possible to reference old outputs once they are spent. Historical validators must have access to any referenced data to validate consensus rules. This leaves transaction kernels as the only available data to be referenced. While arbitrary historical kernels can be referenced this is not desirable as we do not want to impose additional constraints on nodes, requiring them to maintain historical data that would otherwise be prunable.</p> <p>An earlier design iteration was \"No Such Kernel Recently\" (NSKR) locks. Where NRD references were implicit, with duplicate kernel excess commitments, NSKR kernels referenced prior kernels explicitly. These explicit references were problematic for several reasons -</p> <ul> <li>Additional overhead, both local storage and network traffic due to the explicit references.</li> <li>Optimization by referencing prior kernel based on MMR position introduced a dependency on external data (kernels can no longer be validated in isolation).</li> <li>Permitting non-existence of references due to limited window of history, opened up a vector for \"spam\" where arbitrary data could be used in place of a valid reference.</li> </ul> <p>To prevent \"spam\" a signature can be used to verify the reference was indeed a valid commitment. By including a signature along with the commitment, the reference is effectively a full transaction kernel.</p> <p>The idea of using Merkle proofs to verify inclusion of a historical referenced kernel in the kernel MMR was also considered. This gets expensive both in terms of transaction size and increased verification cost. There is also the problem of position not yet being known at transaction creation time, necessitating Merkle proof generation at block creation time by miners which adds complexity.</p>"},{"location":"wiki/miscellaneous/nrd-kernels/#prior-art","title":"Prior art","text":"<p>Bitcoin allows transaction inputs to be \"encumbered\" with a relative locktime based on the sequence number field. This restricts an input from spending the associated output until a certain number of blocks have passed. BIP112 describes the CHECKSEQUENCEVERIFY opcode in Bitcoin and BIP68 describes the underlying consensus changes around the sequence number field.</p> <ul> <li>[Timelock#CheckSequenceVerify (bitcoin wiki)]<sup>6</sup></li> <li>[CheckSequenceVerify (bitcoin wiki)]<sup>7</sup></li> <li>[Bitcoin BIP-0068]<sup>8</sup></li> <li>[Bitcoin BIP-0112]<sup>9</sup></li> </ul> <p>Note that relative locks in Bitcoin are based on transaction inputs and outputs, with inputs only able to spend outputs once confirmed beneath a certain number of blocks. We cannot do this in Grin due to the pruning of old data. Spent outputs will eventually be removed and cannot be relied upon as part of the validation process. Bitcoin encumbers individual outputs whereas in Grin we encumber transactions via the constituent transaction kernels.</p>"},{"location":"wiki/miscellaneous/nrd-kernels/#unresolved-questions","title":"Unresolved questions","text":"<p>Some investigation is still needed around the conditions necessary to allow a kernel to simply be reused with an adjustment to the kernel offset and where an additional kernel is necessary. An adjustment to the kernel offset will expose the private excess under certain conditions and cannot be done safely for all transactions.</p> <p>One outstanding question is what use cases are not covered by NRD kernels. We believe them to be sufficient for the revocable payment channel close mechanism. But they may not be sufficient for all use cases.</p> <p>[Succinct Atomic Swaps (SAS)]<sup>10</sup> describes the use of both relative locks and [adaptor signatures]<sup>11</sup> to implement atomic swaps with only two on-chain transactions. The secret associated with the adaptor signature is swapped to allow funds to be claimed while the relative lock locks funds prior to a refund being claimed. We note that NRD kernels and adaptor signatures are not directly compatible as a prior instance of an NRD kernel would have revealed the secret associated with the adaptor signature. That said we can produce transactions with multiple kernels and we can use this to isolate the adaptor signature on a separate kernel alongside an NRD kernel. It is an unresolved question if there is a way to modify the SAS protocol and avoid the need for these additional kernels in Grin/MW.</p>"},{"location":"wiki/miscellaneous/nrd-kernels/#references","title":"References","text":"<ol> <li> <p>Original \"triggers\" mailing list post by Ruben Somsen \u21a9</p> </li> <li> <p>\"No Such Kernel Recently\" post by John Tromp \u21a9</p> </li> <li> <p>\"Duplicate Kernels\" post by Antioch \u21a9</p> </li> <li> <p>\"NRD based payment channel\" post by John Tromp \u21a9</p> </li> <li> <p>Earlier NSKR based payment channel design \u21a9</p> </li> <li> <p>Timelock#CheckSequenceVerify (bitcoin wiki) \u21a9</p> </li> <li> <p>CheckSequenceVerify (bitcoin wiki) \u21a9</p> </li> <li> <p>Bitcoin BIP-0068 \u21a9</p> </li> <li> <p>Bitcoin BIP-0112 \u21a9</p> </li> <li> <p>Succinct Atomic Swaps by Ruben Somsen \u21a9\u21a9</p> </li> <li> <p>Scriptless Scripts \u21a9\u21a9</p> </li> <li> <p>RFC-0005 \"Variable Size Kernels\" \u21a9</p> </li> </ol>"},{"location":"wiki/miscellaneous/switch-commitments/","title":"Introduction to Switch Commitments","text":"<p>Read this in other languages: \u7b80\u4f53\u4e2d\u6587.</p>"},{"location":"wiki/miscellaneous/switch-commitments/#general-introduction","title":"General introduction","text":"<p>In cryptography a Commitment (or commitment scheme) refers to a concept which can be imagined like a box with a lock. You can put something into the box (for example a piece of a paper with a secret number written on it), lock it and give it to another person (or the public).</p> <p>The other person doesn't know yet what's the secret number in the box, but if you decide to publish your secret number later in time and want to prove that this really is the secret which you came up with in the first place (and not a different one) you can prove this simply by giving the key of the box to the other person.</p> <p>They can unlock the box, compare the secret within the box with the secret you just published and can be sure that you didn't change your secret since you locked it. You \"committed\" to the secret number beforehand, meaning you cannot change it between the time of commitment and the time of revealing.</p>"},{"location":"wiki/miscellaneous/switch-commitments/#examples","title":"Examples","text":""},{"location":"wiki/miscellaneous/switch-commitments/#hash-commitment","title":"Hash Commitment","text":"<p>A simple commitment scheme can be realized with a cryptographic hash function. For example: Alice and Bob want to play \"Guess my number\" and Alice comes up with with her really secret number <code>29</code> which Bob has to guess in the game, then before the game starts, Alice calculates:</p> <pre><code>hash( 29 + r )\n</code></pre> <p>and publishes the result to Bob. The <code>r</code> is a randomly chosen  Blinding Factor which is needed because otherwise Bob could just try hashing all the possible numbers for the game and compare the hashes.</p> <p>When the game is finished, Alice simply needs to publish her secret number <code>29</code> and the blinding factor <code>r</code> and Bob can calculate the hash himself and easily verify that Alice did not change the secret number during the game.</p>"},{"location":"wiki/miscellaneous/switch-commitments/#pedersen-commitment","title":"Pedersen Commitment","text":"<p>Other, more advanced commitment schemes can have additional properties. For example Mimblewimble and Confidential Transactions (CT) make heavy use of Pedersen Commitments, which are homomorphic commitments. Homomorphic in this context means that (speaking in the \"box\" metaphor from above) you can take two of these locked boxes (box1 and box2) and somehow \"add\" them together, so that you get a single box as result (which still is locked), and if you open this single box later (like in the examples before) the secret it contains, is the sum of the secrets from box1 and box2.</p> <p>While this \"box\" metaphor no longer seems to be reasonable in the real-world this is perfectly possible using the properties of operations on elliptic curves.</p> <p>Look into Introduction to Mimblewimble for further details on Pedersen Commitments and how they are used in Grin.</p>"},{"location":"wiki/miscellaneous/switch-commitments/#properties-of-commitment-schemes","title":"Properties of commitment schemes:","text":"<p>In general for any commitment scheme we can identify two important properties which can be weaker or stronger, depending on the type of commitment scheme:</p> <ul> <li> <p>Hidingness (or Confidentiality): How good is the commitment scheme protecting the secret   commitment. Or speaking in terms of our example from above: what would an attacker need to   open the box (and learn the secret number) without having the key to unlock it?</p> </li> <li> <p>Bindingness: Is it possible at all (or how hard would it be) for an attacker to somehow   find a different secret, which would produce the same commitment, so that the attacker could   later open the commitment to a different secret, thus breaking the binding of the   commitment.</p> </li> </ul>"},{"location":"wiki/miscellaneous/switch-commitments/#security-of-these-properties","title":"Security of these properties:","text":"<p>For these two properties different security levels can be identified.</p> <p>The two most important combinations of these are</p> <ul> <li>perfectly binding and computationally hiding commitment schemes and</li> <li>computationally binding and perfectly hiding commitment schemes</li> </ul> <p>\"Computationally\" binding or hiding means that the property (bindingness/hidingness) is secured by the fact that the underlying mathematical problem is too hard to be solved with existing computing power in reasonable time (i.e. not breakable today as computational resources are bound in the real world).</p> <p>\"Perfectly\" binding or hiding means that even with infinite computing power it would be impossible to break the property (bindingness/hidingness).</p>"},{"location":"wiki/miscellaneous/switch-commitments/#mutual-exclusivity","title":"Mutual exclusivity:","text":"<p>It is important to realize that it's impossible that any commitment scheme can be perfectly binding and perfectly hiding at the same time. This can be easily shown with a thought experiment: Imagine an attacker having infinite computing power, he could simply generate a commitment for all possible values (and blinding factors) until finding a pair that outputs the same commitment. If we further assume the commitment scheme is perfectly binding (meaning there cannot be two different values leading to the same commitment) this uniquely would identify the value within the commitment, thus breaking the hidingness.</p> <p>The same is true the other way around. If a commitment scheme is perfectly hiding there must exist several input values resulting in the same commitment (otherwise an attacker with infinite computing power could just try all possible values as described above). This concludes that the commitment scheme cannot be perfectly binding.</p>"},{"location":"wiki/miscellaneous/switch-commitments/#always-a-compromise","title":"Always a compromise","text":"<p>The key take-away point is this: it's always a compromise, you can never have both properties (hidingness and bindingness) with perfect security. If one is perfectly secure then the other can be at most computationally secure (and the other way around).</p>"},{"location":"wiki/miscellaneous/switch-commitments/#considerations-for-cryptocurrencies","title":"Considerations for cryptocurrencies","text":"<p>Which roles do these properties play in the design of cryptocurrencies?</p> <p>Hidingness: In privacy oriented cryptocurrencies like Grin, commitment schemes are used to secure the contents of transactions. The sender commits to an amount of coins he sends, but for the general public the concrete amount should remain private (protected by the hidingness property of the commitment scheme).</p> <p>Bindingness: At the same time no transaction creator should ever be able to change his commitment to a different transaction amount later in time. If this would be possible, an attacker could spend more coins than previously committed to in an UTXO (unspent transaction output) and therefore inflate coins out of thin air. Even worse, as the amounts are hidden, this could go undetected.</p> <p>So there is a valid interest in having both of these properties always secured and never be violated.</p> <p>Even with the intent being that both of these properties will hold for the lifetime of a cryptocurrency, still a choice has to be made about which commitment scheme to use.</p>"},{"location":"wiki/miscellaneous/switch-commitments/#a-hard-choice","title":"A hard choice?","text":"<p>Which one of these two properties needs to be perfectly safe and for which one it would be sufficient to be computationally safe? Or in other words: in case of a disaster, if the commitment scheme unexpectedly gets broken, which one of the two properties should be valued higher? Economical soundness (no hidden inflation possible) or ensured privacy (privacy will be preserved)?</p> <p>This seems like a hard to choice to make.</p> <p>If we look closer into this we realize that the commitment scheme only needs to be perfectly binding at the point in time when the scheme actually gets broken. Until then it will be safe even if it's only computationally binding.</p> <p>At the same time a privacy-oriented cryptocurrency needs to ensure the hidingness property forever. Unlike the binding property, which only is important at the time when a transaction is created and will not affect past transactions, the hidingness property must be ensured at all times. Otherwise, in the unfortunate case should the commitment scheme be broken, an attacker could go back in the chain and unblind past transactions, thus break the privacy property retroactively.</p>"},{"location":"wiki/miscellaneous/switch-commitments/#properties-of-pedersen-commitments","title":"Properties of Pedersen Commitments","text":"<p>Pedersen Commitments are computationally binding and perfectly hiding as for a given commitment to the value <code>v</code>: <code>v*H + r*G</code> there may exist a pair of different values <code>r1</code> and <code>v1</code> such that the sum will be the same. Even if you have infinite computing power and could try all possible values, you would not be able to tell which one is the original one (thus perfectly hiding).</p>"},{"location":"wiki/miscellaneous/switch-commitments/#introducing-switch-commitments","title":"Introducing Switch Commitments","text":"<p>So what can be done if the bindingness of the Pedersen Commitment unexpectedly gets broken?</p> <p>In general a cryptocurrency confronted with a broken commitment scheme could choose to change the scheme in use, but the problem with this approach would be that it requires to create new transaction outputs using the new scheme to make funds secure again. This would require every coin holder to move his coins into new transaction outputs. If coins are not moved into new outputs, they will not profit from the security of the new commitment scheme. Also, this has to happen before the scheme gets actually broken in the wild, otherwise the existing UTXOs no longer can be assumed to contain correct values.</p> <p>In this situation Switch Commitments offer a neat solution. These type of commitments allow changing the properties of the commitments just by changing the revealing / validating procedure without changing the way commitments are created. (You \"switch\" to a new validation scheme which is backwards compatible with commitments created long before the actual \"switch\").</p>"},{"location":"wiki/miscellaneous/switch-commitments/#how-does-this-work-in-detail","title":"How does this work in detail","text":"<p>First let's introduce a new commitment scheme: The ElGamal commitment scheme is a commitment scheme similiar to Pedersen Commitments and it's perfectly binding (but only computationally hiding as we can never have both). It looks very similar to a Pedersen Commitment, with the addition of a new element, calculated by multiplying the blinding factor <code>r</code> with another generator point <code>J</code>:</p> <pre><code>v*H + r*G ,  r*J\n</code></pre> <p>So if we store the additional field <code>r*J</code> and ignore it for now, we can treat it like Pedersen Commitments, until we decide to also validate the full ElGamal commitment at some time in future. This is exactly what was implemented in an earlier version of Grin, before mainnet was launched. In detail: the hashed value of <code>r*J</code> (switch_commit_hash) was added to the transaction output, but this came with the burden of increasing the size of each output by 32 bytes.</p> <p>Fortunately, later on the Mimblewimble mailinglist Tim Ruffing came up with a really beautiful idea (initially suggested by Pieter Wuille), which offers the same advantages but doesn't need this extra storage of an additional element per transaction output:</p> <p>The idea is the following:</p> <p>A normal Pedersen commitment looks like this:</p> <pre><code>v*H + r*G\n</code></pre> <p>(<code>v</code> is value of the input/output, <code>r</code> is a truly random blinding factor, and <code>H</code> and <code>G</code> are two generator points on the elliptic curve).</p> <p>If we adapt this by having <code>r</code> not being random itself, but using another random number <code>r'</code> and create the Pedersen Commitment:</p> <pre><code>v*H + r*G\n</code></pre> <p>such that:</p> <pre><code>r = r' + hash( v*H + r'*G  ,  r'*J )\n</code></pre> <p>(using the additional third generation point <code>J</code> on the curve) then <code>r</code> still is perfectly valid as a blinding factor, as it's still randomly distributed, but now we see that the part within the brackets of the hash function (<code>v*H + r'*G  ,  r'*J</code>) is an ElGamal commitment.</p> <p>This neat idea lead to the removal of the switch commitment hash from the outputs in this (and following) pull requests as now it could be easily included into the Pedersen Commitments.</p> <p>This is how it is currently implemented in Grin. Pedersen commitments are used for the Confidential Transaction but instead of choosing the blinding factor <code>r</code> only by random, it is calculated by adding the hash of an ElGamal commitment to a random <code>r'</code> (see here in main_impl.h#L267).</p> <p>In general switch commitments were first described in the paper \"Switch Commitments: A Safety Switch for Confidential Transactions\"). The \"switch\" in the name comes from the fact that you can virtually flip a \"switch\" in the future and simply by changing the validation procedure you can change the strength of the bindingness and hidingness property of your commitments and this even works in a backwards compatible way with commitments created today.</p>"},{"location":"wiki/miscellaneous/switch-commitments/#conclusion","title":"Conclusion","text":"<p>Grin uses Pedersen Commitments - like other privacy cryptocurrencies do as well - with the only difference that the random blinding factor <code>r</code> is created using the ElGamal commitment scheme.</p> <p>This might not seem like a big change on a first look, but it provides an important safety measure:</p> <p>Pedersen Commitments are already perfectly hiding so whatever happens, privacy will never be at risk without requiring any action from users. But in case of a disaster if the bindingness of the commitment scheme gets broken, then switch commitments can be enabled (via a soft fork) requiring that all new transactions prove that their commitment is not breaking the bindingness by validating the full ElGamal commitment.</p> <p>But in this case users would still have a choice:</p> <ul> <li> <p>they can decide to continue to create new transactions, even if this might compromise   their privacy (only on their last UTXOs) as the ElGamal commitment scheme is   only computationally hiding, but at least they would still have access to their coins</p> </li> <li> <p>or users can decide to just leave the money alone, walk away and make no more transactions   (but preserve their privacy, as their old transactions only validated the Pedersen commitment   which is perfectly hiding)</p> </li> </ul> <p>There are many cases where a privacy leak is much more dangerous to one's life than some cryptocurrency might be worth. But this is a decision that should be left up to the individual user and switch commitments enable this type of choice.</p> <p>It should be made clear that this is a safety measure meant to be enabled in case of a disaster. If advances in computing would put the hardness of the discrete log problem in question, a lot of other cryptographic systems, including other cryptocurrencies, will be in urgent need of updating their primitives to a future-proof system. The switch commitments just provide an additional layer of security if the bindingness of Pedersen commitments ever breaks unexpectedly.</p>"},{"location":"wiki/security-process/code-audits/","title":"Code Audits","text":"<p>Continued code reviews and audits are important for the security of Grin. As such, we highly encourage interested security researchers to:</p> <ul> <li>Review our code, even if no contributions are planned.</li> <li>Publish their findings in accordance with our responsible disclosure standard, even if no particular bug or vulnerability was found. We can all learn from new sets of eyes and benefit from increased scrutiny. While we may disagree with some small points of design or trade-offs, we will always do so respectfully.</li> </ul> <p>All code review and audit contributions are welcome regardless of depth, area or background of the contributor. Many contributions from many different perspectives can help ensure long term security for the Grin codebase.</p> <p>A complete list of PGP keys, canaries, CVEs and audits can be found in the grin-security repository.</p>"},{"location":"wiki/security-process/code-audits/#past-audits","title":"Past Audits","text":"Audit Results JP Aumasson, secp256k1 extensions report - status Coinspect, code audit v1.0.1 report - status Nym Seddon, code audit v4.0.0 report - status"},{"location":"wiki/security-process/grin-security-process/","title":"Grin's Security Process","text":"<p>Grin has a code of conduct and the handling of vulnerability disclosure is no exception. We are committed to conduct our security process in a professional and civil manner. Public shaming, under-reporting or misrepresentation of vulnerabilities will not be tolerated.</p>"},{"location":"wiki/security-process/grin-security-process/#responsible-disclosure-standard","title":"Responsible Disclosure Standard","text":"<p>Grin follows a community standard for responsible disclosure in cryptocurrency and related software. This document is a public commitment to following the standard.</p> <p>This standard provides detailed information for:</p> <ul> <li>Initial Contact: how the initial contact process works</li> <li>Giving Details: what details to include with your disclosure after receiving a response to your initial contact</li> <li>Setting Dates: details for when to release updates and publicize details of the issue</li> </ul> <p>Any expected deviations and necessary clarifications around the standard are explained in the following sections.</p>"},{"location":"wiki/security-process/grin-security-process/#receiving-disclosures","title":"Receiving Disclosures","text":"<p>We are committed to working with researchers who submit security vulnerability notifications to us, to resolve those issues on an appropriate timeline and perform a coordinated release, giving credit to the reporter if they would like.</p> <p>Please submit issues to all of the following main points of contact for security related issues according to the initial contact and details guidelines. More information is available about the expected timelines for the full disclosure cycle.</p> <p>For all security related issues, there are 3 main points of contact:</p> <ul> <li>Daniel Lehnberg, daniel.lehnberg at protonmail.com PGP key</li> <li>John Woeltz, joltz at protonmail.com PGP key</li> </ul> <p>Send all communications PGP encrypted to all parties.</p>"},{"location":"wiki/security-process/grin-security-process/#sending-disclosures","title":"Sending Disclosures","text":"<p>In the case where we become aware of security issues affecting other projects that has never affected Grin, our intention is to inform those projects of security issues on a best effort basis.</p> <p>In the case where we fix a security issue in Grin that also affects the following neighboring projects, our intention is to engage in responsible disclosures with them as described in the adopted standard, subject to the deviations described in the deviations section of this document.</p>"},{"location":"wiki/security-process/grin-security-process/#bilateral-responsible-disclosure-agreements","title":"Bilateral Responsible Disclosure Agreements","text":"<p>Grin does not currently have any established bilateral disclosure agreements.</p>"},{"location":"wiki/security-process/grin-security-process/#recognition-and-bug-bounties","title":"Recognition and Bug Bounties","text":"<p>Grin's responsible disclosure standard includes some general language about Bounty Payments and Acknowledgements.</p> <p>Grin is a traditional open source project with limited to no direct funding. As such, we have little means with which to compensate security researchers for their contributions. We recognize this is a shame and intend to do our best to still make these worth while by:</p> <ul> <li>Advertising the vulnerability, the researchers, or their team on a public page linked from our website, with a links of their choosing.</li> <li>Acting as reference whenever this is needed.</li> <li>Setting up retroactive bounties whenever possible.</li> </ul> <p>There is not currently a formal bug bounty program for Grin as it would require a high level of resources and engagement to operate in good faith. More funding can help provide the necessary resources to run one in the future for the Grin community.</p>"},{"location":"wiki/security-process/grin-security-process/#deviations-from-the-standard","title":"Deviations from the Standard","text":"<p>Grin is a technology that provides strong privacy with zero-knowledge commitments and rangeproofs. Due to the nature of the cryptography used, if a counterfeiting bug results it could be exploited without a way to identify which data was corrupted. This renders rollbacks or other fork-based attempted fixes ineffective.</p> <p>The standard describes reporters of vulnerabilities including full details of an issue, in order to reproduce it. This is necessary for instance in the case of an external researcher both demonstrating and proving that there really is a security issue, and that security issue really has the impact that they say it has - allowing the development team to accurately prioritize and resolve the issue.</p> <p>In the case of a counterfeiting or privacy-breaking bug, however, we might decide not to include those details with our reports to partners ahead of coordinated release, so long as we are sure that they are vulnerable.</p>"},{"location":"wiki/security-process/grin-security-process/#more-information","title":"More Information","text":"<p>Additional security-related information about the Grin project including previous audits, CVEs, canaries, signatures and PGP public keys can be found in the grin-security repository.</p>"},{"location":"wiki/security-process/security-team/","title":"Security Team","text":"<ul> <li>Title: <code>security-team</code></li> <li>Authors: joltz</li> <li>Start date: Jan 22 2020</li> <li>RFC PR: mimblewimble/grin-rfcs#39</li> <li>Tracking issue: mimblewimble/grin-pm/#258</li> </ul>"},{"location":"wiki/security-process/security-team/#summary","title":"Summary","text":"<p>The security team for Grin carries out the security priorities of the Grin community and core team, which are to be defined prior to formation of the team. The security team streamlines the security decision making process for the core team while maintaining a careful balance of security and transparency for the community.</p>"},{"location":"wiki/security-process/security-team/#motivation","title":"Motivation","text":"<ul> <li>Improve transparency, efficiency, decisiveness and scalability around security-related decision making</li> <li>Dedicated support for security-related initiatives such as bilateral disclosure agreements, bug bounty programs and audit work</li> <li>Increase confidence in the ecosystem for future contributions</li> </ul> <p>A clear and structured decision making process is needed to fully support the current security process as well as community initiatives such as bilateral disclosure agreements, bug bounty programs and future audit work. This process was previously maintained by the core team who had many areas of focus, leading to a lack of clarity, timeliness and ability to decisively execute on community security initiatives.</p> <p>The security team frees up core resources to focus on other important areas while expanding dedicated resources to security work, allowing the Grin ecosystem to continue to scale. A clear decision making structure around the security process instills confidence in the greater ecosystem and encourages projects, developers and users to continue to increase contributions of time and resources into Grin.</p>"},{"location":"wiki/security-process/security-team/#community-level-explanation","title":"Community-level explanation","text":"<p>Grin's security team is responsible for making predefined security related decisions for the Grin project. This includes, but is not limited to, decisions about the specification and implementation of Grin's security processes. As much as possible Grin's security team carries out the security priorities of the community and core team in a transparent manner.</p> <p>There may be some unique security-related cases that require the security team to make some decisions in private to protect the security of Grin users. In these cases, once it is safe to do so, the security team is responsible for sharing as many details as possible with the community for transparency and accountability purposes.</p> <p>The primary day-to-day impact this will have on the community is making available structured support around security-related initiatives such as bilateral disclosure agreements, bug bounty programs and audit work. The community and other teams will have regular opportunity to interact with, provide input to and receive input from the security team.</p>"},{"location":"wiki/security-process/security-team/#example","title":"Example","text":"<p>Here we will walk through an example case that highlights how Grin's security team would operate, contrasting with the current process.</p> <p>In the example case, a vulnerability is disclosed to the disclosure contacts listed in Grin's security policy. It is shown that the community gains greater transparency into the decision making process and related outcomes with the proposed security team. Additionally the disclosure map is more tightly contained in the proposed process, resulting in less risk of vulnerability exploitation to the community.</p> <p>Previous Process</p> <ul> <li>Grin's security contacts make initial assessment of the validity of the vulnerability disclosure</li> <li>If disclosure determined to be valid, all details of the disclosure are shared with the entire core team</li> <li>With a conversation between the entire core team, a plan of action is determined and executed, following Grin's responsible disclosure policy</li> <li>Once the vulnerability is mitigated the core team may optionally share some of the details with the community</li> </ul> <p>Security Team Process</p> <ul> <li>Grin's security contacts, all members of the security team, make initial assessment of the validity of the vulnerability disclosure</li> <li>If disclosure determined to be valid, a conversation and plan of action is determined and executed by the security team, following Grin's responsible disclosure policy</li> <li>Once the vulnerability is mitigated the security team must disclose all information that is not still security-critical with the community</li> </ul>"},{"location":"wiki/security-process/security-team/#reference-level-explanation","title":"Reference-level explanation","text":"<p>s</p> <p>Grin's security team will be implemented as stated below.</p>"},{"location":"wiki/security-process/security-team/#membership","title":"Membership","text":"<ul> <li>Bootstrapped by existing security contacts (@lehnberg, @hashmap, @joltz)</li> <li>Minimum three, maximum five members</li> <li>Membership is recommended by the security team and approved by the core team</li> <li>All members must have relevant domain expertise in security, cryptography, the Grin codebase or Grin community</li> <li>All members must have high competency in maintaining personal operational security (keeping private keys secure, maintaining secure communications channels etc.)</li> <li>Membership is revoked by failure to update the canary, unanimous decision by team or decision from the core team</li> <li>Note if the core team engages in removing members from the security team without reasonable justification, the security team loses purpose, becomes ineffective and is relegated to useless security theater</li> </ul>"},{"location":"wiki/security-process/security-team/#decision-making","title":"Decision Making","text":"<ul> <li>Distinction between security-team decisions and security-related decisions:</li> <li>The security team is responsible for making predefined security-team decisions, not all possible ambiguous security-related decisions</li> <li>Decisions are made primarily with consideration to the security priorities outlined prior to the team's formation</li> <li>Unanimous approval of security team members is needed to make all impactful decisions</li> <li>Some decisions made must also be approved by the core team to be carried out:</li> <li>Adding/removing parties from disclosure agreements</li> <li>Adding members to the security team</li> <li>Updating the security policy</li> <li>In the event that the core team does not follow a security team recommendation, a reasonable explanation must be provided as to why the security recommendation was not followed</li> <li>Some decisions must be made without fully informing the core team of all details:</li> <li>When fixing a vulnerability requires a deviation from the standard<ul> <li>In these cases not all information will be shared with core team, such as specific details to carry out an exploit, full impact and other relevant information that will create unnecessary risk if disclosed</li> </ul> </li> <li>The core team must be notified of all cases of these decisions within a reasonable time frame that does not pose a security risk (e.g. after a fix is implemented) and provided with a reasonable explanation by the security team</li> </ul>"},{"location":"wiki/security-process/security-team/#vetoes","title":"Vetoes","text":"<ul> <li>Any member of the security team may veto an impactful security team decision</li> </ul> <p>The ability to veto an impactful security team decision is important to preserve the ability for members of the security team to make honest recommendations. Important and controversial decisions will be made and members of the security team need the ability to not sign their names to a decision they are not comfortable with that could have serious ramifications. These cases will be handled according to the Deadlocks section below.</p> <p>The security team should always strive to reach its own decisions. Constant vetoes and inability to reach unanimous decisions will dampen the advantages of the existence of the team and may render it obsolete. It is important to strike the right balance of different perspectives, expertise and reasonability in members to take advantage of the benefits that come with a diverse and functional security-related decision making process.</p>"},{"location":"wiki/security-process/security-team/#deadlocks","title":"Deadlocks","text":"<ul> <li>Impactful security team decisions that can't be made unanimously by the security team will be made by the core team according to their decision making process</li> <li>If the core team is deadlocked, the decision made will be whichever decision, if any, will provide the end user with the greatest measure of security</li> </ul> <p>Deadlocks should be avoided at all costs. The inability of the security team to reach a unanimous decision based on the security priorities of Grin's community and core team should be a red flag to the community and core team for the health of the team. All members should be able to clearly discuss the factual merits of the options and reach a decision that is in the clear best possible interest for the security of Grin's ecosystem and users.</p>"},{"location":"wiki/security-process/security-team/#example_1","title":"Example","text":"<p>By following the previous example in more detail, critical differences can be further explored between the current process and the proposed security team process in the handling of a unique case.</p> <p>In cases where fixing a vulnerability is so critical that it requires a deviation from the standard, the proposed process reduces the likelihood of the vulnerability being exploited with a focused decision making process and by restricting the details to essential persons only.</p> <p>Previous Process</p> <ul> <li>Grin's security contacts make initial assessment of the validity of the vulnerability disclosure</li> <li>It is determined that the disclosed vulnerability is a critical inflation bug</li> <li>All details of the disclosure, including the steps to carry out the exploit, are shared with the entire core team</li> <li>With a conversation between the entire core team, a plan of action is determined and executed, following Grin's responsible disclosure policy</li> <li>This conversation may take days or weeks as there is no particular decision making process for security-related issues</li> <li>Once the vulnerability is mitigated the core team may optionally share some of the details with the community</li> </ul> <p>Security Team Process</p> <ul> <li>Grin's security contacts, all members of the security team, make initial assessment of the validity of the vulnerability disclosure</li> <li>It is determined that the disclosed vulnerability is a critical inflation bug</li> <li>A conversation and plan of action is quickly and unanimously determined and executed on by the security team, following Grin's responsible disclosure policy</li> <li>Once the vulnerability is mitigated, the security team must disclose all information that is not still security-critical with the community</li> </ul>"},{"location":"wiki/security-process/security-team/#drawbacks","title":"Drawbacks","text":"<ul> <li>The core team is already busy and the formation and management of a security team may distract from other pressing and immediate issues</li> <li>Even though it decentralizes the core team, it potentially creates another point of centralization</li> <li>Adds resource overhead to the project that must be upheld (it is not acceptable to fail to follow through in security processes once established!)</li> <li>Possibly distracts from other important work- we don't want to spread attention too wide too early</li> <li>Adds bulk to Grin's governance structure</li> <li>The community may trust core more than a team to make critical security decisions</li> </ul>"},{"location":"wiki/security-process/security-team/#rationale-and-alternatives","title":"Rationale and alternatives","text":"<ul> <li>One alternative, currently in use, is adding the input of a security expert to the existing core decision making process</li> <li>This is better than nothing but we lose a few benefits without a dedicated security team:<ul> <li>Strengthened security process: reduced likelihood of exploit leaks</li> <li>Improved transparency: there is currently little transparency around core's security decision making process</li> <li>Improved reaction times: informed, thoughtful, decisive actions with input from relevant experts only</li> <li>Possibility for security initiatives: clear decision making process for bilateral disclosure agreements, bug bounty programs, audit work</li> <li>Stronger commitments to the community, ecosystem and other projects: viable with a dedicated, clear decision making process</li> <li>Long-term scalability: extend capacity for security work to grow beyond the core team's attention capacity</li> </ul> </li> <li>Another alternative is to rely on an open community to handle all incidents as they come in</li> <li>This is less desirable than both the previous process and security team process:<ul> <li>Vulnerabilities would essentially be public before they can by mitigated</li> <li>There is no decision making team so mitigation actions may be slow and contentious</li> <li>There is no accountability to ensure that the responsible disclosure process is followed</li> <li>This model is much more transparent than other alternatives but comes with the unacceptable associated costs above</li> </ul> </li> </ul>"},{"location":"wiki/security-process/security-team/#prior-art","title":"Prior art","text":"<p>grin-governance<sup>1</sup> and security-process<sup>2</sup> RFCs lay groundwork for the security-team RFC.</p>"},{"location":"wiki/security-process/security-team/#unresolved-questions","title":"Unresolved questions","text":"<ul> <li>What are the security priorities of the Grin community and core team? (e.g. is privacy a higher priority than undetectable inflation?)</li> <li>Is this the most minimal model that can have long-term success for Grin's security-related decision making process?</li> <li>Is the single-veto model sufficient for a consistent, timely decision making process?</li> </ul>"},{"location":"wiki/security-process/security-team/#future-possibilities","title":"Future possibilities","text":"<ul> <li>Budget allocation and management</li> <li> <p>Manage an allocated budget for possible initiatives</p> <ul> <li>Bug bounty programs</li> <li>Audits</li> <li>Full time contributors</li> <li>Development of security tooling</li> </ul> </li> <li> <p>Security team working groups</p> </li> <li>Red team</li> <li>Blue team</li> <li>Audit team</li> <li>Bug bounty team</li> <li> <p>Community outreach team</p> </li> <li> <p>Expanding security-team decisions</p> </li> <li>Currently security-team decisions are restricted to predefined decisions around the security processes</li> <li>In the future security-team decisions can be expanded to include more security-related decisions</li> </ul>"},{"location":"wiki/security-process/security-team/#references","title":"References","text":"<ol> <li> <p>Grin's Governance RFC \u21a9</p> </li> <li> <p>Grin's Security Process RFC \u21a9</p> </li> </ol>"},{"location":"wiki/services/list-of-services/","title":"List of Grin Services","text":""},{"location":"wiki/services/list-of-services/#exchanges","title":"Exchanges","text":""},{"location":"wiki/services/list-of-services/#active-trading-and-withdrawdeposit","title":"Active trading and withdraw/deposit","text":"<ul> <li>TradeOgre</li> <li>Gate.io</li> <li>BisQ (DEX)</li> </ul>"},{"location":"wiki/services/list-of-services/#block-explorers","title":"Block Explorers","text":"<ul> <li>Grincoin</li> <li>Grincoin Testnet</li> <li>Grinminer</li> <li>Grinminer Testnet</li> <li>Grinexplorer</li> </ul>"},{"location":"wiki/services/list-of-services/#mining-pools","title":"Mining Pools","text":"<ul> <li>GrinMint</li> <li>2Miners</li> <li>2Miners SOLO</li> <li>Alwaysvip</li> <li>GaeaPool</li> <li>2miners SOLO</li> <li>Easygrin </li> <li>Easygrin SOLO </li> </ul>"},{"location":"wiki/services/slatepack-integration/","title":"Slatepack Integration Guide","text":"<p>Slatepack is a new transaction building standard for Grin designed to improve and simplify the transacting experience for all users. The full specification is available here</p> <p>Slatepack was introduced in v4.0.0. Wallets and services must fully support it by v5.0.0 (Jan 2021).</p>"},{"location":"wiki/services/slatepack-integration/#motivation","title":"Motivation","text":"<p>Previously, users and exchanges had to decide between multiple transaction methods to find one that works for them. Transactions were commonly done through HTTPS, requiring users to open ports and configure firewalls, or with slate files which bring their own set of challenges. With Slatepack, a single standard needs to be supported.</p>"},{"location":"wiki/services/slatepack-integration/#summary","title":"Summary","text":"<p>The Slatepack standard eliminates the need for HTTPS or exchanging files. Instead, it introduces two methods:</p> <ol> <li>Synchronous communication done through Tor (transaction is completed automatically similar to HTTPS).</li> <li>Asynchronous communication using Slatepack Messages, which are encoded transaction strings exchanged by a simple copy-paste.</li> </ol> <p>Additionally, Slatepack Addresses are introduced to facilitate the interaction between two wallets.</p> <p>No more endless support tickets</p> <p>Notice how the transactions can be completed without requiring additional help from exchange support staff; When needed, wallets resort to exchanging simple string messages to complete the interaction. This should drastically reduce time spent on support tickets related to troubles around transacting with Grin.</p>"},{"location":"wiki/services/slatepack-integration/#overview","title":"Overview","text":""},{"location":"wiki/services/slatepack-integration/#slatepack-address","title":"Slatepack Address","text":"<p>A Slatepack address is a bech32 encoded address, similar to those used in Bitcoin. However, Slatepack addresses do not touch the network; they are used strictly for transaction building between two wallets, and never appear on-chain or represent ownership.</p> <p>Addresses are exchanged between parties to serve as instructions for how to complete the payment. Therefore, a Slatepack address serves a double purpose:</p> <ul> <li>It decodes to a Tor address.</li> <li>Acts as a key to encrypt the transaction data being communicated by Slatepack Messages (strings).</li> </ul> <p>example address <pre><code>grin1dhvv9mvarqwl6fderuxp3qgl6qppvhc9p4u24347ec0mvgg6342q4w6x56\n</code></pre></p> <p>Since Slatepack addresses are bech32, they can easily be QR encoded.</p>"},{"location":"wiki/services/slatepack-integration/#tor-synchronous-tx-completion","title":"Tor (Synchronous Tx Completion)","text":"<p>Any Slatepack address is decoded by the wallet as a Tor address, where the wallet will be listening. Therefore, if both the exchange's and the user's wallets are online and connected to Tor, payments will complete automatically (the receiver's wallet needs to listen).</p> <p>However, if a Tor connection between the two wallets can't be established (fails for any reason), or when a Slatepack address is not provided, the wallet will resort to exchanging Slatepack Messages for completing a transaction.</p>"},{"location":"wiki/services/slatepack-integration/#slatepack-messages-asynchronous-tx-completion","title":"Slatepack Messages (Asynchronous Tx Completion)","text":"<p>The Slatepack standard automatically handles a failed Tor connection by outputting a Slatepack Message, which is an encoded transaction string to be exchanged manually by copy-paste.</p> <p></p> <p>Given that the sender provides a destination address (always recommended even if Tor isn't desired), then the Slatepack Messages will be encrypted.</p>"},{"location":"wiki/services/slatepack-integration/#transaction-flow","title":"Transaction Flow","text":"<p>As an example, let's demonstrate the workflow of an exchange.</p> <p>(switch between tabs)</p> Withdrawal Step Exchange User 1 Provide Slatepack Address 2 Send to Slatepack Address (send) 3 IF TOR FAILS: Copy message[1] 4 Paste message[1] 5 Copy message[2] 6 Paste message[2] (finalize) Withdrawal UI <p></p> Deposit Step Exchange User 1 Provide Slatepack Address (address) 2 Send to Slatepack Address 3 IF TOR FAILS: Copy message[1] 4 Paste message[1] (receive) 5 Copy message[2] 6 Paste message[2] Deposit UI <p></p>"},{"location":"wiki/services/slatepack-integration/#exchange-integration","title":"Exchange Integration","text":"<p>Exchanges may consider several different paths for integration:</p> <ul> <li>Exchanges may run Tor hidden services to automatically complete transactions, and also provide a user-interface for copy-pasting Slatepack Messages as a fallback mechanism.</li> <li>Some exchanges may not wish to have Tor running anywhere in their infrastructure. In this case, they may provide only the user-interface required for exchanging Slatepack Messages via copy and paste text boxes.</li> <li>Exchanges may provide unique Tor end points to serve as unique deposit addresses for each user.</li> </ul>"},{"location":"wiki/services/slatepack-integration/#payment-proofs","title":"Payment proofs","text":"<p>Grin's lack of on-chain addresses slightly complicates proving a transaction occurred. In order to solve disputes and prove funds were sent to the correct wallet, separate payment proofs are used.</p> <p>By default, whenever a transaction is sent to a destination Slatepack Address, a payment proof is created automatically.</p> <p>The sender (wallet who finalized tx) can export the payment proof by specifying the tx-id (<code>-i</code>) or tx-log-id (<code>-t</code>) of a transaction, and choosing the path for the proof file, e.g:</p> <pre><code>grin-wallet export_proof -i 4 \"~/Documents/proof.txt\"\n</code></pre> <p>He can then provide this proof to any wallet for verification. To verify:</p> <pre><code>grin-wallet verify_proof /path/proof.txt\n</code></pre> <p>This will ensure that:</p> <ul> <li>The kernel for the transaction in the proof is validated and can be found on-chain.</li> <li>Both the sender and recipient's signatures correctly sign for the amount and the kernel.</li> </ul> <p>Additionally, if the recipient of the transaction is the same wallet trying to verify it, then they will be informed as follows:</p> <pre><code>grin-wallet verify_proof proof.txt\n\nPayment proof's signatures are valid.\nThe proof's recipient address belongs to this wallet.\n</code></pre>"},{"location":"wiki/services/slatepack-integration/#questions-support","title":"Questions &amp; Support","text":"<p>For questions about the Slatepack standard or its implementation, send a message in @grincoin#support on Keybase.</p>"},{"location":"wiki/services/slatepack-integration/#technical-details","title":"Technical Details","text":"Technical Specification <p>See the full specification for complete technical details.</p>"},{"location":"wiki/services/slatepack-integration/#address","title":"Address","text":"<p>A <code>SlatepackAddress</code> is a bech32 encoded ed25519 public key which maps to:</p> <ul> <li>A Tor onion address <code>bech32 -&gt; ed25519 -&gt; onionv3</code></li> <li>A derivable x25519 public key for optional encryption <code>bech32 -&gt; ed25519 -&gt; x25519</code></li> </ul> <p>Keys used in <code>SlatepackAddresses</code> are derived from a path from the master seed in a given wallet account. Currently the wallet uses separate derivation paths: one for the private bytes used for the blinding factor keys and one for the private bytes used to derive the ed25519 keys.</p> <p>Unique addresses (not yet supported)</p> <p><code>SlatepackAddress</code> keys may be derived in parallel to the blinding factor derivation path, such that a unique address is derived for each new transaction.</p>"},{"location":"wiki/services/slatepack-integration/#message-formatting","title":"Message Formatting","text":"<p><code>WORD_LENGTH</code>: <code>15</code> characters</p> <ul> <li>Number of <code>SimpleBase58Check</code> encoded characters per word; chosen for human readability across device screen sizes</li> </ul> <p><code>LINE_BREAK</code>: <code>200</code> words</p> <ul> <li>Number of words of <code>WORD_LENGTH</code> to include before inserting a newline; chosen for user friendliness in terminals and messaging applications</li> </ul> <p><code>MAX_STRING_SIZE</code>: <code>1MB</code></p> <ul> <li>Maximum size for an armored <code>SlatepackMessage</code> string without requiring a file container</li> <li>If a <code>SlatepackMessage</code> exceeds this value it must be handled as a <code>.slatepack</code> file instead of a string</li> <li>This parameter chosen to cover as many cases as possible and still be supported by most clipboards</li> </ul> <p>Note that <code>WORD_LENGTH</code> and <code>LINE_BREAK</code> parameters are adjustable as a formatting convenience.</p> <p>Services and exchanges would be reasonable to support the Slatepack standard, without handling the rare file edge case (string &gt;1MB).</p> <p>The <code>SlatepackWorkflow</code> establishes the steps followed to adhere to the standard:</p> <ol> <li> <p>Try to establish connection via Tor</p> <ul> <li>Derive onion address from ED25519 public key decoded from the bech32 <code>SlatepackAddress</code></li> <li>Attempt to complete the transaction via Tor and json-rpc as per the previous implementations</li> <li>If connection fails, proceed to step 2</li> </ul> </li> <li> <p>Fall back to copy/paste (optionally encrypted) ascii-armored transaction strings known as <code>SlatepackMessage</code></p> <ul> <li>If using encryption, derive encryption key: <code>SlatepackAddress</code> -&gt; <code>ed25519 public key</code> -&gt; <code>x25519 public key</code></li> <li>Build ascii-armored string according to standard including <code>SimpleBase58Check</code>, appropriate binary encoding and framing</li> </ul> </li> <li> <p>A <code>SlatepackMessage</code> is a transaction string formatted for manual copy/paste transport. It contains the required components to build a transaction manually, similar to the transaction files previously supported but compacted for transport.</p> <ul> <li> <p>Example:</p> <pre><code>BEGINSLATEPACK. 4H1qx1wHe668tFW yC2gfL8PPd8kSgv\npcXQhyRkHbyKHZg GN75o7uWoT3dkib R2tj1fFGN2FoRLY\nGWmtgsneoXf7N4D uVWuyZSamPhfF1u AHRaYWvhF7jQvKx\nwNJAc7qmVm9JVcm NJLEw4k5BU7jY6S eb. ENDSLATEPACK.\n</code></pre> </li> </ul> </li> </ol>"},{"location":"wiki/transactions/contracts/","title":"Contracts","text":"<p>Read this in other languages: \u7b80\u4f53\u4e2d\u6587</p> <p>This document describes smart contracts that can be setup using Grin even though its simplicity does not allow scripting. All of these types of contracts rely on a few basic Mimblewimble features, and compose them in increasingly clever ways.</p> <p>None of those constructs are fully original or invented by the authors of this document or the Grin developers. Most of the credit should be attributed to a long list of cryptographers and researchers. To name just a few: Torben Pryds Pedersen, Gregory Maxwell, Andrew Poelstra, John Tromp, Claus Peter Schnorr. We apologize in advance for all those we couldn't name and recognize that most computer science discoveries are incremental.</p>"},{"location":"wiki/transactions/contracts/#built-ins","title":"Built-ins","text":"<p>This section is meant as a reminder of some crucial features of the Grin chain. We assume some prior knowledge as to how these are constructed and used.</p>"},{"location":"wiki/transactions/contracts/#pedersen-commitments","title":"Pedersen Commitments","text":"<p>All outputs include a Pedersen commitment of the form <code>r*G + v*H</code> with <code>r</code> the blinding factor, <code>v</code> the value, and G and H two distinct generator points on the same curve group.</p>"},{"location":"wiki/transactions/contracts/#schnorr-signatures","title":"Schnorr Signatures","text":"<p>We suppose we have the SHA256 hash function and the same G curve as above. In its simplest form, a Schnorr signature is built from:</p> <ul> <li>the message <code>M</code> to sign, in our case the transaction fee</li> <li>a private key <code>x</code>, with its matching public key <code>x*G</code></li> <li>a nonce <code>k</code> just used for the purpose of building the signature</li> </ul> <p>We build the challenge <code>e = SHA256(M | k*G | x*G)</code>, and the scalar <code>s = k + e * x</code>. The full aggregate signature is then the pair <code>(s, k*G)</code>.</p> <p>The signature can be checked using the public key <code>x*G</code>, re-calculating <code>e</code> using M and <code>k*G</code> from the 2nd part of the signature pair and by verifying that <code>s</code>, the first part of the signature pair, satisfies:</p> <pre><code>s*G = k*G + e * x*G\n</code></pre> <p>In this simple case of someone sending a transaction to a receiver they trust (see later for the trustless case), a signature can be directly built for a Grin transaction by taking the above private key <code>x</code> to be the sum of output blinding factors minus the sum of input blinding factors. The resulting kernel is assembled from the aggregate signature generated using <code>r</code> and the public key <code>r*G</code>, and allows to verify non-inflation for all Grin transactions (and signs the fees). In the case of a multi-signature, a more complex protocol called MuSig is used for generating a Schnorr signature.</p> <p>Because these signatures are built simply from a scalar and a public key, they can be used to construct a variety of contracts using \"simple\" arithmetic.</p>"},{"location":"wiki/transactions/contracts/#timelocked-transactions","title":"Timelocked Transactions","text":""},{"location":"wiki/transactions/contracts/#absolute-timelocked","title":"Absolute Timelocked","text":"<p>Analogous to Bitcoin's nLockTime.</p> <p>A transaction can be time-locked with a few simple modifications.</p> <p>The message <code>M</code> to sign becomes the lock_height <code>h</code> at which the transaction becomes spendable, appended to the fee, such that <code>M = fee | h</code>.</p> <p>The lock height <code>h</code> is then included in the transaction kernel. If a block contains a kernel that includes a lock height greater than the current block height, it is rejected.</p>"},{"location":"wiki/transactions/contracts/#relative-timelocked","title":"Relative Timelocked","text":"<p>We can extend the concept of an absolute locktime on a tx by including a (kernel) commitment that we can define the lock_height relative to.</p> <p>The lock_height would be relative to the block height where the referenced kernel was first included in the chain state.</p> <p>Tx2 can then be restricted such that it would only be valid to include it in a block once <code>h</code> blocks have passed after first seeing Tx1 (via the referenced kernel commitment).</p> <p>The message <code>M</code> to sign would need to include the following:</p> <ul> <li>The <code>fee</code> as before</li> <li>The lock_height <code>h</code> (as before but interpreted as a relative value)</li> <li>A referenced kernel commitment <code>C</code></li> <li>M = <code>fee | h | C</code></li> </ul> <p>For Tx2 to be accepted it would also need to include a Merkle proof identifying the block including <code>C</code> from Tx1. This proves the relative lock_height requirement has been met.</p>"},{"location":"wiki/transactions/contracts/#derived-contracts","title":"Derived Contracts","text":""},{"location":"wiki/transactions/contracts/#trustless-transactions","title":"Trustless Transactions","text":"<p>An aggregate (Schnorr) signature involving a single party is relatively simple but does not demonstrate the full flexibility of the construction. We show here how to generalize it for use in outputs involving multiple parties.</p> <p>As constructed in section 1.2, an aggregate signature requires trusting the receiving party. As Grin outputs are completely obscured by Pedersen Commitments, one cannot prove money was actually sent to the right party, hence a receiver could claim not having received anything. To solve this issue, we require the receiver to collaborate with the sender in building a transaction and specifically its kernel signature.</p> <p>Alice wants to pay Bob in grins. She starts the transaction building process:</p> <ol> <li>Alice selects her inputs and builds her change output. The sum of all    blinding factors (change output minus inputs) is <code>rs</code>.</li> <li>Alice picks a random nonce ks and sends her partial transaction, <code>ks*G</code> and    <code>rs*G</code> to Bob.</li> <li>Bob picks his own random nonce <code>kr</code> and the blinding factor for his output    <code>rr</code>. Using <code>rr</code>, Bob adds his output to the transaction.</li> <li>Bob computes the message <code>M = fee | lock_height</code>, the Schnorr challenge    <code>e = SHA256(M | kr*G + ks*G | rr*G + rs*G)</code> and finally his side of the    signature <code>sr = kr + e * rr</code>.</li> <li>Bob sends <code>sr</code>, <code>kr*G</code> and <code>rr*G</code> to Alice.</li> <li>Alice computes <code>e</code> just like Bob did and can check that    <code>sr*G = kr*G + e*rr*G</code>.</li> <li>Alice sends her side of the signature <code>ss = ks + e * rs</code> to Bob.</li> <li>Bob validates <code>ss*G</code> just like Alice did for <code>sr*G</code> in step 6 and can    produce the final signature <code>s = (ss + sr, ks*G + kr*G)</code> as well as the final    transaction kernel including <code>s</code> and the public key <code>rr*G + rs*G</code>.</li> </ol> <p>This protocol requires 3 data exchanges (Alice to Bob, Bob back to Alice, and finally Alice to Bob) and is therefore said to be interactive. However the interaction can be done over any medium and in any period of time, including the pony express over 2 weeks.</p> <p>This protocol can also be generalized to any number <code>i</code> of parties. On the first round, all the <code>ki*G</code> and <code>ri*G</code> are shared. On the 2nd round, everyone can compute <code>e = SHA256(M | sum(ki*G) | sum(ri*G))</code> and their own signature <code>si</code>. Finally, a finalizing party can then gather all the partial signatures <code>si</code>, validate them and produce <code>s = (sum(si), sum(ki*G))</code>.</p>"},{"location":"wiki/transactions/contracts/#multiparty-outputs-multisig","title":"Multiparty Outputs (multisig)","text":"<p>We describe here a way to build a transaction with an output that can only be spent when multiple parties approve it. This construction is very similar to the previous setup for trustless transactions, however in this case both the signature and a Pedersen Commitment need to be aggregated.</p> <p>This time, Alice wants to send funds such that both Bob and her need to agree to spend. Alice builds the transaction normally and adds the multiparty output such that:</p> <ol> <li>Bob picks a blinding factor <code>rb</code> and sends <code>rb*G</code> to Alice.</li> <li>Alice picks a blinding factor <code>ra</code> and builds the commitment    <code>C = ra*G + rb*G + v*H</code>. She sends the commitment to Bob.</li> <li>Bob creates a range proof for <code>v</code> using <code>C</code> and <code>rb</code> and sends it to Alice.</li> <li>Alice generates her own range proof, aggregates it with Bob, finalizing    the multiparty output <code>Oab</code>.</li> <li>The kernel is built following the same procedure as for Trustless    Transactions.</li> </ol> <p>We observe that for that new output <code>Oab</code>, neither party know the whole blinding factor. To be able to build a transaction spending Oab, someone would need to know <code>ra + rb</code> to produce a kernel signature. To produce that spending kernel, Alice and Bob need to collaborate. This, again, is done using a protocol very close to Trustless Transactions.</p>"},{"location":"wiki/transactions/contracts/#multiparty-timelocks","title":"Multiparty Timelocks","text":"<p>This contract is a building block for multiple other contracts. Here, Alice agrees to lock some funds to start a financial interaction with Bob and prove to Bob she has funds. The setup is the following:</p> <ul> <li>Alice builds a a 2-of-2 multiparty transaction with an output she shares with   Bob, however she does not participate in building the kernel signature yet.</li> <li>Bob builds a refund transaction with Alice that sends the funds back to Alice   using a timelock (for example 1440 blocks ahead, about 24h).</li> <li>Alice and Bob finish the 2-of-2 transaction by building the corresponding   kernel and broadcast it.</li> </ul> <p>Now Alice and Bob are free to build additional transactions distributing the funds locked in the 2-of-2 output in any way they see fit. If Bob refuses to cooperate, Alice just needs to broadcast her refund transaction after the time lock expires.</p> <p>This contract can be trivially used for unidirectional payment channels.</p>"},{"location":"wiki/transactions/contracts/#conditional-output-timelocks","title":"Conditional Output Timelocks","text":"<p>Analogous to Bitcoin's CheckLockTimeVerify.</p> <p>We currently have unconditional lock_heights on txs (tx is not valid and will not be accepted until lock_height has passed).</p> <p>Private keys can be summed together. Key<sub>3</sub> = Key<sub>1</sub> + Key<sub>2</sub></p> <p>Commitments can be summed together. C<sub>3</sub> = C<sub>1</sub> + C<sub>2</sub></p> <p>Given unconditional locktimes on txs we can leverage these to give us conditional locktimes on outputs by \"entangling\" two outputs on two related txs together.</p> <p>We can construct two txs (Tx<sub>1</sub>, Tx<sub>2</sub>) with two entangled outputs Out<sub>1</sub> and Out<sub>2</sub> such that -</p> <ul> <li>Out<sub>1</sub> (commitment C<sub>1</sub>) is from Tx<sub>1</sub> and built using Key<sub>1</sub></li> <li>Out<sub>2</sub> (commitment C<sub>2</sub>) is from Tx<sub>2</sub> and built using Key<sub>2</sub></li> <li>Tx<sub>2</sub> has an unconditional lock_height on it</li> </ul> <p>If we do this (and we can manage the keys as necessary) -</p> <ul> <li>Out<sub>1</sub> + Out<sub>2</sub> can only be spent as a pair using Key<sub>3</sub></li> <li>They can only be spent after lock_height from Tx<sub>2</sub></li> </ul> <p>Tx<sub>1</sub> (containing Out<sub>1</sub>) can be broadcast, accepted and confirmed on-chain immediately. Tx<sub>2</sub> cannot be broadcast and accepted until lock_height has passed.</p> <p>So if Alice only knows K<sub>3</sub> and does not know Key<sub>1</sub> or Key<sub>2</sub>, then Out<sub>1</sub> can only be spent by Alice after lock_height has passed. If Bob on the other hand knows Key<sub>2</sub> then Out<sub>1</sub> can be spent by Bob immediately.</p> <p>We have a conditional timelock on Out<sub>1</sub> (confirmed, on-chain) where it can be spent either with Key<sub>3</sub> (after lock_height), or Key<sub>2</sub> immediately.</p>"},{"location":"wiki/transactions/contracts/#relative-conditional-output-timelocks","title":"(Relative) Conditional Output Timelocks","text":"<p>Analogous to Bitcoin's CheckSequenceVerify.</p> <p>By combining \"Conditional Timelock on Output\" with \"(Relative) Timelocked Transactions\" we can encumber a confirmed output with a relative timelock (relative to a related tx kernel).</p> <p>Tx<sub>1</sub> (containing Out<sub>1</sub>) can be broadcast, accepted and confirmed on-chain immediately. Tx<sub>2</sub> cannot be broadcast and accepted until the relative lock_height has passed, relative to the referenced kernel from the earlier Tx<sub>1</sub>.</p>"},{"location":"wiki/transactions/contracts/#atomic-swap","title":"Atomic Swap","text":"<p>This setup relies on a time locked contract combined with a check for 2 public keys. On Bitcoin this would be a 2-of-2 multisig, one public key being Alice's, the second being the hash of a preimage that Bob has to reveal. In this setup, we consider public key derivation <code>x*G</code> to be the hash function and by Bob revealing <code>x</code>, Alice can then produce an adequate signature proving she knows <code>x</code> (in addition to her own private key).</p> <p>Alice has grins and Bob has bitcoin. They would like to swap. We assume Bob created an output on the Bitcoin blockchain that allows spending either by Alice if she learns a hash pre-image <code>x</code>, or by Bob after time <code>Tb</code>. Alice is ready to send her grins to Bob if he reveals <code>x</code>.</p> <p>First, Alice sends her grins to a multiparty timelock contract with a refund time <code>Ta &lt; Tb</code>. To send the 2-of-2 output to Bob and execute the swap, Alice and Bob start as if they were building a normal trustless transaction as specified in section 2.1.</p> <ol> <li>Alice picks a random nonce <code>ks</code> and her blinding sum <code>rs</code> and sends <code>ks*G</code>    and <code>rs*G</code> to Bob.</li> <li>Bob picks a random blinding factor <code>rr</code> and a random nonce <code>kr</code>. However    this time, instead of simply sending <code>sr = kr + e * rr</code> with his <code>rr*G</code> and    <code>kr*G</code>, Bob sends <code>sr' = kr + x + e * rr</code> as well as <code>x*G</code>.</li> <li>Alice can validate that <code>sr'*G = kr*G + x*G + rr*G</code>. She can also check    that Bob has money locked with <code>x*G</code> on the other chain.</li> <li>Alice sends back her <code>ss = ks + e * xs</code> as she normally would, now that she    can also compute <code>e = SHA256(M | ks*G + kr*G)</code>.</li> <li>To complete the signature, Bob computes <code>sr = kr + e * rr</code> and the final    signature is <code>(sr + ss, kr*G + ks*G)</code>.</li> <li>As soon as Bob broadcasts the final transaction to get his new grins, Alice    can compute <code>sr' - sr</code> to get <code>x</code>.</li> </ol> <p>Notes on the Bitcoin setup</p> <p>Prior to completing the atomic swap, Bob needs to know Alice's public key. Bob would then create an output on the Bitcoin blockchain with a 2-of-2 multisig similar to <code>alice_pubkey secret_pubkey 2 OP_CHECKMULTISIG</code>. This should be wrapped in an <code>OP_IF</code> so Bob can get his money back after an agreed-upon time and all of this can even be wrapped in a P2SH. Here <code>secret_pubkey</code> is <code>x*G</code> from the previous section.</p> <p>To verify the output, Alice would take <code>x*G</code>, recreate the bitcoin script, hash it and check that her hash matches what's in the P2SH (step 2 in previous section). Once she gets <code>x</code> (step 6), she can build the 2 signatures necessary to spend the 2-of-2, having both private keys, and get her bitcoin.</p>"},{"location":"wiki/transactions/contracts/#relative-timelocks-lightning-network","title":"\"Relative Timelocks\" (Lightning Network)","text":"<p>See No Recent Duplicate (NRD) transaction kernels for more details.</p>"},{"location":"wiki/transactions/payment-proofs/","title":"Payment Proofs","text":"<ul> <li>Title: payment-proofs</li> <li>Authors: David Burkett</li> <li>Start date: Nov 05 2019</li> <li>RFC PR: mimblewimble/grin-rfcs#31</li> <li>Tracking issue: mimblewimble/grin-wallet#230</li> </ul>"},{"location":"wiki/transactions/payment-proofs/#summary","title":"Summary","text":"<p>Support generating and validating payment proofs for sender-initiated (i.e. non-invoice) transactions.</p>"},{"location":"wiki/transactions/payment-proofs/#motivation","title":"Motivation","text":"<p>Bitcoin and other cryptocurrencies with transparent protocol-level addressing and immutable, unprunable blockchains can prove sender, receiver, and amounts of payments simply by pointing to the transaction in the blockchain. Grin's privacy and scalability means users no longer have this ability. This prevents some merchants from accepting Grin due to the high possibility of payment disputes that are unresolvable in the same way they are for transparent coins.</p> <p>This RFC changes the transaction building process where payers can require payees to create a \"proof\" they've received a payment before the payer finalizes and broadcasts the transaction.</p>"},{"location":"wiki/transactions/payment-proofs/#community-level-explanation","title":"Community-level explanation","text":"<p>From an end-user perspective, payers can require payees to prove receipt of funds as part of the transacting process. Payers can then use these \"proofs\" to resolve payment disputes and prove they sent funds to the correct payee.</p>"},{"location":"wiki/transactions/payment-proofs/#reference-level-explanation","title":"Reference-level explanation","text":""},{"location":"wiki/transactions/payment-proofs/#slate-changes","title":"Slate changes","text":"<p>A new (optional) structure (<code>payment_info</code>) will be added to transaction slates, along with a version increase. The <code>payment_info</code> structure will contain:</p> <ul> <li><code>sender_address</code> - An ed25519 public key generated by the sender.</li> <li><code>receiver_address</code> - An ed25519 public key for the receiver, typically the public key of the user's v3 onion address.</li> <li><code>receiver_signature</code> - A signature of the sender_address, received amount, and kernel commitment that validates against the <code>receiver_address</code>.</li> </ul>"},{"location":"wiki/transactions/payment-proofs/#generating-proofs","title":"Generating proofs","text":"<p>Receipt confirmations (<code>receiver_signature</code>) will be generated by the payee by providing an ED25519 signature of: <code>(amount || kernel_commitment || sender_address)</code>, using the private key of the <code>receiver_address</code>.</p> <p>The <code>sender_signature</code> can be generated for <code>(amount || kernel_commitment || sender_address)</code> using the private key of the <code>sender_address</code>.</p> <p>Sender will then create and store the following info, which can be considered the complete <code>payment_proof</code>:</p> <ul> <li><code>receiver_address</code></li> <li><code>receiver_signature</code></li> <li><code>amount</code></li> <li><code>kernel_commitment</code></li> <li><code>sender_address</code></li> <li><code>sender_signature</code></li> </ul> <p>Sizes of each corresponding field</p> Field Size amount 8 bytes excess 33 bytes recipient_address 32 bytes recipient_sig 64 bytes sender_address 32 bytes sender_sig 64 bytes <p>The fields <code>recipient_address</code> and <code>sender_address</code> will occuppy 32 bytes under assumption of being stored as ed25519 public keys.</p>"},{"location":"wiki/transactions/payment-proofs/#verifying-proofs","title":"Verifying Proofs","text":"<p>This <code>payment_proof</code> can be provided by the sender at any time to convince a payee that a payment was made to them. The proof can be verified as follows:</p> <ol> <li>Ensure the <code>kernel_commitment</code> is confirmed on-chain.</li> <li>Verify that the <code>receiver_address</code> belongs to the payee.</li> <li>Verify that the <code>receiver_signature</code> is valid.</li> <li>Verify that the <code>sender_signature</code> is valid.</li> </ol>"},{"location":"wiki/transactions/payment-proofs/#wallet-actions","title":"Wallet actions","text":""},{"location":"wiki/transactions/payment-proofs/#init-send","title":"init-send","text":"<p>As part of the first step of the tx-building process, the sender/payer generates the <code>sender_address</code> using their keychain.</p> <p>The <code>receiver_address</code> and keychain path of the <code>sender_address</code> must be stored locally, along with the <code>slate_id</code>.</p> <p>The <code>sender_address</code> and <code>receiver_address</code> will then be added to the <code>payment_proof</code> structure of the slate.</p>"},{"location":"wiki/transactions/payment-proofs/#receive","title":"receive","text":"<p>If the <code>payment_proof</code> structure exists on the slate, it is mandatory that the <code>receiver_signature</code> is generated and added to the slate as part of the receive tx-building step.</p>"},{"location":"wiki/transactions/payment-proofs/#finalize","title":"finalize","text":"<p>Using the <code>slate_id</code>, the sender can retrieve the original <code>sender_address</code> and <code>receiver_address</code> that were included in the slate, and verify that those fields remain unchanged. The sender must then validate the <code>receiver_signature</code>. If any of the original <code>payment_proof</code> slate fields were modified, or if the <code>receiver_signature</code> is invalid, the transaction must be rejected by the sender.</p> <p>Once the <code>payment_info</code> details have been validated, the sender can generate and store the <code>payment_proof</code> (See <code>Generating Proofs</code> above), and then finalize the transaction as normal.</p>"},{"location":"wiki/transactions/payment-proofs/#drawbacks","title":"Drawbacks","text":"<ul> <li>Increases the size of tx slates.</li> <li>Possibility of privacy leakage through address reuse.</li> </ul>"},{"location":"wiki/transactions/payment-proofs/#rationale-and-alternatives","title":"Rationale and alternatives","text":"<ul> <li>This design works well with TOR tx building, yet is generic enough to work with all known transacting mechanisms.</li> </ul>"},{"location":"wiki/transactions/payment-proofs/#prior-art","title":"Prior art","text":"<ul> <li>Wallet713 implements payment proofs for grinbox transactions, which our design adapts and builds on to work more seemlessly with onion addresses and with transaction building methods that don't inherently rely on addresses.</li> </ul>"},{"location":"wiki/transactions/payment-proofs/#unresolved-questions","title":"Unresolved questions","text":"<ul> <li>Can this be adapted to work for invoices?</li> </ul>"},{"location":"wiki/transactions/payment-proofs/#future-possibilities","title":"Future possibilities","text":"<ul> <li>Payment proofs could potentially be added to invoice payments in the future, but at the cost of an additional round of communication.</li> </ul>"},{"location":"wiki/transactions/payment-proofs/#references","title":"References","text":"<ol> <li> <p>Tx slate structure \u21a9</p> </li> <li> <p>Beam's payment proof model \u21a9</p> </li> </ol>"},{"location":"wiki/transactions/range-proof-format/","title":"Rangeproof Format","text":"<p>This  document could use a re-write.</p>"},{"location":"wiki/transactions/range-proof-format/#secp256k1-zkp-bulletproof-format","title":"secp256k1-zkp Bulletproof format","text":"<p>Grin uses Bulletproofs, the currently most efficient range proofs which do not require a trusted setup. Implemented at mimblewimble/secp256k1-zkp, a fork of the Blockstream C library ElementsProject/secp256k1-zkp.</p> <p>In this document we explain how to recover the proof parameters from the output bytes. Note that we name the parameters as they are named in the C library, which might be slightly different than the paper in some cases.</p> <p>Here is a sample proof output taken from a Grin transaction:</p> <pre><code>0b1bdf235e9c438aab5c6d02d3fe8173304bc528a3330825fb2311fa60fcdd6bfb92a248e26f849aebd511d2b326fa34b7f3030517d2f8e08a9b3cac7fa9fd200d07a46ca6ec5af30ce569b1e5faf2acf525cf1ed90cbed74ab7378b9b3957f28635fe7440aac2dc2c4bf43265b6ad1bfa82fddd9a827c4e97a913ce451b9a66bb06d3c08e03e85e98c581bbdf8c852796371a4603b8d52b80a1f2e95bd5e2a91c7a00b4d4564d9586235a7858d9ce8a8888bead7d51be2dd802de5af2921e079586817fce16d36c7764af8b4bf133b56b39970d6a568bf9ff101e6d33409e7c3bb081df7425b276655be611941245ceaad529495a86bc0e3d0f8634a8acf65c34c4e244959a5098bd58285408945a247d2fd894e5b18027d698c7e494e4256110553df54babf90592fbdffa0138b6b5a2a423ea5e2ec4d8f852a33c271a73b10fed9e1ee8cb2db1e71311cacd9e1d0b6dbf6cfab15723ec3cac4cc52154fc9d532202a085238e756ad1fa804cce2a634decc1b348f6ff939f9f80187d85aa5c308224a505c75e7f58fc7f35424276db7956474c1895e23ac55f864f4177b59f3ce92ef8c99e011cf55e0cefc5635d2eaf573df29af057a19bb209392a8c0e29a4b77adad76d385422e7f1d06de2d4f14e61ac3619aa22ae5bc288bb41cb56ddb70bb39ae84d00eb0cb34b4063bb55a83b9fe52604e545adcd41beb6ce14cdff73a21beb7493fa443a34585b7d2927f608cad17aa5f0e8e154b14d35315f63dd3580e80d06d8be4039f58778967f7bf2cdd9020fbcc9fed799b8159814f6a261c568e8b59c59df3180efb9cc13c576bf313248c96fa867aba43a80e799ff19ac685d7208cea7944dc9dcba7a61f2809540ecd0711e76b601969bdc551845e0b11fb821871d00e417ad002a70353867db25fa647e98a0db4c3bbaf828d97fc66079ef0d\n</code></pre> <p>First, we have two 32 byte scalars. These are the already negated versions of taux and mu. We negate them such that the verifier doesn't have to do it (rangeproof_impl.h 701-702).</p> <p><code>0b1bdf235e9c438aab5c6d02d3fe8173304bc528a3330825fb2311fa60fcdd6b (5024686248162052924872973414517693136231035491146611931625298995470137089387)</code> taux (negated)</p> <p><code>fb92a248e26f849aebd511d2b326fa34b7f3030517d2f8e08a9b3cac7fa9fd20 (113789604713728301456840843635921464549630649029317112794749678552821986360608)</code> mu (negated)</p> <p>After that, we have 4 points, which represent commitments A, S, T1, T2. Points are encoded in a very smart way. We have one offset byte. We use this offset byte indicate the LSB of y, telling us if the points y value needs to be negated when recovered. If this is the case, the bit is set to 1 (starting at the LSB); otherwise, it is left at 0. If we have more then eight points, we need 2 bytes offset, if we have more then 16, then three, and so forth (rangeproof_impl.h 703).</p> <p><code>0d</code> offset</p> <p><code>0000 1101</code> offset in binary</p> <p>From this, we can recover the 4 points. (using the standard compressed point version here with leading 02 or 03) We start reading at the LSB.</p> <p><code>0307a46ca6ec5af30ce569b1e5faf2acf525cf1ed90cbed74ab7378b9b3957f286</code> A (03 because of the 1 bit in the offset)</p> <p><code>0235fe7440aac2dc2c4bf43265b6ad1bfa82fddd9a827c4e97a913ce451b9a66bb</code> S (02 here because of the 0 bit in the offset)</p> <p><code>0306d3c08e03e85e98c581bbdf8c852796371a4603b8d52b80a1f2e95bd5e2a91c</code> T1</p> <p><code>037a00b4d4564d9586235a7858d9ce8a8888bead7d51be2dd802de5af2921e0795</code> T2</p> <p>Next, we have the final value of the dot product which again is a 32-byte scalar (inner_product_impl.h 811)</p> <p><code>86817fce16d36c7764af8b4bf133b56b39970d6a568bf9ff101e6d33409e7c3b (60838727059453008536034129618950719358562694528830851223208761064459354405947)</code> dot</p> <p>Then we have the final values (32-byte scalars) of the shrunk vectors a, b used in the inner product protocol. The library does not do the last round of the protocol, meaning it will stop when the vectors are of length two instead of length one. This is because every round creates two commitments Li and Ri. If we don't do the last round, we spare two commitments with the cost that our two vectors are of size two instead of one, which is more space-efficient, and we save computing time. (inner_product_impl.h  835-836)</p> <p><code>b081df7425b276655be611941245ceaad529495a86bc0e3d0f8634a8acf65c34 (79836526842770413616887368822368313168206709119259360230886972660827215518772)</code> a1</p> <p><code>c4e244959a5098bd58285408945a247d2fd894e5b18027d698c7e494e4256110 (89053099110995010594661038229216983605420219413380810817771304480647904846096)</code> b1</p> <p><code>553df54babf90592fbdffa0138b6b5a2a423ea5e2ec4d8f852a33c271a73b10f (38556062768490931671602594328406809964645337276375001909352144464132590252303)</code> a2</p> <p><code>ed9e1ee8cb2db1e71311cacd9e1d0b6dbf6cfab15723ec3cac4cc52154fc9d53 (107477520278964342277912932357487306000871347661927764278313323679782451060051)</code> b2</p> <p>And last we have the commitments Li and Ri of every round. In Grin we create range proofs with a range of 0 to (2^64 -1). This means we have six rounds (log(64) = 6); however, since we stop early, we only do five rounds, so 10 points instead of 12. The implementation always computes L before R. (inner_product_impl.h 627) Again we have an offset in which we specify how to recover y values. Now since we have more than eight points we need two bytes offset. We start reading at the LSB of the first byte and then go to the LSB of the second byte. (inner_product_impl.h 839)</p> <p><code>2202</code> offset</p> <p><code>0010 0010</code> first offset byte (binary) <code>0000 0010</code> second offset byte (binary)</p> <p><code>02a085238e756ad1fa804cce2a634decc1b348f6ff939f9f80187d85aa5c308224</code> L1</p> <p><code>03a505c75e7f58fc7f35424276db7956474c1895e23ac55f864f4177b59f3ce92e</code> R1 (03 because of the 1 at bit number 2 of first offset byte)</p> <p><code>02f8c99e011cf55e0cefc5635d2eaf573df29af057a19bb209392a8c0e29a4b77a</code> L2</p> <p><code>02dad76d385422e7f1d06de2d4f14e61ac3619aa22ae5bc288bb41cb56ddb70bb3</code> R2</p> <p><code>029ae84d00eb0cb34b4063bb55a83b9fe52604e545adcd41beb6ce14cdff73a21b</code> L3</p> <p><code>03eb7493fa443a34585b7d2927f608cad17aa5f0e8e154b14d35315f63dd3580e8</code> R3 (03 because of the 1 at bit number 6 of first offset byte)</p> <p><code>020d06d8be4039f58778967f7bf2cdd9020fbcc9fed799b8159814f6a261c568e8</code> L4</p> <p><code>02b59c59df3180efb9cc13c576bf313248c96fa867aba43a80e799ff19ac685d72</code> R4</p> <p><code>0208cea7944dc9dcba7a61f2809540ecd0711e76b601969bdc551845e0b11fb821</code> L5</p> <p><code>03871d00e417ad002a70353867db25fa647e98a0db4c3bbaf828d97fc66079ef0d</code> R5 (03 because of the 1 at bit number 2 of second offset byte)</p>"},{"location":"wiki/transactions/slatepack/","title":"Slatepack","text":"<ul> <li>Title: <code>slatepack</code></li> <li>Authors: joltz</li> <li>Start date: May 07 2020</li> <li>RFC PR: mimblewimble/grin-rfcs#55</li> <li>Tracking issue: mimblewimble/grin-wallet#406</li> </ul>"},{"location":"wiki/transactions/slatepack/#summary","title":"Summary","text":"<p>Slatepack is a universal transaction standard for Grin. It is designed to provide a single coherent transaction building framework to improve both the user and developer experiences in the Grin ecosystem. All wallets and services are expected to fully support the Slatepack standard by the last scheduled hard fork in January 2021 to remain compatible.</p> <p>This document specifies the required components of the Slatepack standard and introduces them in the context of existing methods for transaction building in Grin. It assumes that Slatepack is the default supported transaction standard for Grin and is intended to operate under all conditions and edge cases. Slatepack is intended to be compatible with the objects and serialization methods defined in the Slate V4/Compact Slates RFC. This RFC is meant to replace the Slate Serialization, Armored Slates and Encrypted Slates RFCs.</p>"},{"location":"wiki/transactions/slatepack/#motivation","title":"Motivation","text":"<p>Without a comprehensive transaction building flow, users and services are left to make their own complicated decisions about firewalls, file handling and compatibility, risking their security, privacy and sanity.</p> <p>The objective of this RFC is to converge on a simple, universal, adoptable, secure and privacy preserving workflow standard for Grin transactions: Slatepack.</p>"},{"location":"wiki/transactions/slatepack/#community-level-explanation","title":"Community-level explanation","text":"<p>Slatepack changes the existing transaction building process in Grin in a few ways:</p> <ol> <li> <p>Users, developers and services are no longer required to choose between many possible transaction methods to use and support: Slatepack is a universal Grin transaction standard</p> <ul> <li>The transport method decision now occurs automatically for the user by following the Slatepack standard</li> <li>There is only one synchronous method and one asynchronous method supported by default to keep things simple for developers and support workers</li> </ul> </li> <li> <p>Tor is the only synchronous transaction transport method that is currently supported in the Slatepack standard</p> <ul> <li>This happens \"under the hood\" by the wallet and the user only has to keep track of a <code>SlatepackAddress</code> for their counterparty</li> <li>If Tor is not successful, the transaction process automatically falls back to using an encrypted copy and pastable <code>SlatepackMessage</code> string to complete the transaction asynchronously</li> </ul> </li> <li> <p>The asynchronous method by default is now a copy and pastable <code>SlatepackMessage</code> string instead of a file</p> <ul> <li><code>SlatepackMessage</code> is an ascii-armor string that supports encryption of its payload with a <code>SlatepackAddress</code><ul> <li>An encrypted <code>SlatepackMessage</code> is not meaningfully larger than a plain text <code>SlatepackMessage</code> with regard to transportability as proposed here</li> </ul> </li> </ul> </li> <li> <p>The difference between synchronous and asynchronous transaction methods is abstracted away from the end user with the Slatepack standard</p> <ul> <li><code>grin-wallet send -d SlatepackAddress 1.337</code> will first try to send the Grin synchronously via Tor to the <code>SlatepackAddress</code></li> <li>If that fails it will fall back to outputting an armored encrypted <code>SlatepackMessage</code> string for manual copy and paste transport</li> <li>Example <code>SlatepackAddress</code>: <code>grin1p4fuklglxqsgg602hu4c4jl4aunu5tynyf4lkg96ezh3jefzpy6swshp5x</code></li> </ul> </li> <li> <p>Asynchronous transactions are now encrypted by default by knowing the <code>SlatepackAddress</code> of your counterparty(s)</p> <ul> <li>If a counterparty is unwilling or unable to provide a <code>SlatepackAddress</code>, a plain text <code>SlatepackMessage</code> can still be exchanged</li> </ul> </li> <li> <p>Sending a mobile Grin transaction should be as easy as scanning a simple QR encoded from a bech32 <code>SlatepackAddress</code></p> <ul> <li>Or as easy as pasting the <code>SlatepackAddress</code> of your counterparty into your wallet for any other device</li> <li>Or if Tor is not accessible, or the receiving party is not online, as easy as copying and pasting a couple of <code>SlatepackMessage</code> strings with a counterparty in an alternative communication channel (email, forum, social media, instant messenger, generic web text box, carrier pigeon etc.)</li> </ul> </li> </ol>"},{"location":"wiki/transactions/slatepack/#reference-level-explanation","title":"Reference-level explanation","text":"<p>The Slatepack standard defines the three primary components: <code>SlatepackAddress</code>, <code>SlatepackMessage</code> and <code>SlatepackWorkflow</code>.</p> <p>The <code>SlatepackAddress</code> is a shareable bech32 encoded ed25519 public key that can be used both to route synchronous transactions and to encrypt asynchronous transactions.</p> <p>The <code>SlatepackMessage</code> is an easily copy and pastable ascii-armor string that contains an encrypted slate payload by default and is used in asynchronous transactions.</p> <p>The <code>SlatepackWorkflow</code> specifies how both of these components interact in a universally adoptable transaction standard for Grin.</p>"},{"location":"wiki/transactions/slatepack/#slatepackaddress","title":"<code>SlatepackAddress</code>","text":"<p>A <code>SlatepackAddress</code> is a bech32 encoded ed25519 public key and when shared with other parties is used to represent the ability to receive Grin transactions.</p> <p>grin-wallet already handles ed25519 keys for the v3 onion addresses in Tor transactions. These keys can be extended to be a general <code>SlatepackAddress</code> to allow a universal key format for both transport and encryption that is error-checked, QR friendly and easily human identifiable.</p> <ul> <li> <p>Existing ed25519 public keys from the wallet are bech32 encoded with <code>grin</code> as the <code>human-readable part</code> to build a <code>SlatepackAddress</code></p> <ul> <li><code>tgrin</code> is the HRP for a floonet <code>SlatepackAddress</code></li> </ul> </li> <li> <p>A <code>SlatepackAddress</code> can be decoded to its ed25519 public key which can then be mapped to an x25519 public key to be used for encryption</p> </li> </ul> <p>By default, all wallets should generate a new <code>SlatepackAddress</code> for each transaction for improved user privacy and security. Wallets can optionally support the ability for a static, reusable receiving <code>SlatepackAddress</code> with a warning about the privacy risks of reusing these addresses.</p> <p>The exact proposal for the implementation of simultaneous active <code>SlatepackAddresses</code> to enforce address uniqueness by default according to this standard is left as an implementation detail to wallets to ensure that wallets can interactively receive Grin across many <code>SlatepackAddresses</code> simultaneously and efficiently.</p> <p>ed25519 keys are bech32 encoded as <code>SlatepackAddresses</code> rather than x25519 keys because the mapping from ed25519 to x25519 is more straightforward (x25519 public keys do not carry a <code>v</code> coordinate so they can map to two possible ed25519 public keys- this is solvable but using the ed25519 as the first order key avoids a potentially complex solution).</p>"},{"location":"wiki/transactions/slatepack/#key-generation","title":"Key Generation","text":"<p>Keys used in <code>SlatepackAddresses</code> are derived from a path from the master seed in a given wallet account. Currently the wallet uses separate derivation paths: one for the private bytes used for the blinding factor keys and one for the private bytes used to derive the ed25519 keys used to derive Tor onion addresses. ed25519 keys used for a <code>SlatepackAddress</code> are derived from this second derivation path of the master seed.</p> <p><code>SlatepackAddress</code> keys may be derived in parallel to the blinding factor derivation path such that a unique <code>SlatepackAddress</code> is derived each time a new blinding factor is derived for a transaction to satisfy the requirement for a unique <code>SlatepackAddress</code> to be used for each transaction by default.</p> <p>In a future update it may be desirable to encode the derivation path for the <code>SlatepackAddress</code> for a given encrypted <code>SlatepackMessage</code> somewhere so that the x25519 decryption keys can be derived without grinding down the path to find the right key to use.</p>"},{"location":"wiki/transactions/slatepack/#example-slatepackaddress","title":"Example <code>SlatepackAddress</code>","text":"<pre><code>grin1p4fuklglxqsgg602hu4c4jl4aunu5tynyf4lkg96ezh3jefzpy6swshp5x\n</code></pre>"},{"location":"wiki/transactions/slatepack/#slatepackmessage","title":"<code>SlatepackMessage</code>","text":"<p>A <code>SlatepackMessage</code> requires multiple layers of data and encoding.</p>"},{"location":"wiki/transactions/slatepack/#serialization","title":"Serialization","text":"<p>Grin slates are serialized as first order JSON objects. Binary serialization is done on those JSON objects. Before Slatepack, users could use both binary and JSON serialization for asynchronous transactions.</p> <p>With the Slatepack standard, all asynchronous transactions serialize the slate JSON objects as binary. JSON serialization for synchronous transactions (Tor) is still used as before. The Slatepack standard serialization choices are only relevant for asynchronous transaction methods.</p> <p>The details for the binary serialization of the most recent slates at the time of this writing can be found in the Slate V4 (Compact Slates) RFC. Future variations in slate binary serialization should be referenced in an RFC and may require the update of this document.</p>"},{"location":"wiki/transactions/slatepack/#plain-text-metadata","title":"Plain Text Metadata","text":"<p>Plain text metadata is included with Slatepack messages to indicate how to handle the encryption if any for the slate data in addition to tracking versions for compatibility. It can be expanded in future versions with new fields that are safe to include as plain text. These fields are neither encrypted nor authenticated.</p> <ul> <li><code>\"slatepack\": [Major, Minor]</code></li> <li> <p>Where <code>[Major, Minor]</code> are positive fixnum ints representing the Slatepack version used to build the <code>SlatepackMessage</code></p> </li> <li> <p><code>\"mode\": int</code></p> </li> <li>Where <code>int</code> is a positive fixnum int indicating the type of <code>SlatepackMessage</code></li> <li>0 == plain text</li> <li>1 == encrypted</li> <li>Extendable to future new modes (e.g. multiparty)</li> <li> <p>Indicates which additional metadata fields should be expected to follow</p> </li> <li> <p><code>\"sender\": SlatepackAddress</code></p> </li> <li>Only used here where <code>mode == 0</code>, otherwise this field is encrypted as described below</li> <li>Where <code>SlatepackAddress</code> is a bech32 encoded ed25519 public key generated by the sender's wallet</li> <li>For Slatepacks where the user does not wish to provide any <code>SlatepackAddress</code> a <code>0</code> value is used</li> <li>This value is used in the <code>SlatepackWorkflow</code> to attempt to complete the transaction via Tor and to otherwise encrypt a slate for asynchronous transport</li> </ul>"},{"location":"wiki/transactions/slatepack/#encrypted-metadata","title":"Encrypted Metadata","text":"<p>Encrypted metadata is included with an encrypted <code>SlatepackMessage</code> to improve privacy for the sender of a Slatepack transaction in cases where Tor is not available. It is a basic structure containing the sender <code>SlatepackAddress</code> and potential <code>recipients_list</code> field for multiparty use to be encrypted by age. If these fields are included as plain text metadata, they would require an additional MAC field for authentication and reveal data that would be desirable to keep private.</p> <p>Note that <code>recipients_list</code> does not gain the same privacy advantages of the <code>sender</code> field because the values can be derived from the plain text data included in the age header with a bit of work.</p> <ul> <li><code>\"sender\": SlatepackAddress</code></li> <li> <p>Used to complete the <code>SlatepackWorkflow</code></p> </li> <li> <p><code>\"recipients_list\": vec&lt;SlatepackAddress&gt;</code></p> </li> <li>Only included in multiparty encrypted mode for use in future versions</li> <li>Array of recipients such that each recipients <code>SlatepackAddress</code> in <code>recipients_list</code> matches their associated <code>epk</code> and <code>emk</code> by index in the age encryption header of the encrypted payload</li> <li>E.g. <code>\"recipients_list\": [grin1a, grin1b]</code>, <code>\"age_header_recipients\": [(X25519, EPKa, EMKa), (X25519, EPKb, EMKb)]</code><ul> <li><code>grin1a</code> and <code>(X25519, EPKa, EMKa)</code> both belong to the same party as they are both at index 0</li> <li><code>grin1b</code> and <code>(X25519, EPKb, EMKb)</code> both belong to the same party as they are both at index 1</li> </ul> </li> </ul>"},{"location":"wiki/transactions/slatepack/#encryption","title":"Encryption","text":"<p>Slatepack encryption adheres to the cryptography decisions made by age. It supports a conversion from the ed25519 signing key type that grin-wallet already uses for Tor to a x25519 encryption key type that age uses for encryption. This allows us to avoid having to make new cryptography decisions to support encrypted slates with keys already used in grin-wallet.</p> <p>While Slatepack adheres to the cryptography decisions and payload structure choices made by age in its encrypted payloads, this data alone is not sufficient to handle all possible <code>SlatepackWorkflow</code> steps (because the age recipient header data contains x25519 keys, we want ed25519 keys for the workflow as key mapping in the other direction is not desirable).</p> <p>It should also be noted that a <code>SlatepackAddress</code> could be used to do generic age encryption by decoding the bech32 to the ed25519 public key and mapping that to its corresponding x25519 public key used in age. An <code>age Address</code> could also be used as a <code>SlatepackAddress</code> with some extra effort: bech32 decode to the x25519 public key and then follow Signal's lead to attempt to solve the problem of an x25519 key mapping to two ed25519 keys to give a single ed25519 public key to be used to build a <code>SlatepackAddress</code> by bech32 encoding with <code>slatepack</code> as the HRP.</p>"},{"location":"wiki/transactions/slatepack/#payload-age-encryption","title":"Payload (age Encryption)","text":"<p>A binary serialized slate and associated <code>Encrypted Metadata</code> fields are concatenated and encrypted according to the age encryption specification. The steps taken here follow age as closely as possible to avoid losing any security properties. A fairly well-reviewed age library in rust is available to use for implementation.</p> <p>Any deviations in Slatepack encryption from the exact cryptography steps and decisions made in age are unintentional and should be corrected unless they are explicitly stated as a deviation from the cryptography decisions made by age.</p> <p>An encrypted Slatepack payload is built with the same steps as an encrypted age payload, where the X25519 keys are derived from a participants <code>SlatepackAddress</code>.</p> <p>E.g. <code>age_encrypt(sender + slate_binary)</code> where <code>mode == 1</code> and <code>sender</code> is a valid <code>SlatepackAddress</code></p>"},{"location":"wiki/transactions/slatepack/#armor","title":"Armor","text":"<p>The payload that will be armored is an optionally encrypted, binary serialized <code>Slatepack</code> JSON object and any associated encrypted metadata. Armor is <code>Framing</code> wrapped around a <code>SimpleBase58Check</code> encoded <code>Payload</code>.</p>"},{"location":"wiki/transactions/slatepack/#framing","title":"Framing","text":"<p>Armor uses specific <code>Headers</code>, <code>Footers</code> and <code>Periods</code> as <code>Framing</code> to contain its <code>Payload</code>.</p> <ul> <li><code>Header</code></li> <li>Supported Headers:<ul> <li><code>BEGINSLATEPACK</code></li> </ul> </li> <li> <p>Regex: <code>^[&gt;\\n\\r\\t ]*BEGINSLATEPACK[&gt;\\n\\r\\t ]*$</code></p> </li> <li> <p><code>Footer</code></p> </li> <li>Supported Footers<ul> <li><code>ENDSLATEPACK</code></li> </ul> </li> <li> <p>Regex: <code>^[&gt;\\n\\r\\t ]*ENDSLATEPACK[&gt;\\n\\r\\t ]*$</code></p> </li> <li> <p><code>Periods</code></p> </li> <li> <p>All data of an armored slate up to the first <code>.</code> is the framing header</p> </li> <li>All data after the first <code>.</code> and before the second <code>.</code> is the <code>SimpleBase58Check</code> encoded payload which contains the slate data</li> <li>All data after the second <code>.</code> and before the third <code>.</code> is the framing footer</li> <li>Any data after the third <code>.</code> is ignored</li> </ul>"},{"location":"wiki/transactions/slatepack/#encoding-simplebase58check","title":"Encoding <code>SimpleBase58Check</code>","text":"<p><code>SlatepackMessage</code> armor payloads are encoded similar to legacy bitcoin addresses, with the primary differences being that the <code>SimpleBase58Check</code> used here does not include version bytes and includes the error checking code at the beginning of the payload instead of at the end.</p> <ol> <li> <p><code>SHA256(SHA256(SLATEPACK_MESSAGE_BINARY))</code></p> </li> <li> <p>First four bytes from previous step are <code>ERROR_CHECK_CODE</code></p> </li> <li> <p>Concatenate <code>ERROR_CHECK_CODE + SLATEPACK_MESSAGE_BINARY</code></p> </li> <li> <p>Base58 encode the output from the previous step to complete the armor <code>Payload</code></p> </li> </ol> <p>It should be noted that the <code>ERROR_CHECK_CODE</code> does not have a robust error checking ability because a double sha256 hash is not a proper error check code and the encoding scheme itself was meant to be used for bitcoin addresses which are much smaller than slate payloads.</p> <p>A more robust error correction option was not chosen here because the consequences of the failure to detect an error are not as severe as they would be for a bitcoin address as further validation would need to occur for Grin. The purpose is to catch some characters being accidentally added or lost during armor transport rather than preventing a spend to an address we don't know the key to spend from.</p>"},{"location":"wiki/transactions/slatepack/#formatting","title":"Formatting","text":"<ul> <li><code>WORD_LENGTH</code>: <code>15</code></li> <li> <p>Number of <code>SimpleBase58Check</code> encoded characters per word; chosen for human readability across device screen sizes</p> </li> <li> <p><code>LINE_BREAK</code>: <code>200</code> words</p> </li> <li> <p>Number of words of <code>WORD_LENGTH</code> to include before inserting a newline; chosen for user friendliness in terminals and messaging applications</p> </li> <li> <p><code>MAX_STRING_SIZE</code>: <code>1MB</code></p> </li> <li>Maximum size for an armored <code>SlatepackMessage</code> string without requiring a file container</li> <li>If a <code>SlatepackMessage</code> exceeds this value it must be handled as a <code>.slatepack</code> file instead of a string</li> <li>This parameter chosen to cover as many cases as possible and still be supported by most clipboards</li> </ul> <p><code>WORD_LENGTH</code> and <code>LINE_BREAK</code> parameters are adjustable as a formatting convenience. <code>MAX_STRING_SIZE</code> is fixed and cannot be exceeded without wrapping the armored <code>SlatepackMessage</code> in a <code>.slatepack</code> file.</p>"},{"location":"wiki/transactions/slatepack/#edge-case-large-slates-1mb","title":"Edge Case: Large Slates (&gt;1MB)","text":"<p>Some slate payloads may be so large that they cannot be reliably handled across all clipboards. To handle these edge cases, a <code>SlatepackMessage</code> will be expected to be passed in a <code>.slatepack</code> file format in cases where Tor is unsuccessful and the armored <code>SlatepackMessage</code> string output would exceed 1MB. A file format was chosen as opposed to a multi-part message approach because messages are already written to file by default by grin-wallet and they are potentially simpler to handle from an implementation perspective.</p> <p>While wallets must support handling these edge cases to avoid all possible cases where a wallet cannot spend or receive a valid transaction, it would be reasonable for services and exchanges to support the Slatepack standard without the requirement of handling the rare file edge case.</p>"},{"location":"wiki/transactions/slatepack/#example-slatepack-json-object","title":"Example Slatepack JSON Object","text":""},{"location":"wiki/transactions/slatepack/#mode-0-plain-text","title":"Mode 0: Plain Text","text":"<p>In this plain text example, neither the sender nor the receiver wish to share a <code>SlatepackAddress</code></p> <pre><code>{\n  \"slatepack\": [1, 0],\n  \"mode\": 0,\n  \"sender\": \"0\",\n  \"payload\": &lt;binary serialized slate&gt;\n}\n</code></pre>"},{"location":"wiki/transactions/slatepack/#mode-1-encrypted","title":"Mode 1: Encrypted","text":"<pre><code>{\n  \"slatepack\": [1, 0],\n  \"mode\": 1,\n  \"payload\": &lt;age encrypted binary: sender slatepack address + binary serialized slate&gt;,\n}\n</code></pre>"},{"location":"wiki/transactions/slatepack/#example-slatepackmessage","title":"Example <code>SlatepackMessage</code>","text":"<pre><code>BEGINSLATEPACK. 4H1qx1wHe668tFW yC2gfL8PPd8kSgv\npcXQhyRkHbyKHZg GN75o7uWoT3dkib R2tj1fFGN2FoRLY\nGWmtgsneoXf7N4D uVWuyZSamPhfF1u AHRaYWvhF7jQvKx\nwNJAc7qmVm9JVcm NJLEw4k5BU7jY6S eb. ENDSLATEPACK.\n</code></pre>"},{"location":"wiki/transactions/slatepack/#slatepackworkflow","title":"<code>SlatepackWorkflow</code>","text":"<p>Adoption of the Slatepack standard allows for a unified workflow that can still function without knowledge of a <code>SlatepackAddress</code> from a counterparty.</p>"},{"location":"wiki/transactions/slatepack/#with-a-slatepackaddress","title":"With a <code>SlatepackAddress</code>","text":"<ol> <li> <p><code>grin-wallet send -d grin1p4fuklglxqsgg602hu4c4jl4aunu5tynyf4lkg96ezh3jefzpy6swshp5x 1.337</code></p> </li> <li> <p>Sender wallet derives an onion v3 address from <code>grin1p4fuklglxqsgg602hu4c4jl4aunu5tynyf4lkg96ezh3jefzpy6swshp5x</code> and attempts to complete the transaction synchronously via Tor</p> </li> <li> <p>(Fallback) If the synchronous transaction fails, a <code>SlatepackMessage</code> string is encrypted to the <code>SlatepackAddress</code> and output for manual asynchronous transport by the user</p> </li> </ol>"},{"location":"wiki/transactions/slatepack/#without-a-slatepackaddress","title":"Without a <code>SlatepackAddress</code>","text":"<ol> <li> <p><code>grin-wallet send 1.337</code></p> </li> <li> <p>A <code>SlatepackMessage</code> string is output for manual asynchronous transport by the user</p> </li> </ol>"},{"location":"wiki/transactions/slatepack/#with-qr-codes","title":"With QR Codes","text":"<p>A QR-based <code>SlatepackWorkflow</code> will always begin with a standard QR size because they are encoded directly from a bech32 <code>SlatepackAddress</code>.</p> <p>This encoding simultaneously provides a derivable onion address to attempt a synchronous transaction (<code>bech32 -&gt; ed25519 -&gt; onionv3</code>) and a derivable encryption key (<code>bech32 -&gt; ed25519 -&gt; x25519</code>) to return an encrypted Slatepack string to complete the transaction asynchronously as a fallback.</p> <p>As a consequence, a <code>SlatepackAddress</code> must be revealed by the party producing a QR code in the <code>SlatepackWorkflow</code>.</p> <ol> <li> <p>Receiver shares <code>SlatepackAddress</code> via QR</p> </li> <li> <p>Sender scans QR code and the transaction is completed synchronously via Tor by deriving the recipient's onion v3 address from their <code>SlatepackAddress</code></p> </li> <li> <p>(Fallback) If the synchronous transaction fails, a <code>SlatepackMessage</code> string is output for manual asynchronous transport by the user</p> </li> </ol>"},{"location":"wiki/transactions/slatepack/#with-three-or-more-parties","title":"With Three or More Parties","text":"<p>Some possible future Slatepack transactions may require more than two parties to successfully build. These cases should not require any breaking changes to the core Slatepack standard workflow.</p> <p>The exact flow order (round-robin etc) will be defined by the accompanying RFCs that define the possible future multiple party slates themselves. In some cases, new slate versions may require (non-breaking) updates to this RFC. From there, the same standard Slatepack standard workflow of attempting to exchange the data via Tor first with an ascii armor fallback is still valid.</p> <p>For example, a future Slatepack version will add support for an array containing a <code>SlatepackAddress</code> for each party in the order desired to finish building the transaction. The wallet of each subsequent party will attempt to establish a connection with the next via Tor. In the event of a Tor failure it would be the responsibility of the most recent party to manually transport it to the next.</p> <p>In cases with many parties, the fallback method of the Slatepack standard could quickly become cumbersome if, for example, every third participant fails to achieve a Tor connection.</p>"},{"location":"wiki/transactions/slatepack/#implementation-timeline","title":"Implementation Timeline","text":"<ol> <li>Initial Slatepack implementation introduced with the July 2020 hard fork</li> <li> <p>May or may not support encryption by default yet</p> </li> <li> <p>The proposed Slatepack standard is fully implemented and adopted as a universal transaction standard in last hard fork (Jan 2021)</p> </li> <li>Slatepack is the default transaction standard in all wallets and services</li> </ol>"},{"location":"wiki/transactions/slatepack/#drawbacks","title":"Drawbacks","text":"<ul> <li> <p>This puts a lot of eggs in one basket (if Slatepack fails there will likely be confusion returning to old methods)</p> </li> <li> <p>This may be a bit rushed to have where we want it before HF schedule</p> </li> <li> <p>Deprecating HTTP(S) is already a major change- by requiring the adoption of this completely new standard in addition we risk putting a lot of effort on the shoulders of existing services in the Grin ecosystem</p> </li> </ul>"},{"location":"wiki/transactions/slatepack/#rationale-and-alternatives","title":"Rationale and alternatives","text":"<ul> <li> <p>By adding new options without simplifying the workflow for users we risk confusion and friction</p> </li> <li> <p>We could just add an option for copy and pastable slates instead of introducing an entirely new universal transaction flow standard</p> </li> </ul>"},{"location":"wiki/transactions/slatepack/#prior-art","title":"Prior art","text":"<p>Note that while previous asynchronous Mimblewimble transaction solutions require a relatively short TTL for a counterparty to successfully connect to their respective network before transactions fail (currently 72 hours for Tari DHT Network, 24 hours for Beam SBBS), Grin Slatepack transactions can remain valid indefinitely without spamming the network when using the ascii armor fallback.</p>"},{"location":"wiki/transactions/slatepack/#tari","title":"Tari","text":"<p>Tari uses the Tari DHT Network to support asynchronous Mimblewimble transactions. This approach is comprehensive and comprises of the entire peer to peer messaging network, including both nodes and wallets. This is distinct from Slatepack which is strictly an approach to transaction building between wallet software, not general protocol messaging.</p> <p>Similar to Slatepack, Tari users derive a public key from their master seed (which is represented to users as emojis instead of bech32) and is used to look up peers in peer databases (as opposed to directly routing to a traditional Tor hidden service as in Slatepack). By default, Tari, like Slatepack, uses Tor for communication.</p> <p>While Slatepack and Tari both have addresses that decode to public keys used to find and communicate with counterparty wallets via Tor, they both handle the Tor failure case differently. Tari seems to rely on its custom DHT network to gracefully handle this at the cost of the complexity of a custom DHT layer. Slatepack falls back to an unopinionated, encrypted ascii armor string for the user to transport \"outside of the Grin network\" to complete the transaction.</p> <p>The advantage for Slatepack is significantly reduced complexity by using Tor directly with an unopinionated fallback mode. The disadvantage for Slatepack is that transactions don't \"magically\" just work if Tor communication is failing- they still require some effort from the user to transport the ascii armor themselves.</p> <p>Note that these details were taken from early documentation and not code- transactions in Tari may behave differently in practice.</p>"},{"location":"wiki/transactions/slatepack/#beam","title":"Beam","text":"<p>Beam uses the SBBS gossip protocol to support asynchronous mimblewimble transactions. SBBS adds a nontrivial amount of complexity and attack surface to the core Beam software. In exchange, Beam receives a somewhat user-friendly mechanism for users to build transactions asynchronously. The asynchronous fallback method for Slatepack transactions is a simple ascii armor string that does not contain an opinion about a particular protocol with which to exchange the data.</p> <p>The advantage with the Slatepack method is that much less code is required to support these transactions which can improve the overall stability and security of the codebase running the Grin network. The disadvantage of this for Slatepack is that asynchronous transactions don't \"magically\" work- they still need to be between users via an outside channel (instant message, text box, email etc). Slatepack makes the tradeoff of slightly more work for the end user in exchange for a simpler and potentially more secure network for Grin.</p>"},{"location":"wiki/transactions/slatepack/#unresolved-questions","title":"Unresolved questions","text":"<ul> <li> <p>How to handle key derivation harmoniously?</p> </li> <li> <p>What are unmentioned security considerations for using the same base key to both map to an onion address and map to an encryption key used in transactions?</p> </li> <li> <p>Related, what are unmentioned security considerations to <code>SlatepackAddress</code> reuse?</p> </li> <li> <p>Should we still use double-sha256 in <code>SimpleBase58Check</code> or take the opportunity to use a BCH or CRC code which may be more appropriate for error detection on slatepack messages?</p> </li> <li> <p>Is additional engineering desired here if there will always be further validation of the slate payload before a spend can occur?</p> </li> <li> <p>If addresses are not reused by default and since wallets need to be able to conduct multiple transactions in parallel, they need the ability to listen on all \"active\" addresses at the same time</p> </li> </ul>"},{"location":"wiki/transactions/slatepack/#future-possibilities","title":"Future possibilities","text":"<ul> <li> <p>Extended to support future modes (payment channel, payjoin, multiple counterparties etc)</p> </li> <li> <p>An entirely different standard could be adopted in the future if non-interactive transactions become the default, eliminating the need for Slatepack</p> </li> <li>It might be possible for a new standard to remain compatible with the existing <code>SlatepackAddress</code> to allow a more generic <code>GrinAddress</code></li> </ul>"},{"location":"wiki/transactions/slatepack/#references","title":"References","text":"<ol> <li> <p>Bitcoin BIP173 \u21a9</p> </li> <li> <p>age - File Encryption Tool &amp; Format \u21a9</p> </li> <li> <p>age Rust library \u21a9</p> </li> <li> <p>Ed25519 Keys \u21a9</p> </li> <li> <p>Ed25519 to Curve25519 \u21a9</p> </li> <li> <p>Using Ed25519 signing keys for encryption \u21a9</p> </li> <li> <p>Armored Slates RFC \u21a9</p> </li> <li> <p>Saltpack \u21a9</p> </li> <li> <p>Tor v3 Specification \u21a9</p> </li> <li> <p>Signal Docs XEdDSA \u21a9</p> </li> <li> <p>How Tari Works \u21a9</p> </li> <li> <p>Beam Docs SBBS \u21a9</p> </li> </ol>"},{"location":"wiki/transactions/slates/","title":"Slates","text":"<ul> <li>Title: <code>slate-v4 (compact slates)</code></li> <li>Authors: Michael Cordner</li> <li>Start date: April 03 2020</li> <li>RFC PR: mimblewimble/grin-rfcs#49</li> <li>Tracking issue: mimblewimble/grin-wallet#317</li> </ul>"},{"location":"wiki/transactions/slates/#summary","title":"Summary","text":"<p>What is a slate?</p> <p>To exchange Grin, users must exchange transaction slates in one form or another. A transaction slate is a blob containing the necessary data to be included at each step of the transaction building process.</p> <p>This RFC describes the changes between version 3 and version 4 of the Slate transaction exchange format, which had the goal of reducing the contents of the Slate to be as minimal as possible.</p>"},{"location":"wiki/transactions/slates/#motivation","title":"Motivation","text":"<p>Previously, the definition of Slate versions up to V3 had been put together with no regard for its size or/and redundant/irrelevant content. In order to facilitate future exchange method possibilities, it's desirable to ensure the Slate is as compact as possible, particularly on the 'first leg' of a transaction exchange which only actually requires minimal information from the transaction initiator.</p> <p>This RFC aims to define the contents of a streamlined \"compact\" slate by:</p> <ul> <li>Removing all redundant or unnecessary Slate fields</li> <li>Shortening the names of many Slate fields</li> <li>Reducing the size of the Slate to at all phases of a transaction</li> <li>Defining an optional highly-minimized binary format for Slate output</li> </ul> <p>Although this RFC doesn't address any particular transaction exchange methods that might be facilitated by this streamlining, one could envisage possibilities such as:</p> <ul> <li>An exchange placing the entire initial slate in a QR code</li> <li>Encoding the initial slate as an easily-cut-and-paste chunk</li> </ul>"},{"location":"wiki/transactions/slates/#community-level-explanation","title":"Community-level explanation","text":"<p>There are two basic transaction workflows in a two-party Grin transaction:</p> <ul> <li> <p>In the Basic workflow, a sender adds their inputs and change outputs to a transaction, and sends them, along with the fee, the amount and their signature data to the recipient. The recipient adds a output for the amount to the transaction, adds their signature data and returns to the sender, who completes the transaction and posts.</p> </li> <li> <p>In the Invoice workflow, the invoice creator adds a new output to a transaction, and sends the amount and signature data to the payer. The payer adds their inputs and change outputs to the transaction along with their signature data and fee information, then returns to the invoicer, who completes the transaction and posts.</p> </li> </ul> <p>Although previous versions of the Slate included every party's complete inputs and outputs at every stage of the transaction, it is not technically necessary for the initiator to provide their inputs and outputs to the other party. It suffices for the initiator to store the input/output listing in their local transaction context, and only provide the amount, fee, excess and signature data to the other party. Recognizing this, it is possible to ensure that the 'first-leg' of a transaction stage is extremely compact.</p> <p>For instance, version 3 of the Slate on transaction initiation may have looked something like the following:</p> <pre><code>{\n  \"version_info\": {\n    \"version\": 3,\n    \"orig_version\": 3,\n    \"block_header_version\": 2\n  },\n  \"num_participants\": 2,\n  \"id\": \"0436430c-2b02-624c-2032-570501212b00\",\n  \"tx\": {\n    \"offset\": \"d202964900000000d302964900000000d402964900000000d502964900000000\",\n    \"body\": {\n      \"inputs\": [\n        {\n          \"features\": \"Coinbase\",\n          \"commit\": \"087df32304c5d4ae8b2af0bc31e700019d722910ef87dd4eec3197b80b207e3045\"\n        },\n        {\n          \"features\": \"Coinbase\",\n          \"commit\": \"08e1da9e6dc4d6e808a718b2f110a991dd775d65ce5ae408a4e1f002a4961aa9e7\"\n        }\n      ],\n      \"outputs\": [\n        {\n          \"features\": \"Plain\",\n          \"commit\": \"0812276cc788e6870612296d926cba9f0e7b9810670710b5a6e6f1ba006d395774\",\n          \"proof\": \"dcff6175390c602bfa92c2ffd1a9b2d84dcc9ea941f6f317bdd0f875244ef23e696fd17c71df79760ce5ce1a96aab1d15dd057358dc835e972febeb86d50ccec0dad7cfe0246d742eb753cf7b88c045d15bc7123f8cf7155647ccf663fca92a83c9a65d0ed756ea7ebffd2cac90c380a102ed9caaa355d175ed0bf58d3ac2f5e909d6c447dfc6b605e04925c2b17c33ebd1908c965a5541ea5d2ed45a0958e6402f89d7a56df1992e036d836e74017e73ccad5cb3a82b8e139e309792a31b15f3ffd72ed033253428c156c2b9799458a25c1da65b719780a22de7fe7f437ae2fccd22cf7ea357ab5aa66a5ef7d71fb0dc64aa0b5761f68278062bb39bb296c787e4cabc5e2a2933a416ce1c9a9696160386449c437e9120f7bb26e5b0e74d1f2e7d5bcd7aafb2a92b87d1548f1f911fb06af7bd6cc13cee29f7c9cb79021aed18186272af0e9d189ec107c81a8a3aeb4782b0d950e4881aa51b776bb6844b25bce97035b48a9bdb2aea3608687bcdd479d4fa998b5a839ff88558e4a29dff0ed13b55900abb5d439b70793d902ae9ad34587b18c919f6b875c91d14deeb1c373f5e76570d59a6549758f655f1128a54f162dfe8868e1587028e26ad91e528c5ae7ee9335fa58fb59022b5de29d80f0764a9917390d46db899acc6a5b416e25ecc9dccb7153646addcc81cadb5f0078febc7e05d7735aba494f39ef05697bbcc9b47b2ccc79595d75fc13c80678b5e237edce58d731f34c05b1ddcaa649acf2d865bbbc3ceda10508bcdd29d0496744644bf1c3516f6687dfeef5649c7dff90627d642739a59d91a8d1d0c4dc55d74a949e1074427664b467992c9e0f7d3af9d6ea79513e8946ddc0d356bac49878e64e6a95b0a30214214faf2ce317fa622ff3266b32a816e10a18e6d789a5da1f23e67b4f970a68a7bcd9e18825ee274b0483896a40\"\n        }\n      ],\n      \"kernels\": [\n        {\n          \"features\": \"Plain\",\n          \"fee\": \"7000000\",\n          \"lock_height\": \"0\",\n          \"excess\": \"000000000000000000000000000000000000000000000000000000000000000000\",\n          \"excess_sig\": \"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n        }\n      ]\n    }\n  },\n  \"amount\": \"60000000000\",\n  \"fee\": \"7000000\",\n  \"height\": \"5\",\n  \"lock_height\": \"0\",\n  \"ttl_cutoff_height\": null,\n  \"payment_proof\": null,\n  \"participant_data\": [\n    {\n      \"id\": \"0\",\n      \"public_blind_excess\": \"033ac2158fa0077f087de60c19d8e431753baa5b63b6e1477f05a2a6e7190d4592\",\n      \"public_nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\",\n      \"part_sig\": null,\n      \"message\": null,\n      \"message_sig\": null\n    }\n  ]\n}\n</code></pre> <p>In version 4 of the Slate format, the initial Slate now looks like the following:</p> <pre><code>{\n  \"ver\": \"4:2\"\n  \"id\": \"0436430c-2b02-624c-2032-570501212b00\",\n  \"sta\": \"S1\",\n  \"off\": \"d202964900000000d302964900000000d402964900000000d502964900000000\",\n  \"amt\": \"6000000000\",\n  \"fee\": \"8000000\",\n  \"sigs\": [\n    {\n      \"xs\": \"023878ce845727f3a4ec76ca3f3db4b38a2d05d636b8c3632108b857fed63c96de\"\n      \"nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\",\n    }\n  ],\n}\n</code></pre> <p>While a \"return\" slate might look something like the following:</p> <pre><code>{\n  \"ver\": \"4:3\",\n  \"id\": \"0436430c-2b02-624c-2032-570501212b00\",\n  \"sta\": \"S2\",\n  \"off\": \"a4052c9200000001a6052c9200000002ed564fab50b75fc5ea32ce052fc9bebf\",\n  \"sigs\": [\n    {\n      \"xs\": \"03b0d73a044f1f9ae06cf96ef91593f121864b66bf7f7e7ac481b0ce61e39847fe\",\n      \"nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\",\n      \"part\": \"8f07ddd5e9f5179cff19486034181ed76505baaad53e5d994064127b56c5841b54735cb9ed2f59fb457144f7b1c8226d08b54cbdd0eb7e6492950751b0bb54f9\"\n    }\n  ],\n  \"coms\": [\n    {\n      \"c\": \"091582c92b99943b57955e52b5ccf1223780c2a2e55995c00c86fca2bcb46b6b9f\",\n      \"p\": \"49972a8d5b7c088e7813c3988ebe0982f8f0b12b849b1788df7da07b549408b0d6c99f80c0e2335370c104225ef5d282d79966e9044c959bedc3be03af6246fa07fc13eb3c60c90213c9f3a7a5ecf9a34c8fbaddc1a72e49e12dba9495e5aaa53bb6ac6ed63d8774707c57ab604d6bdc46de18da57a731fe336c3ccef92b4dae967417ffdae2c7d75864d46d30e287dd9cc15882e15f296b9bab0040e4432f4024be33924f112dd26c90cc800ac09a327b0ac3a661f63da9945fb1bcc82a7777d61d97cbe657675e22d035d2cf9ea03a89cfa410960ebc18a0a18b1909f4c5bef20b0fd13ffcf5a818ad8768d354b1c0f2e9b16dd7a9cf0641546f57d1945a98b8684d067dd085b90b40457e4c14665fb1b94feecf30a90f508ded16ba1bba8080a6866dffd0b1f01738fff8c62ce5e38e677835752a1b4072124dd9ff14ba8ff92126baebbb5f6e14fbb052f5d5b09aec11bfd880d7d4640a295aa83f184034d26f00cbdbabf9b89fddd7a7c9cc8c5d4b53fc39971e4495a8d984ac9607be89780fde528ee3f2d6b912908b4caf04f5c93f64431517af6b32d0b9c18255959f6903c6696ec71f615a0c877630a2d871f3f8a107fc80f306a94b6ad5790070f7d2535163bad7feae9263a9d3558ea1acecc4e61ff4e05b0162f6aba1a3b299ff1c3bb85e4109e550ad870c328bedc45fed8b504f679bc3c1a25b2b65ede44602f21fac123ba7c5f132e7c786bf9420a27bae4d2559cf7779e77f96b747b6d3ad5c13b5e8c9b49a7083001b2f98bcf242d4644537bb5a3b5b41764812a93395b7ab372c18be575e02c3763b4170234e5fddeb43420aadb71cb80f75cc681c1e7ffee3e6a8868c6076fd1da539ab9a12fef1c8cbe271b6de60100c9f82d826dc97b47b57ee9804e60112f556c1dce4f12ecc91ef34d69090b8c9d2ae9cbae38994a955cb\"\n    }\n  ]\n}\n</code></pre> <p>The 'return' slate from the recipient to the originator is expected to be larger, as it must include the recipient's outputs/inputs and proofs (as the party who posts the transaction needs all of this information). However, compacting the slate at each stage of its journey allows for future possibilities that may have been more difficult in previous iterations of the slate format. For instance, an initiator taking Grin payments might be expected to be better equipped to receive Grin transactions. They could present the payer with an invoice transaction for the amount compacted to the size of a QR code, which the payer could scan, accept, and then post back to the invoicer's listening wallet infrastructure.</p> <p>Compacting the slate also acts as a minor privacy-enhancer by hiding the initiator's outputs from the other party.</p>"},{"location":"wiki/transactions/slates/#reference-level-explanation","title":"Reference-level explanation","text":""},{"location":"wiki/transactions/slates/#slate-definition-json","title":"Slate Definition - JSON","text":"<p>Entries prefixed with <code>//</code> denote fields that may be omitted, as well as their default assumed values. <code>#</code> denotes a comment for the purposes of illustration.</p> <p>Field ordering is canonical.</p> <pre><code>{\n# These fields are always present\n  \"ver\": \"4:3\",\n  \"id\": \"0436430c-2b02-624c-2032-570501212b00\",\n  \"sta\": \"S1\",\n  \"off\": \"d202964900000000d302964900000000d402964900000000d502964900000000\",\n\n# These fields may or may not be present\n//\"num_parts: 2,\n//\"fee\": \"8000000\",\n//\"amt\": \"1000000000\",\n//\"feat\": 0,\n//\"ttl\": null,\n\n# Sigs is always present with at least one entry\n  \"sigs\": [\n    {\n      \"xs\": \"03b0d73a044f1f9ae06cf96ef91593f121864b66bf7f7e7ac481b0ce61e39847fe\",\n//    \"part\": null,\n      \"nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\",\n    }\n  ]\n\n# These structs may or may not be present\n\n//\"coms\": null,\n//\"proof\": null,\n//\"feat_args\": null\n}\n</code></pre> <p>A description of all fields and their meanings is as follows:</p>"},{"location":"wiki/transactions/slates/#top-level-slate-struct","title":"Top-Level Slate Struct","text":""},{"location":"wiki/transactions/slates/#fields","title":"Fields","text":""},{"location":"wiki/transactions/slates/#always","title":"Always","text":"<ul> <li><code>ver</code> - The slate version and supported block header version, separated by a <code>:</code></li> <li><code>id</code> - The slate's UUID, standard hex-string encoding for UUIDs</li> <li><code>sta</code> - 2 character String representing the current stage of the the transaction. See Status Codes</li> <li><code>off</code> - The running transaction offset total, hex-string encoded. All parties select a random offset at the beginning of the transaction and subtract their offset from the excess value of their outputs. They then subtract the value of the inputs from the offset when committing to inputs, updating the total offset before sending to the next stage.</li> </ul>"},{"location":"wiki/transactions/slates/#optional","title":"Optional","text":"<p>(depending on state and transaction options)</p> <ul> <li><code>num_parts</code> - The number of participants in the transaction, assumed to be 2 if omitted</li> <li><code>amt</code> - The transaction amount as a string parseable as a u64. May be omitted on a return journey.</li> <li><code>fee</code> - The transaction fee as a string parseable as a u64. May be omitted on a return journey, except during an invoice transaction.</li> <li><code>feat</code> - Kernel Features ID. If omitted, kernel is assumed to be Plain (0). If set to 1 or otherwise, any arguments required for a particular kernel feature set will be found in the <code>feat_args</code> struct.</li> <li><code>ttl</code> - Time to Live, or block height beyond which wallets should refuse to further process the transaction. Assumed 0 (no ttl) if omitted from the slate.</li> </ul>"},{"location":"wiki/transactions/slates/#structs","title":"Structs","text":""},{"location":"wiki/transactions/slates/#always_1","title":"Always","text":"<ul> <li><code>sigs</code> - An array of signature data containing the signature information of the last participant. See Signature Data</li> </ul>"},{"location":"wiki/transactions/slates/#optional_1","title":"Optional","text":"<p>(depending on state of transaction)</p> <ul> <li><code>proof</code> - An optional payment proof request. See Payment Proof Data</li> <li><code>coms</code> - The <code>Transaction;</code>(link) is removed from the slate in favour of including this top-level Slate field that can be used to reconstruct the transaction object as expected by the Grin node. See Transaction Object Fields</li> <li><code>feat_args</code> - Optional arguments for Kernel features.</li> </ul>"},{"location":"wiki/transactions/slates/#status-codes","title":"Status Codes","text":"<p>Valid values of the <code>sta</code> field and their meanings are:</p> <ul> <li><code>S1</code> - Standard (payer to payee) transaction flow, new transaction that incorporates the sender's inputs and change output(s), if any. Sender's signature nonce, excess (with kernel offset) is included and ready for sending to recipient.</li> <li><code>S2</code> - Standard transaction flow, recipient has created their outputs(s) and supplied their excess, nonce and partial signature, ready to return to recipient for completion.</li> <li><code>S3</code> - Standard transaction flow, Slate complete, contains all inputs, outputs and final signatures, and is ready for posting</li> <li><code>I1</code> - Invoice (payee to payer) transaction flow, new transaction that incorporates the Invoicer's output(s). Invoicer's signature nonce and excess (with kernel offset) is included and ready for sending to Invoicee.</li> <li><code>I2</code> - Invoice workflow, Invoicee has added their inputs and change output(s).  Invoicee's signature, nonce and excess is included and ready for sending back to the invoicer.</li> <li><code>I3</code> - Invoice workflow, Slate complete, contains all inputs, outputs and final signatures, and is ready for posting</li> </ul>"},{"location":"wiki/transactions/slates/#signature-data","title":"Signature Data","text":"<p>An entry in the <code>sigs</code> array is as follows:</p> <pre><code>{\n   \"xs\": \"03b0d73a044f1f9ae06cf96ef91593f121864b66bf7f7e7ac481b0ce61e39847fe\",\n   \"part\": null,\n   \"nonce\": \"031b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f\",\n}\n</code></pre> <p>The <code>sigs</code> struct contains is comprised of an array of participant signature data, with each entry comprising:    * <code>xs</code> - Hex string encoded short form public key on the secp256k1 curve representing the public blind excess for the participants outputs subtracted from each party's part of the offset.    * <code>part</code> - Hex string encoded Aggregated (Schnorr) secp2561k signature represeting the participant's partial sig. May be omitted if the participant does not yet have enough data to create it    * <code>nonce</code> - Hex string encoded The public key of the nonce chosen by the participant for their partial signature</p> <p>The other party's <code>sig</code> entry is removed from the slate before sending it back to the transaction initiator during the S2 and I2 phases.</p>"},{"location":"wiki/transactions/slates/#payment-proof-data","title":"Payment Proof Data","text":"<p>If included, the proof structure is:</p> <pre><code>  \"proof\": {\n    \"saddr\": \"7e008eb593ba17d116e282d6267a3c6aad87b910933ad34dfa4d7d2c92b6ba31\",\n//  \"rsig\": null,\n    \"raddr\": \"3a425bd5da5f0f78593251ede7fad0ecf7a95679d84b2cb405255d97ce068234\"\n  }\n</code></pre> <p>The <code>proof</code> struct is an optional payment proof request that must be filled out by the recipient if requested (only valid for basic transaction flow). Its fields are as follows:</p> <ul> <li><code>saddr</code> - Hex string encoded short-form public key on the ed25519 curve, representing the sender's wallet address (see the payment proofs rfc for details.</li> <li><code>raddr</code> - Hex string encoded short-form public key on the ed25519 curve represnting the recipient's wallet address</li> <li><code>rsig</code> - Hex string encoded EdDSA ed25519 signature representing the recipient's payment-proof signature. Can be omitted if this has not yet been filled out</li> </ul>"},{"location":"wiki/transactions/slates/#transaction-object-fields","title":"Transaction Object Fields","text":"<p>The V4 Version of the Slate contains its own separate representation of Grin's internal Transaction object. (Grin's internal transaction struct definition can be found here: Transaction). Internally, the wallet will transform its representation into the format expected by the node while posting the transaction.</p> <p>The <code>tx</code> struct in a V4 Slate is removed, and is replaced instead by the following Top-Level fields. Wallets recreate the transaction object as expected by the Grin node from these fields before posting.</p> <ul> <li><code>coms</code> is an array containing the outputs and inputs that have been added to the slate. These will appear during the I1 or S2 phases of a transaction. Each entry includes:</li> <li><code>f</code>: The output features, assumed to be 'Plain' if omitted. 0 denotes Plain, 1 denotes Coinbase</li> <li><code>c</code>: The output/input commitment, hex string Encoded</li> <li><code>p</code>: The output's range proof, hex string Encoded. If this is included, the entry is assumed to be an output. If not, it is an input.</li> </ul> <p>When rebuilding the transaction kernel for the Node (done during the S3 or I3 phases,) the kernel is assumed to be 'Plain' unless the top-level <code>feat</code> field is non-zero. In this case, the kernel features are filled accordingly with any needed values from the <code>feat_args</code> struct.</p> <p>In a typical S3 phase, these fields may look something like:</p> <pre><code>  \"coms\": [\n    {\n      \"c\": \"091582c92b99943b57955e52b5ccf1223780c2a2e55995c00c86fca2bcb46b6b9f\",\n      \"p\": \"49972a8d5b7c088e7813c3988ebe0982f8f0b12b849b1788df7da07b549408b0d6c99f80c0e2335370c104225ef5d282d79966e9044c959bedc3be03af6246fa07fc13eb3c60c90213c9f3a7a5ecf9a34c8fbaddc1a72e49e12dba9495e5aaa53bb6ac6ed63d8774707c57ab604d6bdc46de18da57a731fe336c3ccef92b4dae967417ffdae2c7d75864d46d30e287dd9cc15882e15f296b9bab0040e4432f4024be33924f112dd26c90cc800ac09a327b0ac3a661f63da9945fb1bcc82a7777d61d97cbe657675e22d035d2cf9ea03a89cfa410960ebc18a0a18b1909f4c5bef20b0fd13ffcf5a818ad8768d354b1c0f2e9b16dd7a9cf0641546f57d1945a98b8684d067dd085b90b40457e4c14665fb1b94feecf30a90f508ded16ba1bba8080a6866dffd0b1f01738fff8c62ce5e38e677835752a1b4072124dd9ff14ba8ff92126baebbb5f6e14fbb052f5d5b09aec11bfd880d7d4640a295aa83f184034d26f00cbdbabf9b89fddd7a7c9cc8c5d4b53fc39971e4495a8d984ac9607be89780fde528ee3f2d6b912908b4caf04f5c93f64431517af6b32d0b9c18255959f6903c6696ec71f615a0c877630a2d871f3f8a107fc80f306a94b6ad5790070f7d2535163bad7feae9263a9d3558ea1acecc4e61ff4e05b0162f6aba1a3b299ff1c3bb85e4109e550ad870c328bedc45fed8b504f679bc3c1a25b2b65ede44602f21fac123ba7c5f132e7c786bf9420a27bae4d2559cf7779e77f96b747b6d3ad5c13b5e8c9b49a7083001b2f98bcf242d4644537bb5a3b5b41764812a93395b7ab372c18be575e02c3763b4170234e5fddeb43420aadb71cb80f75cc681c1e7ffee3e6a8868c6076fd1da539ab9a12fef1c8cbe271b6de60100c9f82d826dc97b47b57ee9804e60112f556c1dce4f12ecc91ef34d69090b8c9d2ae9cbae38994a955cb\"\n    },\n    {\n      \"c\": \"087df32304c5d4ae8b2af0bc31e700019d722910ef87dd4eec3197b80b207e3045\"\n    },\n    {\n      \"c\": \"08e1da9e6dc4d6e808a718b2f110a991dd775d65ce5ae408a4e1f002a4961aa9e7\"\n    }\n  ],\n</code></pre>"},{"location":"wiki/transactions/slates/#feature-arguments","title":"Feature arguments","text":"<p>Depending on the chosen Kernel Feature set, <code>feat_args</code> may be populated with arguments specific to the kernel. The exact arguments that will be present here depend on the value of <code>feat</code>. Currently, the only supported kernel is HeightLocked (value 1) which has the arguments:</p> <pre><code>\"feat_args\": {\n   \"lock_hgt\": \"2343234\" // For HeightLocked kernels (1)\n}\n</code></pre>"},{"location":"wiki/transactions/slates/#changes-from-existing-v3-slate","title":"Changes from existing V3 Slate","text":""},{"location":"wiki/transactions/slates/#top-level-slate-struct_1","title":"Top-Level Slate Struct","text":"<ul> <li>The <code>version_info</code> struct is removed, and is replaced with <code>ver</code>, which has the format \"[version]:[block header version]\"</li> <li><code>sta</code> is added, with possible values S1|S2|S3|I1|I2|I3|NA</li> <li><code>num_participants</code> is renamed to <code>num_parts</code></li> <li><code>num_parts</code> may be omitted from the slate. If omitted its value is assumed to be 2.</li> <li><code>amount</code> is renamed to <code>amt</code></li> <li><code>amt</code> may be removed from the slate on the S2 phase of a transaction.</li> <li><code>fee</code> may be removed from the slate on the S2 phase of a transaction. It may also be omitted when initiating an I1 transaction, and added during the I2 phase.</li> <li><code>lock_height</code> is removed</li> <li><code>feat</code> is added to the slate denoting the Kernel feature set. May be omitted from the slate if kernel is plain</li> <li><code>ttl_cutoff_height</code> is renamed to <code>ttl</code></li> <li><code>ttl</code> may be omitted from the slate. If omitted its value is assumed to be 0 (no TTL).</li> <li>The <code>participant_data</code> struct is renamed to <code>sigs</code></li> <li><code>tx</code> is removed</li> <li>The <code>coms</code> (commitments) array is added, from which the final transaction object can be reconstructed</li> <li>The <code>payment_proof</code> struct is renamed to <code>proof</code></li> <li>The <code>feat_args</code> struct is added, which may be populated for non-Plain kernels</li> <li><code>proof</code> may be omitted from the slate if it is None (null),</li> <li><code>offset</code> is added, which keeps track of the running offset total as it's modified by the participants</li> </ul>"},{"location":"wiki/transactions/slates/#participant-data-sigs","title":"Participant Data (<code>sigs</code>)","text":"<ul> <li><code>public_blind_excess</code> is renamed to <code>xs</code></li> <li><code>public_nonce</code> is renamed to <code>nonce</code></li> <li><code>part_sig</code> is renamed to <code>part</code></li> <li><code>part</code> may be omitted if it has not yet been filled out</li> <li><code>message</code> is removed</li> <li><code>message_sig</code> is removed</li> <li><code>id</code> is removed. Parties can identify themselves via the keys stored in their transaction context</li> </ul>"},{"location":"wiki/transactions/slates/#payment-proof-data-proof","title":"Payment Proof Data (<code>proof</code>)","text":"<ul> <li>The <code>sender_address</code> field is renamed to <code>saddr</code></li> <li>The <code>receiver_address</code> field is renamed to <code>raddr</code></li> <li>The <code>receiver_signature</code> field is renamed to <code>rsig</code></li> <li><code>rsig</code> may be omitted if it has not yet been filled out</li> </ul>"},{"location":"wiki/transactions/slates/#pretty-printing","title":"Pretty-Printing","text":"<p>The examples above are pretty-printed for reference, but all Slates should remove all whitespace before sending to other parties. The whitespace and formatting can be re-added anywhere the Slate needs to be presented for debugging.</p>"},{"location":"wiki/transactions/slates/#slate-definition-binary","title":"Slate Definition - Binary","text":"<p>While the JSON slate remains the first-order slate definition, and should be accepted by all wallets and APIs, wallets should also have the ability to transform slates between the JSON format and a reduced binary format suitable for armoring or direct transfer. The definition of the V4 binary slate format follows.</p> <p>All integer values are Big-Endian.</p> Slate V4 Field type len notes <code>ver.slate_version</code> u16 2 <code>ver.block_header_version</code> u16 2 <code>id</code> Uuid 16 binary Uuid representation <code>sta</code> u8 1 See Status Byte <code>offset</code> BlindingFactor 32 Optional field status u8 1 See Optional Field Status <code>num_parts</code> u8 (1) If present <code>amt</code> u64 (8) If present <code>fee</code> u64 (8) If present <code>feat</code> u8 (1) If present <code>ttl</code> u64 (8) If present <code>sigs</code> entries struct varies See Sigs Entries Optional struct status u8 1 See Optional Struct Status <code>coms</code> entries struct (varies) If present. See Coms Entries <code>proof</code> struct (varies) If present. See Proof <code>feat_args</code> entries struct (varies) If present. See Feature Args"},{"location":"wiki/transactions/slates/#status-byte","title":"Status Byte","text":"<p>Encodes slate status (<code>sta</code>) field, mapped as follows:</p> State value <code>NA</code> (Unknown) 0 <code>S1</code> 1 <code>S2</code> 2 <code>S3</code> 3 <code>I1</code> 4 <code>I2</code> 5 <code>I3</code> 6"},{"location":"wiki/transactions/slates/#optional-field-status","title":"Optional Field Status","text":"<p>A bit field that denotes the presence or absence of the optional slate fields. Each bit is mapped to particular slate field as follows:</p> Bit 7 6 5 4 3 2 1 0 field <code>ttl</code> <code>feat</code> <code>fee</code> <code>amt</code> <code>num_parts</code> <p>If the corresponding field for a bit is 1, the field is present and must be read accordingly.</p>"},{"location":"wiki/transactions/slates/#sigs-entries","title":"Sigs Entries","text":"<p>Sigs Entries contains a length-prefixed array of entries corresponding to the <code>sigs</code> struct.</p> Field type len notes length u8 1 entries struct varies array of entries, see below <p>Each Sigs Entry is structured as follows:</p> Field type len notes complete flag u8 1 If non-zero, entry contains <code>part</code> <code>xs</code> secp256k1 Public Key 33 <code>nonce</code> secp256k1 Public Key 33 <code>part</code> secp256k1 AggSig (64) If present"},{"location":"wiki/transactions/slates/#optional-struct-status","title":"Optional Struct Status","text":"<p>A bit field that denotes the presence or absence of the optional slate structures. Each bit is mapped to particular slate structure as follows:</p> Bit 7 6 5 4 3 2 1 0 struct <code>proof</code> <code>coms</code> <p>If the corresponding field for a struct is 1, the struct is present and must be read accordingly.</p>"},{"location":"wiki/transactions/slates/#coms-entries","title":"Coms Entries","text":"<p>Coms Entries contains a length-prefixed array of entries corresponding to the <code>coms</code> struct.</p> Field type len notes length u16 2 entries struct varies array of entries, see below <p>Each Coms Entry is structured as follows:</p> Field type len notes output flag u8 1 If non-zero, entry is output and contains <code>p</code> (proof) <code>f</code> u8 1 features (1 = Coinbase, 0 = Plain) <code>c</code> Commitment 33 <code>p</code> Rangeproof 675 If present"},{"location":"wiki/transactions/slates/#proof","title":"Proof","text":"<p>Optional Payment proof, with fields as follows</p> Proof Field type len notes <code>saddr</code> ed25519 Public Key 32 <code>raddr</code> ed25519 Public Key 32 rsig flag u8 1 If non-zero, <code>rsig</code> field is present <code>rsig</code> ed25519 EDCSA Sig (64) If present"},{"location":"wiki/transactions/slates/#feature-args","title":"Feature Args","text":"<p>Optional feature args, presence or absence of which should be determined by the value of the <code>feat</code> field. Currently only present if <code>feat</code> is 2.</p> Field type len notes <code>lock_hgt</code> u64 8 Lock height, present if <code>feat</code> is 2"},{"location":"wiki/transactions/slates/#unresolved-questions","title":"Unresolved questions","text":"<ul> <li>Is block header version needed?</li> <li>NRD Kernels need to be included</li> </ul>"},{"location":"wiki/transactions/slates/#future-possibilities","title":"Future possibilities","text":"<p>This RFC is envisaged as a necessary first step for all slate-exchange possibilities that would benefit from compactness, e.g:</p> <ul> <li>QR Code encoding of slates</li> <li>Armored slates</li> <li>Slatepack</li> </ul>"},{"location":"wiki/transactions/transaction-body/","title":"Transaction Body","text":"<p>General format of a Transaction Body in a Mimblewimble/Grin is basically a Mimblewimble transaction which consists of a list of Inputs, Outputs and Kernels.</p> Field Description Size # inputs Number of inputs 8 bytes # outputs Number of outputs 8 bytes # kernels Number of kernels 8 bytes inputs Serialized inputs 34 bytes per input outputs Serialized outputs 42 bytes per output kernels Serialized kernels x bytes per kernel <p>The kernel size x depends on the kernel type. More details in its dedicated section below.</p>"},{"location":"wiki/transactions/transaction-body/#inputs","title":"Inputs","text":"<p>Each of the inputs consists of Feature and a Commitment.</p> Field Description Size Feature Plain (0x00) or Coinbase (0x01) 1 byte Commitment Pedersen commitment 33 bytes"},{"location":"wiki/transactions/transaction-body/#outputs","title":"Outputs","text":"<p>Just as in case of the inputs, the outputs consist of Feature and a Commitment but in addition they also hold Range proofs</p> Field Description Size Feature Plain (0x00) or Coinbase (0x01) 1 byte Commitment Pedersen commitment 33 bytes Range proof size x Proves the transaction is net positive 8 bytes Range proof Proves the transaction is net positive x bytes <p>Note that the range proof is of a variable size which is indicated by its first 8 bytes.</p>"},{"location":"wiki/transactions/transaction-body/#kernels","title":"Kernels","text":"<p>Every kernel starts with Kernel feature which indicates how it should be deserialized. In each variant, the kernel concludes with an Excess commitment and a Excess signature. What differs them is what is in the middle. We will describe each variant separately</p>"},{"location":"wiki/transactions/transaction-body/#coinbase-kernel","title":"Coinbase kernel","text":"<p>This kernel is used for coinbase outputs that collect both the fixed block subsidy of 60 Grin and all the transaction fees in the block.</p> Field Description Size Feature Plain (0x00), Coinbase (0x01), Height Locked (0x02) or No recent duplicate (0x03) 1 byte Excess commitment Pedersen commitment 33 bytes Excess signature Schnorr signature 64 bytes"},{"location":"wiki/transactions/transaction-body/#plain-kernel","title":"Plain kernel","text":"<p>A kernel resulting from a transaction, unlike Coinbase kernel it also includes Fee billed for the transaction.</p> Field Description Size Feature Plain (0x00), Coinbase (0x01), Height Locked (0x02) or No recent duplicate (0x03) 1 byte Fee Transaction fee 8 bytes Excess commitment Pedersen commitment 33 bytes Excess signature Schnorr signature 64 bytes"},{"location":"wiki/transactions/transaction-body/#height-locked-kernels","title":"Height locked kernels","text":"<p>The first protocol kernel would always consist of Feature, Fee, Lock height and standard Excess commitment and Signature. Starting from the V2 protocol a specific type of kernel - height locked kernel supports the lock height.</p> Field Description Size Feature Plain (0x00), Coinbase (0x01), Height Locked (0x02) or No recent duplicate (0x03) 1 byte Fee Transaction fee 8 bytes Lock height Block height starting from which the kernel becomes valid 8 bytes Excess commitment Pedersen commitment 33 bytes Excess signature Schnorr signature 64 bytes"},{"location":"wiki/transactions/transaction-body/#nrd-no-recent-duplicate-kernels","title":"NRD (No Recent Duplicate) kernels","text":"<p>An NRD kernel is only valid in the absence of an identical instance existing within the last relative-height blocks. More information is available in the NRD kernel RFC as well as in the mailing list archive.</p> Field Description Size Feature Plain (0x00), Coinbase (0x01), Height Locked (0x02) or No recent duplicate (0x03) 1 byte Fee Transaction fee 8 bytes Relative lock height Number of most recent blocks in which the same NRD must be absent 8 bytes Excess commitment Pedersen commitment 33 bytes Excess signature Schnorr signature 64 bytes"}]}